#!/bin/sh
# Brute Force Hack Conversion from ECSL to MoML
# Author:  Christopher Brooks
# Version: $Id$
#
# Copyright (c) 2004 The Regents of the University of California.
# 	All Rights Reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY


# Usage: ecsl2moml ecslfile

if [ $# -ne 1 ]; then
    echo "$0: Usage: $0 ecslfile"
    echo "   Read in ecslfile, generate a MoML file with the same base name"
    echo "   ecslfile should end in .xml"
    exit 2
fi

input=$1
if [ ! -r $input ]; then
    echo "$0: $input is not readable. Exiting."
    exit 3
fi

modelname=`basename $input .xml`
output="$modelname.moml"

tmpfile1=/tmp/ecsl2moml.$$.1
tmpfile2=/tmp/ecsl2moml.$$.2

# Add the MoML Header and get rid of RootFolder
awk '{
    if ($0 ~ /<RootFolder/) {
        print "<?xml version=\"1.0\" standalone=\"no\"?>"
        print "<!DOCTYPE entity PUBLIC \"-//UC Berkeley//DTD MoML 1//EN\""
        print "    \"http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd\">"
    } else if ($0 ~ /<\/RootFolder>/) {
        # Print nothing
    } else {
        print $0
    }
}' modelname=${modelname} $input > $tmpfile1

# Get rid of the StateFlow section.  FIXME: eventually, deal with this
awk '
    $0 ~ /<Stateflow/ { sawStateFlow = 1 }
    sawStateFlow == 0 { print $0}
    $0 ~ /<\/Stateflow/ { sawStateFlow = 0 }
' < $tmpfile1 > $tmpfile2

# Get rid of the enclosing <Dataflow..> </Dataflow>
grep -v "<Dataflow" $tmpfile2 | grep -v "</Dataflow" > $tmpfile1

# Convert <System ... to <entity
awk ' {
    if ($0 ~ /<System/) {
       # Get the value of the name field
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /name=$/) {
               name = f[i+1]
               break;
           }
       }
       indent = substr($0, 0, index($0,"<") - 1)  
       # Sometimes we have <System ... />
       print indent "<entity name=\"" name "\" class=\"ptolemy.actor.TypedCompositeActor\"" f[nf]
       
       if (sawFirstEntity == 0) {
           sawFirstEntity = 1
           # Add the director
           print "    <property name=\"CT Director\" class=\"ptolemy.domains.ct.kernel.CTMixedSignalDirector\">"
           print "        <property name=\"stopTime\" class=\"ptolemy.data.expr.Parameter\" value=\"10.0\">"
           print "        </property>"
           print "        <property name=\"ODESolver\" class=\"ptolemy.data.expr.Parameter\" value=\"&quot;ptolemy.domains.ct.kernel.solver.ExplicitRK23Solver&quot;\">"
           print "            <property name=\"style\" class=\"ptolemy.actor.gui.style.EditableChoiceStyle\">"
           print "                <property name=\"choice0\" class=\"ptolemy.data.expr.Parameter\" value=\"&quot;ptolemy.domains.ct.kernel.solver.ExplicitRK23Solver&quot;\">"
           print "                </property>"
           print "                <property name=\"choice1\" class=\"ptolemy.data.expr.Parameter\" value=\"&quot;ptolemy.domains.ct.kernel.solver.BackwardEulerSolver&quot;\">"
           print "                </property>"
           print "                <property name=\"choice2\" class=\"ptolemy.data.expr.Parameter\" value=\"&quot;ptolemy.domains.ct.kernel.solver.ForwardEulerSolver&quot;\">"
           print "                </property>"
           print "            </property>"
           print "        </property>"
           print "        <property name=\"breakpointODESolver\" class=\"ptolemy.data.expr.Parameter\" value=\"&quot;ptolemy.domains.ct.kernel.solver.DerivativeResolver&quot;\">"
           print "            <property name=\"style\" class=\"ptolemy.actor.gui.style.EditableChoiceStyle\">"
           print "                <property name=\"choice0\" class=\"ptolemy.data.expr.Parameter\" value=\"&quot;ptolemy.domains.ct.kernel.solver.DerivativeResolver&quot;\">"
           print "                </property>"
           print "                <property name=\"choice1\" class=\"ptolemy.data.expr.Parameter\" value=\"&quot;ptolemy.domains.ct.kernel.solver.BackwardEulerSolver&quot;\">"
           print "                </property>"
           print "                <property name=\"choice2\" class=\"ptolemy.data.expr.Parameter\" value=\"&quot;ptolemy.domains.ct.kernel.solver.ImpulseBESolver&quot;\">"
           print "                </property>"
           print "            </property>"
           print "        </property>"
           print "        <property name=\"_location\" class=\"ptolemy.kernel.util.Location\" value=\"{75.0, 40.0}\">"
           print "        </property>"
           print "    </property>"
        }  
    } else if ($0 ~ /<\/System>/) {
       # FIXME: If we have <System ... />, then the indent might be wrong?
       print indent "</entity>"
    } else {
       print $0
    }   
}' < $tmpfile1 > $tmpfile2


# Convert <Annotation to MoML Annotation
awk ' {
    if ($0 ~ /<Annotation/) {

       # Get the value of the Text field
       text=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /Text=$/) {
               text = f[i+1]
               break;
           }
       }
       if (length(text) > 0) {
           indent = substr($0, 0, index($0,"<") - 1)  
           annotationCount++
           print indent "<property name=\"annotation" annotationCount "\" class=\"ptolemy.kernel.util.Attribute\">"
           print indent "    <property name=\"_hideName\" class=\"ptolemy.kernel.util.SingletonAttribute\">"
           print indent "    </property>"
           print indent "    <property name=\"_iconDescription\" class=\"ptolemy.kernel.util.SingletonConfigurableAttribute\">" 
           print indent "        <configure><svg><text x=\"20\" y=\"20\" style=\"font-size:14; font-family:SansSerif; fill:red\">" text "</text></svg></configure>"
           print indent "    </property>"
           print indent "    <property name=\"_smallIconDescription\" class=\"ptolemy.kernel.util.SingletonConfigurableAttribute\">"
           print indent "    <configure>"
           print indent "        <svg>"
           print indent "        <text x=\"20\" style=\"font-size:14; font-family:SansSerif; fill:blue\" y=\"20\">-A-</text>"
           print indent "        </svg>"
           print indent "    </configure>"
           print indent "    </property>"
           print indent "    <property name=\"_controllerFactory\" class=\"ptolemy.vergil.basic.NodeControllerFactory\">"
           print indent "    </property>"
           print indent "    <property name=\"_editorFactory\" class=\"ptolemy.vergil.toolbox.AnnotationEditorFactory\">"
           print indent "    </property>"
           print indent "    <property name=\"_location\" class=\"ptolemy.kernel.util.Location\" value=\"15.0, 275.0\">"
           print indent "    </property>"
           print indent "    <property name=\"_icon\" class=\"ptolemy.vergil.icon.XMLIcon\">"
           print indent "    </property>"

           print indent "</property>"
        }
    } else {
        print $0
    }
} ' < $tmpfile2 > $tmpfile1


# Convert <Line to <relation
awk ' {
    if ( $1 ~ /<Line/) {
       # Get the value of the _id field
       id=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /_id=$/) {
               id = f[i+1]
               break;
           }
       }
       indent = substr($0, 0, index($0,"<") - 1)  
       print indent "<relation name=\"" id "\" class=\"ptolemy.actor.TypedIORelation\"/>"

       if ($0 ~ /dstLine_end_/) {
           # Get the value of the dstLine_end_ field
           dstLine_end_=""
           nf = split($0, f, "\"")   
           for (i = 1; i <= nf; i++) {
               if ( f[i] ~ /dstLine_end_=$/) {
                   dstLine_end_ = f[i+1]
                   break;
               }
           }
          #print indent "<link port=\"" dstLine_end_ "\" relation=\"" id "\"/>" 

           # Get the value of the srcLine_end_ field
           srcLine_end_=""
           nf = split($0, f, "\"")   
           for (i = 1; i <= nf; i++) {
               if ( f[i] ~ /srcLine_end_=$/) {
                   srcLine_end_ = f[i+1]
                   break;
               }
           }
          #print indent "<link port=\"" srcLine_end_ "\" relation=\"" id "\"/>" 
       }

    } else {
        print $0
    }
}' < $tmpfile1 > $tmpfile2


# Convert <Primitive to <entity
awk 'BEGIN {
    map["Abs"] = "ptolemy.actor.lib.AbsoluteValue"
    map["Clock"] = "ptolemy.actor.lib.Clock"
    map["Constant"] = "ptolemy.actor.lib.Const"
    map["Demux"] = "ptolemy.actor.lib.Select"
    # FIXME
    map["DiscreteFilter"] = "ptolemy.domains.de.lib.EventFilter"
    map["DiscretePulseGenerator"] = "ptolemy.actor.lib.Pulse"
    map["Display"] = "ptolemy.actor.lib.gui.Display"
    # FIXME
    map["From"] = "ptolemy.actor.lib.Stop"
    map["Gain"] = "vendors.ecsl_dp.ptolemy.ECSLGain"
    # FIXME
    map["Goto"] = "ptolemy.actor.lib.Stop"
    map["Ground"] = "ptolemy.actor.lib.Discard"
    map["Integrator"] = "ptolemy.domains.ct.lib.Integrator"
    #map["Integrator"] = "vendors.ecsl_dp.ptolemy.IntegratorComposite"
    map["Logic"] = "ptolemy.actor.lib.logic.LogicFunction"
    map["Merge"] = "ptolemy.domains.de.lib.Merge"
    # FIXME: should be Minimum or Maximum 
    map["MinMax"] = "ptolemy.actor.lib.Maximum"
    # FIXME
    map["MultiPortSwitch"] = "ptolemy.actor.lib.Switch"
    map["Mux"] = "ptolemy.actor.lib.Multiplexor"
    map["Product"] = "ptolemy.actor.lib.MultiplyDivide"
    # FIXME
    map["RelationalOperator"] = "ptolemy.actor.lib.logic.Comparator"
    map["S-Function"] = "ptolemy.matlab.Expression"
    # FIXME
    map["Saturate"] = "ptolemy.actor.lib.Quantizer"
    #map["Scope"] = "ptolemy.actor.lib.gui.TimedPlotter"
    map["Scope"] = "vendors.ecsl_dp.ptolemy.Scope"
    map["Signum"] = "ptolemy.actor.lib.Quantizer"
    # FIXME: set to Sin
    map["Sin"] = "ptolemy.actor.lib.TrigFunction"
    # FIXME Leave off sampleTime, convert integers to doubles
    map["Step"] = "ptolemy.domains.ct.lib.ContinuousClock"
    #map["Step"] = "vendors.ecsl_dp.ptolemy.Step"
    #map["Sum"] = "ptolemy.actor.lib.AddSubtract"
    map["Sum"] = "vendors.ecsl_dp.ptolemy.ECSLSum"
    map["Switch"] = "ptolemy.actor.lib.Switch"
    map["Terminator"] = "ptolemy.actor.lib.Stop"
    # FIXME
    map["ToWorkspace"] = "ptolemy.actor.lib.Stop"
    map["UnitDelay"] = "ptolemy.domains.de.lib.TimedDelay"
    map["ZeroOrderHold"] = "ptolemy.domains.ct.lib.ZeroOrderHold"
}
{
    if ($1 ~ /<Primitive/) {
       # Get the value of the name field
       name=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /name=$/) {
               name = f[i+1]
               break;
           }
       }

       # Get the value of the position field
       position=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /osition=$/) {
               position = f[i+1]
               break;
           }
       }
       split(position, p, ",")
       x = substr(p[1], 2, length(p[1])) / 2.4
       y = substr(p[2], 1, length(p[2]) - 1) / 2.4

       # Get the value of the BlockType field
       blockType=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /BlockType=$/) {
               blockType = f[i+1]
               break;
           }
       }
       indent = substr($0, 0, index($0,"<") - 1)  
       print indent "<entity name=\"" name "\" class=\"" map[blockType] "\">"
       print indent "    <property name=\"_location\" class=\"ptolemy.kernel.util.Location\" value=\"[" x ", " y "]\">"
       print indent "     </property>"
    } else if ($1 ~ /<\/Primitive>/) {
        print indent "</entity>"
    } else {
        print $0
    }
} ' < $tmpfile2 > $tmpfile1


relationsFile=ecsl2moml.relations
rm -f $relationsFile

# Convert OutputPort and InputPort
awk '
$0 ~ /<entity/ {
       # Get the value of the name field
       name=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /name=$/) {
               name = f[i+1]
               break;
           }
       }
       containerCount += 1
       containerStack[containerCount] = name

       # Get the value of the class field
       class=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /class=$/) {
               class = f[i+1]
               break;
           }
       }
}
{
    if ($1 ~ /<OutputPort/ || $1 ~ /<InputPort/ || $1 ~ /<TriggerPort/) {
       # Get the value of the name field
       name=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /name=$/) {

               name = f[i+1]
               break;
           }
       }
       # Remap names like In1 to input
       if (name ~ /^In[0-9]*$/) {
           oldName = name
           name = "input"
   
       }

       if (name ~ /^Out[0-9]*$/) {
           oldName = name
           name = "output"
       }

       # Get the value of the dstLine field
       dstLine=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /dstLine=$/) {
               dstLine = f[i+1]
               break;
           }
       }
       # Get the value of the srcLine field
       srcLine=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /srcLine=$/) {
              srcLine = f[i+1]
              break;
           }
       }
 
       # First, we handle the usual case where OutputPort only
       # has a dstLine field
       if ($1 ~ /<OutputPort/) {
           relation = dstLine
       } else {
           relation = srcLine
       }

       indent = substr($0, 0, index($0,"<") - 1)  

       print indent "<port name=\"" name "\" class=\"ptolemy.actor.TypedIOPort\">"
       if ($1 ~ /<OutputPort/) {
           print "<property name=\"output\"/>"
       } else if ($1 ~ /<InputPort/) {
           print "<property name=\"input\"/>"
       }  

       longName = containerStack[containerCount] "." name

       if (index(relation, " ") != 0) {
           if (class == "ptolemy.domains.ct.lib.Integrator") { 
               # The class cannot handle a multiport, so add a relation.
               addRelationsContainer[longName] = containerStack[containerCount]
               addRelations[longName] = name
               name = name "_multiPort"
               longName = containerStack[containerCount] "_" name

           } else { 
               # The relation name has spaces in it, so this is a multiport
               print indent "    <property name=\"multiport\"/>"
           }
       }


       if (class == "vendors.ecsl_dp.ptolemy.ECSLSum" \
               && name == "input" ) {
           # FIXME: Connect the first Input to minus, the second to plus
           if (oldName == "In1") {
               longName = containerStack[containerCount] ".plus"
           } else if (oldName == "In2") {
               longName = containerStack[containerCount] ".minus"
           }
       }

       print indent "</port>"

       if (length(links[longName]) == 0) { 
           links[longName] = relation
       } else {
           # Already have a relation for this longName
           links[longName] = links[longName] " " relation
       }

       # Second, we handle the case where OutputPort 
       # has a dstLine field _and_ a srcLine field
       if ($1 ~ /<OutputPort/ && length(srcLine) > 0) {
           longName = containerStack[containerCount] "." name
           # FIXME: this needs to be linked in the container???
           #links[longName] = srcLine
       } else if ($1 ~ /<InputPort/ && length(dstLine) > 0) {
           longName = containerStack[containerCount] "." name
           # FIXME: this needs to be linked in the container???
           #links[longName] = dstLine
       }       
    } else {
        print $0
    }
}
$1 ~ /<\/entity>/ {
    container = containerStack[containerCount] 
    containerCount -= 1         
    indent = substr($0, 0, index($0,"<") - 1)  


    # Handle places where we need to add a relation
    for (addRelation in addRelations) {
       if ( length(addRelations[addRelation]) > 0 ) {
           addRelationsFullName = addRelationsContainer[addRelation] "_" addRelations[addRelation] "_multiPort"
           print indent "<relation name=\"" addRelationsFullName "\" class=\"ptolemy.actor.TypedIORelation\"/>"
           print indent "<link port=\"" addRelation "\" relation=\"" addRelationsFullName "\"/>" 
       }
    }


    # We need to add the link statements outside the container.
    # Sometimes, containers are nested, getting the links right is tricky.
    for ( link in links) {
       if ( length(links[link]) > 0 \
          &&  substr(link, 0, length(container)) == container ) {
          # We have not yet printed this link, and it is for
          # the container we just exited.

          # Sometimes a dstLine will have many relations listed
          # dstLine="id32b id32c id32d id32e"

          relation = links[link]
          if (index(relation, " ") == 0) {
              # No spaces is the relation name
              print indent "<link port=\"" link "\" relation=\"" relation "\"/>" 
          } else {
              nf = split(relation, relations, " ") 
              for(i = 1; i <= nf; i++) {
                  # If the port is an addRelations port, then
                  # we will substitute n the next awk run
                  addRelationsHack = 0
                  for (addRelation in addRelations) {
                      if ( length(addRelations[addRelation]) > 0 ) {
                           addRelationsFullName = addRelationsContainer[addRelation] "_" addRelations[addRelation] "_multiPort"
                           if (link == addRelationsFullName) {
                               addRelationsHack = 1
                               # Now we write sed commands to a file
                               # for processing in the next step.
 
                               # Delete the creation of the relation
                               print "s/[ 	]*<relation name=\"" relations[i] "\".*$//" >"ecsl2moml.relations"

                               # Substitute our relation in 
                               print "s/relation=\"" relations[i] "\"/relation=\"" addRelationsFullName "\"/" >"ecsl2moml.relations"

                           }
                       }
                  } 
                  if (addRelationsHack == 0) {
                      print indent "<link port=\"" link "\" relation=\"" relations[i] "\"/>"
                  }
              }
          }
          links[link] = ""  
       }

    }
    for (addRelation in addRelations) {
       if ( length(addRelations[addRelation]) > 0 ) {
          addRelations[addRelation] = ""
       }
    }
}' < $tmpfile1 > $tmpfile2

# Substitute relation names for relations where we had to add a port
sed -f ecsl2moml.relations < $tmpfile2 > $tmpfile1 

# Parameter
awk '{
    if ($1 ~ /<entity/) {
       # Get the value of the class field
       class=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /class=$/) {
               class = f[i+1]
               break;
           }
       }
    }
    if ($1 ~ /<Parameter/) {
       # Get the value of the name field
       name=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /name=$/) {
               name = f[i+1]
               break;
           }
       }

       # Get the value of the value field
       value=""
       nf = split($0, f, "\"")   
       for (i = 1; i <= nf; i++) {
           if ( f[i] ~ /Value=$/) {
               value = f[i+1]
               break;
           }
       }
       indent = substr($0, 0, index($0,"<") - 1)  
       # FIXME: do more with types?
       propertyClass = "ptolemy.data.expr.Parameter"
       if (class == "vendors.ecsl_dp.ptolemy.ECSLSum") {
           if (name == "Inputs" || name == "IconShape") {
               propertyClass = "ptolemy.data.expr.StringParameter"
           }
       }
       print indent "<property name=\"" name "\" class=\"" propertyClass "\" value=\"" value "\"/>"
    } else {
       print $0
    } 
} ' < $tmpfile1 > $tmpfile2


cp $tmpfile2 $output

rm -f $tmpfile1 $tmpfile2