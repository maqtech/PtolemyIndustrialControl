/* Input file to JJTree and JavaCC to generate Ptolemy II Parser */

options {
LOOKAHEAD=1;
//DEBUG_PARSER = true;
//DEBUG_TOKEN_MANAGER = true;
MULTI = true;
STATIC = false;
}

PARSER_BEGIN(PtParser)
/* 
 Copyright (c) 1998 The Regents of the University of California.
 All rights reserved.
 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the above
 copyright notice and the following two paragraphs appear in all copies
 of this software.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.
 
                                        PT_COPYRIGHT_VERSION_2
                                        COPYRIGHTENDKEY

@ProposedRating Yellow (nsmyth@eecs.berkeley.edu)

Created : May 1998

*/

package ptolemy.data.expr;

import ptolemy.kernel.*;
import ptolemy.kernel.util.*;
import ptolemy.data.*;

import java.io.*;

//////////////////////////////////////////////////////////////////////
//// PTParser.jjt
/** 
This file implements an expression parser for Ptolemy II using the 
JavaCC parser generator. It can handle all the basic arithmetic operators
(*, /, +, -,, %), relational operators (<, <=, >, >=, == !=), logical 
operators(&&, ||, !), bitwise operators (&, |, ^, ~)  and, using 
reflection, all of the functionality available in the java.lang.Math 
package. 
<p>
By editing the ASTFunctionNode file it is also relatively 
easy to allow references to other functions. This provides an easy mechanism 
to extend the range to the parser e.g. have a tcl(...) function 
that passes the string to a Tcl interpreter and retuns the result.
<p>
Functional if is supported via the following syntax:
        (boolean) ? (value1) : (value2)
<p>
Extensibility is also supported by allowing method calls on the Tokens,
the syntax is 
        (value1).method(comma separated arguments)
<p>
JavaCC by itself simply generates a file (and support files) that allow an 
input to be parsed, it does not return a parse tree. For the purposes of 
type checking we require a parse tree, and this is obtained using JJTree, a 
preprocesssor for JavaCC. 
<p>
JJtree operates by annotating the grammar file to support the generation
of the parse tree. Thus the process is
<p>
<center>X.jjt --> JJTREE --> X.jj --> JAVACC --> X.java + support files
<br>
</CENTER>
<p>
The parser can also be passed a symbol table of ptolemy.data.expr.Parameters 
which the expression to be parsed can reference.
<p>
Anything between quotes(") is taken to be one string.
<p>
The expressions recognized follow as close as possible the syntax of Java.
In particular the operator precedences implemented here follow exactly 
those in Java. Any type conversions that are performed are lossless. If 
the user wants lossy conversions, explicit casts will be necessary.
<p>
For a more thorough description of what the Parser is designed to do, 
please consult the Ptolemy II design document (or contact nsmyth@eecs)

@author Neil Smyth
@version $Id$

@see ptolemy.data.expr.ASTPtFunctionNode
@see ptolemy.data.expr.ASTPtFunctionalIfNode
@see ptolemy.data.expr.ASTPtLeafNode
@see ptolemy.data.expr.ASTPtLogicalNode
@see ptolemy.data.expr.ASTPtMethodCallNode
@see ptolemy.data.expr.ASTPtProductNode
@see ptolemy.data.expr.ASTPtRelationalNode
@see ptolemy.data.expr.ASTPtRootNode
@see ptolemy.data.expr.ASTPtSumNode
@see ptolemy.data.expr.ASTPtUnaryNode
@see ptolemy.data.Token 
*/
public class PtParser {
    /** Stores the parameters to which the input expression can reference
     */
    private NamedList _scope;

    /** The Parameter (or other ParameterListener) creating the parser. 
     *  Each time another parameter is referenced in the input expression, 
     *  this Parameter is registered as a listener of that parameter. 
     *  If null, then no dependency is registered.
     */
    private ParameterListener _listener;

    boolean debug = false;
    
    public PtParser(ParameterListener parameter) {
        this(new ByteArrayInputStream("a hack!!".getBytes()));
        _listener = parameter;
    }

    public PtParser() {
        this(new ByteArrayInputStream("a hack!!".getBytes()));
    }

    /** Generates a parse tree from the given String. The root node is 
     *  returned. To evaluate the parse tree, the method evaluateParseTree()
     *  should be called on the rootNode
     *  @param stringIn The expression to be parsed
     *  @exception IllegalArgumentException Thrown if the parse failed.
     *  @return The root node of the parse tree.
     */
    public ASTPtRootNode  generateParseTree(String stringIn) throws IllegalArgumentException {
        InputStream stream = new ByteArrayInputStream(stringIn.getBytes());
        this.ReInit(stream);
        //debug = true;
        String str = stringIn.replace('\n', ' ');
        if (debug) { 
            System.out.print("\nParsing expression: ");
            System.out.println(str);
        }
        try {
            // First parse the expression to obtain the parse tree
            ASTPtRootNode rootNode = start();
            if (debug) rootNode.displayParseTree(" ");
            return rootNode;
        } catch (ParseException x) {
            str = "parse of " + stringIn + " failed: " + x.getMessage();
            throw new IllegalArgumentException(str);
        }
    }  

    /** Generates a parse tree from the given String. The root node is 
     *  returned. To evaluate the parse tree, the method evaluateParseTree()
     *  should be called on the rootNode
     *  @param stringIn The expression to be parsed.
     *  @param scope Parameters to which the expression can refer.
     *  @exception IllegalArgumentException Thrown if the parse failed.
     *  @return The root node of the parse tree.
     */
    public ASTPtRootNode generateParseTree(String stringIn, NamedList scope) throws IllegalArgumentException {
        _scope = scope;
        ASTPtRootNode rootNode;
        try {
            rootNode = generateParseTree(stringIn);
        } catch (IllegalArgumentException ex) {
            throw ex;
        } finally {
            // need to make sure Parser state is reset
            _scope = null;
        } 
        return rootNode;
    }
}

PARSER_END(PtParser)


/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


/* Now come to proper tokens */

SKIP :
{
 	" "
  |	"\r"
  |	"\t"
}

TOKEN :
{
	< EOL: "\n" >
}

TOKEN : /* Arithmetic operators */
{
	< PLUS: "+" >
  |	< MINUS: "-" >
  |	< MULTIPLY: "*" >
  |	< DIVIDE: "/" >
  |     < MODULO: "%" >
}

TOKEN : /* Relational operators */
{
	< GT: ">" >
  |	< LT: "<" >
  |	< GTE: ">=" >
  |	< LTE: "<=" >
  |     < NOTEQUALS: "!=" >
  |     < EQUALS: "==" >
}

TOKEN : /* Boolean & bitwise operators */
{
	< COND_AND: "&&" >
  |	< COND_OR: "||" >
  |     < BOOL_NOT: "!" >
  |     < BITWISE_NOT: "~" >                          
  |	< AND: "&" >
  |     < OR: "|" >
  |     < XOR: "^" >  

}

TOKEN : /* Numeric literals */
{
  < INTEGER:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < DOUBLE:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}

TOKEN : /*Boolean literals */
{
    <BOOLEAN : ( "TRUE" | "true" | "True" | "FALSE" | "false" | "False") >
}

TOKEN : /* Function names */
{
	< ID: ( <LETTER> )+ (["0"-"9", "$", "@", "#", "[", "]" ] | <LETTER> )* >
  | 	< #LETTER: ["a"-"z", "A"-"Z", "_"] > 		
} 

TOKEN : /* literal strings */
{
        < STRING: <QUOTE> ( "\\\"" | ~["\""])* <QUOTE> >
  |     < #QUOTE: "\"" >
}

ASTPtRootNode start() #PtRootNode :
{}
{
    funcIf() ( <EOL> | <EOF> )?
	{ return jjtThis; }
}

void funcIf() #void :
{}
{
   (
           logicalOr() ( "?" logicalOr() ":" logicalOr() )?
   ) #PtFunctionalIfNode(>1)
}

void logicalOr() #void :
{Token x;}
{
   (
           logicalAnd() ( 
                   x = <COND_OR> logicalAnd()
                   {  jjtThis._lexicalTokens.insertLast(x); }
           )*
   ) #PtLogicalNode(>1)
}

void logicalAnd() #void :
{Token x;}
{
   (
           bitwiseOr() ( 
                   x = <COND_AND> bitwiseOr()
                   {  jjtThis._lexicalTokens.insertLast(x); }
           )*
   ) #PtLogicalNode(>1)
}

void bitwiseOr() #void :
{Token x;}
{
   (
           bitwiseXor() ( 
                   x = <OR> bitwiseXor()
                   {  jjtThis._lexicalTokens.insertLast(x); }
           )*
   ) #PtBitwiseNode(>1)
}

void bitwiseXor() #void :
{Token x;}
{
   (
           bitwiseAnd() ( 
                   x = <XOR> bitwiseAnd()
                   {  jjtThis._lexicalTokens.insertLast(x); }
           )*
   ) #PtBitwiseNode(>1)
}

void bitwiseAnd() #void :
{Token x;}
{
   (
           logicalEquals() ( 
                   x = <AND> logicalEquals()
                   {  jjtThis._lexicalTokens.insertLast(x); }
           )*
   ) #PtBitwiseNode(>1)
}

void logicalEquals() #void :
{Token x;}
{
   (
           relational() ( 
                   ( x = <EQUALS> | x = <NOTEQUALS> ) relational()
                   {
                       jjtThis._lexicalTokens.insertLast(x);
                   }
           )?
   ) #PtRelationalNode(>1)

}

void relational() #void :
{Token x;}
{
   (
           sum() ( 
                   ( x = <GT> | x = <GTE> | x = <LT> | x = <LTE> ) sum()
                   {
                       jjtThis._lexicalTokens.insertLast(x);
                   }
           )?
   ) #PtRelationalNode(>1)
}

void sum() #void :
{Token x;}
{
   (
           term() ( 
                   ( x = <PLUS> | x = <MINUS> ) term()
                   {
                       jjtThis._lexicalTokens.insertLast(x);
                   }
           )*
   ) #PtSumNode(>1)
}

void term() #void :
{Token x;}
{
   (
           unary() ( 
                   ( x = <MULTIPLY> | x = <DIVIDE> | x = <MODULO> ) unary()
                   {
                       jjtThis._lexicalTokens.insertLast(x);
                   }
           )*
   ) #PtProductNode(>1)
}


void unary() #void :
{}
{
   (
           <MINUS> element()
           { jjtThis.isMinus = true;}
   ) #PtUnaryNode

 |  
   (
           <BOOL_NOT> element()
           { jjtThis.isNot = true;} 
   ) #PtUnaryNode
 |  
   (
           <BITWISE_NOT> element()
           { jjtThis.isBitwiseNot = true;} 
   ) #PtUnaryNode

 |  element()
}

void element() #void :
{
int len;
String tidied, x;
}
{
   ( 
     <DOUBLE>
	{   try 
            {
                x = token.image.toLowerCase();
                len = x.length();
                if ( x.endsWith("f") ) {                   
                } else if ( x.endsWith("d") || x.endsWith("f") ) {   
                    // all floating point numbers are double
                    Double value = new Double(x.substring(0, len-1 ));
                    jjtThis._ptToken = new DoubleToken(value.doubleValue());
                } else {
                   Double value = new Double(x);
                   jjtThis._ptToken = new DoubleToken(value.doubleValue()); 
                }
            } catch (NumberFormatException ee) {
                String str = "Unable to convert token " + token.image;
                throw new ParseException(str + "to an float or double");
            }
        }
   ) #PtLeafNode

  |  
   (
     <INTEGER>
	{   try 
            {
                x = token.image.toLowerCase();
                len = x.length();
                if ( x.endsWith("l") ) {                   
                    Long value = new Long(x.substring(0, len-1 ));
                    jjtThis._ptToken = new LongToken(value.longValue());
                } else {
                   Integer value = new Integer(x);
                   jjtThis._ptToken = new IntToken(value.intValue()); 
                }
            } catch (NumberFormatException ee) {
                String str = "Unable to convert token " + token.image;
                throw new ParseException(str + "to an integer or long");
	    }
	}
   ) #PtLeafNode

  | 
   (
      <STRING>
      {
         // Now cut the " from each end of the string
        len = token.image.length();
        tidied = token.image.substring(1, (len -1));
        jjtThis._ptToken = new StringToken(tidied);
      }
   ) #PtLeafNode

  |  
   (
     <BOOLEAN>
      { 
          if (token.image.equalsIgnoreCase("TRUE")) {
              jjtThis._ptToken = new BooleanToken(true);
          } else if (token.image.equalsIgnoreCase("FALSE")) {
              jjtThis._ptToken = new BooleanToken(false);   
          }
      }
   ) #PtLeafNode   


  | 
    (
        "(" funcIf() ( 
            LOOKAHEAD( ")" "." )  (
                    // we're in a method call on the previous token 
                  ")" "." <ID> {jjtThis.methodName = token.image; }
                  "(" [ funcIf() ( "," funcIf()  )* ]  ")" )
          |            
            ")"
         )
     ) #PtMethodCallNode(>1)
 
  |   LOOKAHEAD( <ID> "(" )
      function()
    
  | 
   (
     <ID>
     { 
        Parameter referedParam = null;
	if (_scope != null) {
           referedParam = (Parameter)_scope.get(token.image);
	}
        if (referedParam != null) {
           // The Parameter is stored in the node so that the tree 
	   // does not have to be reparsed whenever the Token in 
	   // the Parameter changes.
           jjtThis._param   = referedParam; 
           // Register the calling parameter as a ParameterListener 
	   // of this Parameter this ID references.
           if (_listener != null) {
        	referedParam.registerListener(_listener);
            }
        } else if (token.image.equalsIgnoreCase("PI")) {
            jjtThis._ptToken = new ptolemy.data.DoubleToken(Math.PI);
        } else if (token.image.equalsIgnoreCase("E")) {
            jjtThis._ptToken = new ptolemy.data.DoubleToken(Math.E);
        } else {
            String str = " Parameter" + token.image + " not visible in ";
            throw new ParseException(str + "current scope");
        }
    }
   ) #PtLeafNode
}


void function() #PtFunctionNode :
{}
{    <ID> {jjtThis.funcName = token.image;} 
    "(" [  funcIf() ( ","  funcIf()  )* ]  ")"
}


