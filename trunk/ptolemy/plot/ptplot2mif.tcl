#!/bin/sh
# the next line restarts using tclsh \
exec tclsh "$0" "$@"

# This is a hack that takes PostScript produced by Ptplot
# and converts it to Framemaker mif format

# @Version: $Id$
# @Author: Christopher Hylands.  Based on pxgraph/mif.c by Edward A. Lee

# @Copyright (c) 1998 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY

# Usage: ptplot2mif.tcl foo.ps > foo.mif
#
# This Tcl script reads in a file named by its first argument, creates
# a Tcl script and then sources it, producing mif output.

proc readin { infile } {
    set fd [open $infile r]
    # sawPage is true if we've seen %%Page:
    set sawPage 0 
    set pscript ""
    while {[gets $fd line] >= 0} {
	# puts "---> $line"
	if [regexp {^%%Page:} $line] {
	    set sawPage 1 
	}
	if { !$sawPage } {
	    if [regexp {/PageSize \[([^ ]*) ([^ ]*)\]} $line a x y] {
		global xmax ymax
		set xmax $x
		set ymax $y
	    }
	} else {
	    if [regexp {^%} $line] {
		# If it starts with a %, comment it out
		append pscript "puts \{# $line\}\n"
		append pscript "parsePercent {$line}\n"
	    } else {
		set linelist [split $line]
		append pscript "[lindex $linelist end]\
			[lrange $linelist 0 [expr {[llength $linelist] -2}]]\n"
	    }	    
	}

    }
    mifInit
    debug "xmax: $xmax ymax:$ymax"
    eval $pscript
    mifEnd
}

set currentFont Helvetica
set currentFontSize 12
set currentFontBold No

########################################################################
#### mifInit
# Start of the mif file.
#
proc mifInit {} {
    puts "<MIFFile> # This line must be first. Generated by ptplot2mif.tcl"
    puts "<Pen 0>"
    puts "<PenWidth .5>"
    puts "<Fill 15>"
}
 
########################################################################
#### mifEnd
# End of the mif file.
# 
proc mifEnd {} {
    puts "<Group <ID 1>>"
    flush stdout
}

########################################################################
#### debug
# Used for debugging
#
proc debug {args} {
    eval {puts "# debug: $args"}
}

########################################################################
#### parsePercent
# Parse % directives in the original PostScript
#
proc parsePercent {line} {
    if [regexp {% Font\[([^,]*), ([^,]*), ([^,]*)]} $line a b c d] {
	# Handle $Font directives
	global currentFont currentFontSize currentFontBold No	
	debug "parsePercent '$line' b=$b c=$c d=$d"
	set currentFont $b
	set currentFontSize $d
	if {$c} {
	    set currentFontBold Yes
	} else {
	    set currentFontBold No
	}
    }
}


########################################################################
#### Convert x value from PostScript coords to MIF coords.
#
proc mapx {x} {
    global xmax
    return [expr {($x+0.0)/$xmax*6.2}]
}

########################################################################
#### Convert y value from PostScript coords to MIF coords.
#

proc mapy {y} {
    global ymax
    return [expr {($ymax-($y+0.0))/$ymax*6.2}]
}

############################################################
############################################################
# Below here are the procs that we eval to do the real work#
# See the PostScript file for the original definitions     #
############################################################
############################################################

# /AF {6 -2 roll 2 copy moveto 6 2 roll A fill} BD
proc AF {args} {
    debug "AF $args"
}

# /AS {A stroke} BD
proc AS {args} {
    debug "AS $args"
}

# /DL {moveto lineto stroke} BD
proc DL {args} {
    debug "DL $args"
    puts "<PolyLine\n <GroupID 1>\n <HeadCap Butt>"
    puts " <PenWidth .5>\n <DashedPattern <DashedStyle Solid>>"
    puts "<Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>"
    puts "<Point [mapx [lindex $args 2]] [mapy [lindex $args 3]]>"
    puts ">"
}

# /DS {
#	moveto 1 index stringwidth pop NZ sub
#	1 index length 1 sub NZ div 0
#	3 2 roll ashow} BD
proc DS {args} {
    debug "DS $args"
    global currentFont currentFontSize currentFontBold No

    puts "<TextLine\n <GroupID 1>"
    puts "<Font <FFamily $currentFont> <FSize $currentFontSize>\
	    <FBold $currentFontBold>>"
    puts "<TLAlignment Left>"
    puts "<TLOrigin [mapx [lindex $args [expr {[llength $args] -2}]]]\
	[mapy [lindex $args [expr {[llength $args] -1}]]]>"
    if ![regexp {\(([^\)]*)\)} "$args" a textval] {
	error "DS '$args': Internal Error, regexp failed to find string"
    }

    puts "<String `$textval'>>"
}

# /EP {showpage P restore} BD
proc EP {args} {
    debug "EP $args"
}

# /IC {initclip} BD
proc IC {args} {
    debug "initclip IC $args"
}

# /PYF {PY eofill} BD
proc PYF {args} {
    debug "PYF $args"
    puts "<PolyLine\n <GroupID 1>\n <HeadCap Butt>"
    puts " <PenWidth .5>\n <DashedPattern <DashedStyle Solid>>"
    for {set i 1} {$i < [expr {[llength $args] -1}]} {incr i} {
	puts "<Point [mapx [lindex $args $i]] [mapy [lindex $args [incr i]]]> # $i [lindex $args $i] [llength $args]"
    }
    puts ">"

}

# /PYS {PY stroke} BD
proc PYS {args} {
    debug "PYS $args"
    puts "<PolyLine\n <GroupID 1>\n <HeadCap Butt>"
    puts " <PenWidth .5>\n <DashedPattern <DashedStyle Solid>>"
    for {set i 1} {$i < [expr {[llength $args] -1}]} {incr i} {
	puts "<Point [mapx [lindex $args $i]] [mapy [lindex $args [incr i]]]> # $i [lindex $args $i] [llength $args]"
    }
    puts ">"
}

# /RC {R clip newpath} BD
proc RC {args} {
    debug "RC $args"

}

# /RF {R fill} BD
proc RF {args} {
    debug "Region Fill RF $args"
    puts "<PolyLine\n <GroupID 1>\n <HeadCap Butt>"
    puts " <PenWidth .5>\n <DashedPattern <DashedStyle Solid>>"
    puts "<Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>"

    puts "<Point [mapx [expr {[lindex $args 0] + [lindex $args 2]}]]\
	[mapy [lindex $args 1]]>"
    puts "<Point [mapx [expr {[lindex $args 0] + [lindex $args 2]}]]\
	[mapy [expr {[lindex $args 1] + [lindex $args 3]}]]>"
    puts "<Point [mapx [lindex $args 0]]\
	[mapy [expr {[lindex $args 1] + [lindex $args 3]}]]>"
    puts "<Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>"
    puts ">"
}

# /RS {R stroke} BD
proc RS {args} {
    debug "Relative Square RS $args"
    puts "<PolyLine\n <GroupID 1>\n <HeadCap Butt>"
    puts " <PenWidth .5>\n <DashedPattern <DashedStyle Solid>>"
    puts "<Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>"

    puts "<Point [mapx [expr {[lindex $args 0] + [lindex $args 2]}]]\
	[mapy [lindex $args 1]]>"
    puts "<Point [mapx [expr {[lindex $args 0] + [lindex $args 2]}]]\
	[mapy [expr {[lindex $args 1] + [lindex $args 3]}]]>"
    puts "<Point [mapx [lindex $args 0]]\
	[mapy [expr {[lindex $args 1] + [lindex $args 3]}]]>"
    puts "<Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>"
    puts ">"
}

# /SC {3 {255 div 3 1 roll} repeat setrgbcolor} BD
proc SC {args} {
    debug "Set Color SC $args"
}

# /SF {
# 	F exch get exch scalefont setfont
#	(abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890) stringwidth pop div
#	currentfont exch scalefont setfont} BD
proc SF {args} {
    debug "SF $args"

}

# /SP {/P save D} BD
proc SP {args} {
    debug "SP $args"
}




# This line calls the readin proc when we source this file.
readin [lindex $argv 0]
