#!/bin/sh
# the next line restarts using tclsh \
exec tclsh "$0" "$@"

# This is a hack that takes PostScript produced by Ptplot
# and converts it to Framemaker mif format

# @Version: $Id$
# @Author: Christopher Hylands.  Based on pxgraph/mif.c by Edward A. Lee

# @Copyright (c) 1998 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY

# Usage: ptplot2mif.tcl foo.ps > foo.mif
#
# This Tcl script reads in a file named by its first argument, creates
# a Tcl script and then sources it, producing mif output.

proc readin { infile } {
    set fd [open $infile r]
    # sawPage is true if we've seen %%Page:
    set sawPage 0 
    set pscript ""
    while {[gets $fd line] >= 0} {
	# puts "---> $line"
	if [regexp {^%%Page:} $line] {
	    set sawPage 1 
	}
	if { !$sawPage } {
	    if [regexp {/PageSize \[([^ ]*) ([^ ]*)\]} $line a x y] {
		global xmax ymax
		set xmax $x
		set ymax $y
	    }
	} else {
	    if [regexp {^%} $line] {
		# If it starts with a %, comment it out
		append pscript "puts \{# $line\}\n"
		append pscript "parsePercent {$line}\n"
	    } else {
		set linelist [split $line]
		set command [lindex $linelist end]
		set arglist [lrange $linelist 0 \
				[expr {[llength $linelist] -2}]]\n
		if { "$command" == "SC" } {
		    global colorlist
		    set colorlist [addToColorList $colorlist [string trim $arglist]]
		}
		append pscript "$command $arglist"
	    }	    
	}
    }
    mifInit
    debug "xmax: $xmax ymax:$ymax"
    eval $pscript
    mifEnd
}

set currentFont Helvetica
set currentFontSize 12
set currentFontBold No
set colorlist {}
set currentColor Black

########################################################################
#### addToColorList
#
proc addToColorList {colorlist args} {
    set a [lindex $args 0]
    if { "$a" != "255 255 255" && "$a" != "0 0 0" } {
	if { [lsearch $colorlist $a] < 0 } {
	    lappend colorlist "$a"
	}
    }
    return $colorlist
}

########################################################################
#### ObColor
#
proc ObColor {} {
    global currentColor
    return " <ObColor `$currentColor'>"
}

########################################################################
#### mifInit
# Start of the mif file.
#
proc mifInit {} {
    puts "<MIFFile> # This line must be first. Generated by ptplot2mif.tcl"
    global colorlist
    if {$colorlist != {}} {
	mifColors $colorlist
    }
    puts "<Pen 0>"
    puts "<PenWidth .5>[ObColor]"
    puts "<Fill 15>"
}
 
########################################################################
#### mifColors
# Print out color catalog
# 
proc mifColors {colorlist} {
    puts "<ColorCatalog"
    for {set i 0} {$i < [llength $colorlist]} {incr i} {
	set color [lindex $colorlist $i]
	puts " <Color"
	puts "  <ColorTag `Color$i'>"
	puts "  <ColorCyan [expr {[lindex $color 0] / 255.0 * 100.0}]>"
	puts "  <ColorMagenta [expr {[lindex $color 1] / 255.0 *100.0}]>"
	puts "  <ColorYellow [expr {[lindex $color 2] / 255.0 * 100.0}]>"
	puts " >"
    } 
    puts ">"
}

########################################################################
#### mifEnd
# End of the mif file.
# 
proc mifEnd {} {
    puts "<Group <ID 1>>"
    flush stdout
}

########################################################################
#### debug
# Used for debugging
#
proc debug {args} {
    eval {puts "# debug: $args"}
}

########################################################################
#### parsePercent
# Parse % directives in the original PostScript
#
proc parsePercent {line} {
    if [regexp {% Font\[([^,]*), ([^,]*), ([^,]*)]} $line a b c d] {
	# Handle $Font directives
	global currentFont currentFontSize currentFontBold No	
	debug "parsePercent '$line' b=$b c=$c d=$d"
	set currentFont $b
	# Note: use a font that is smaller by two points
	set currentFontSize [expr {$d -0}]
	if {$c} {
	    set currentFontBold Yes
	} else {
	    set currentFontBold No
	}
    }
}


########################################################################
#### Convert x value from PostScript coords to MIF coords.
#
proc mapx {x} {
    global xmax
    return [expr {($x+0.0)/$xmax*8.5}]
}

########################################################################
#### Convert y value from PostScript coords to MIF coords.
#

proc mapy {y} {
    global ymax
    return [expr {($ymax-($y+0.0))/$ymax*11.0}]
}

############################################################
############################################################
# Below here are the procs that we eval to do the real work#
# See the PostScript file for the original definitions     #
############################################################
############################################################

# /AF {6 -2 roll 2 copy moveto 6 2 roll A fill} BD
proc AF {args} {
    debug "AF $args"
    eval AForAS 7 $args
}

# /AS {A stroke} BD
proc AS {args} {
    debug "AS $args"
    eval AForAS 0 $args
}

# Common functionality for AF or AS
proc AForAS {pen args} {
    puts "<Ellipse\n <GroupID 1>\n <Pen $pen>\n <Fill 0>"
    puts " <PenWidth 0.5 pt>\n[ObColor]"
    set l [lindex $args 0]
    set t [lindex $args 1]
    set w [lindex $args 2]
    set h [lindex $args 3]
    puts " <ShapeRect [mapx [expr {$l - 0.5 * $w}]] \
	[mapy [expr {$t + 0.5 * $h}]] \
	[mapx $w] \
	[mapx $h]>>" 
}

# /DL {moveto lineto stroke} BD
proc DL {args} {
    debug "DL $args"
    puts "<PolyLine\n <GroupID 1>\n <Pen 0>\n <Fill 0>\n <HeadCap Butt>"
    puts " <PenWidth 0.5>\n[ObColor]\n <DashedPattern <DashedStyle Solid>>"
    puts " <Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>"
    puts " <Point [mapx [lindex $args 2]] [mapy [lindex $args 3]]>>"
}

# /DS {
#	moveto 1 index stringwidth pop NZ sub
#	1 index length 1 sub NZ div 0
#	3 2 roll ashow} BD
proc DS {args} {
    debug "DS $args"
    global currentFont currentFontSize currentFontBold No

    puts "<TextLine\n <GroupID 1>"
    puts " <Font <FFamily $currentFont> <FSize $currentFontSize>\
	    <FBold $currentFontBold>>"
    puts " <TLAlignment Left>"
    puts " <TLOrigin [mapx [lindex $args [expr {[llength $args] -2}]]]\
	[mapy [lindex $args [expr {[llength $args] -1}]]]>"
    if ![regexp {\(([^\)]*)\)} "$args" a textval] {
	error "DS '$args': Internal Error, regexp failed to find string"
    }

    puts " <String `$textval'>>"
}

# /EP {showpage P restore} BD
proc EP {args} {
    debug "EP $args"
}

# /IC {initclip} BD
proc IC {args} {
    debug "initclip IC $args"
}

# /PYF {PY eofill} BD
proc PYF {args} {
    debug "PYF $args"
    puts "<PolyLine\n <GroupID 1>\n <Pen 0>"
    if {"[lindex $args 0]" == "true" } {
	puts " <Fill 7>"
    } else {
	puts " <Fill 0>"
    }	
    puts " <HeadCap Butt>"
    puts " <PenWidth .5>\n[ObColor]\n <DashedPattern <DashedStyle Solid>>"
    for {set i 1} {$i < [expr {[llength $args] -1}]} {incr i} {
	puts " <Point [mapx [lindex $args $i]] [mapy [lindex $args [incr i]]]>"
    }
    puts ">"

}

# /PYS {PY stroke} BD
proc PYS {args} {
    debug "PYS $args"
    puts "<PolyLine\n <GroupID 1> <Pen 0>"
    if {"[lindex $args 0]" == "true" } {
	puts " <Fill 0>"
    } else {
	puts " <Fill 7>"
    }	
    puts " <HeadCap Butt>"
    puts " <PenWidth .5>\n[ObColor]\n <DashedPattern <DashedStyle Solid>>"
    for {set i 1} {$i < [expr {[llength $args] -1}]} {incr i} {
 	puts "<Point [mapx [lindex $args $i]] [mapy [lindex $args [incr i]]]> # $i [lindex $args $i] [llength $args]"
    }
    puts ">"
}

# /RC {R clip newpath} BD
proc RC {args} {
    debug "RC $args"

}

# /RF {R fill} BD
proc RF {args} {
    debug "Region Fill RF $args"
    puts "<PolyLine\n <GroupID 1>\n <Pen 0>\n <Fill 7>\n <HeadCap Butt>"
    puts " <PenWidth 0.5>\n[ObColor]\n <DashedPattern <DashedStyle Solid>>"
    puts " <Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>"

    puts " <Point [mapx [expr {[lindex $args 0] + [lindex $args 2]}]]\
	[mapy [lindex $args 1]]>"
    puts " <Point [mapx [expr {[lindex $args 0] + [lindex $args 2]}]]\
	[mapy [expr {[lindex $args 1] + [lindex $args 3]}]]>"
    puts " <Point [mapx [lindex $args 0]]\
	[mapy [expr {[lindex $args 1] + [lindex $args 3]}]]>"
    puts " <Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>>"
}

# /RS {R stroke} BD
proc RS {args} {
    debug "Relative Square RS $args"
    puts "<PolyLine\n <GroupID 1>\n <Pen 0>\n <Fill 7>\n <HeadCap Butt>"
    puts " <PenWidth 0.5>\n[ObColor]\n <DashedPattern <DashedStyle Solid>>"
    puts " <Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>"

    puts " <Point [mapx [expr {[lindex $args 0] + [lindex $args 2]}]]\
	[mapy [lindex $args 1]]>"
    puts " <Point [mapx [expr {[lindex $args 0] + [lindex $args 2]}]]\
	[mapy [expr {[lindex $args 1] + [lindex $args 3]}]]>"
    puts " <Point [mapx [lindex $args 0]]\
	[mapy [expr {[lindex $args 1] + [lindex $args 3]}]]>"
    puts " <Point [mapx [lindex $args 0]] [mapy [lindex $args 1]]>>"
}

# /SC {3 {255 div 3 1 roll} repeat setrgbcolor} BD
# Create a color list for printing out.  Note that this method
# gets called as we read in the PostScript file, unlike the other
# methods that get evaluated later
proc SC {args} {
    global currentColor colorlist
    debug "Set Color SC $args"
    set a [string trim $args]
    set currentColor "Color[lsearch $colorlist $a]"
    if { "$a" == "255 255 255" } {
	set currentColor "Black"
    }
    if { "$a" == "0 0 0" } {
	#set currentColor "White"
	set currentColor "Black"
    }

}

# /SF {
# 	F exch get exch scalefont setfont
#	(abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890) stringwidth pop div
#	currentfont exch scalefont setfont} BD
proc SF {args} {
    debug "SF $args"

}

# /SP {/P save D} BD
proc SP {args} {
    debug "SP $args"
}




# This line calls the readin proc when we source this file.
readin [lindex $argv 0]
