<!-- : ptmkmodel,v 1.6 1999/06/13 21:47:21 cxh Exp $
  @author: Bart Kienhuis
 -->
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>Sketch<I>Add your own title, removing the &lt;I&gt; ... &lt;/I&gt; </I></title>
<link href="../../../../../doc/default.css" rel="stylesheet" type="text/css">
</head>
<body>
<H1>Process Network Demo</H1>
<P><!-- All of the controls of the applet should be visible when the
applet is displayed on a XGA screen-->
<!-- 
     The HTML below is for the Java Plugin.  The first  
     section is for IE, the second is for Netscape
 -->
<OBJECT classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" 
 width=600 height=600 name="QR" 
 codebase="http://java.sun.com/products/plugin/1.2.2/jinstall-1_2_2-win.cab#Version=1,2,2,0">
<PARAM NAME=CODE VALUE=ptolemy.domains.pn.demo.QR.QR.class>
<PARAM NAME=CODEBASE VALUE=../../../../..>
<PARAM NAME=ARCHIVE VALUE=" ptolemy/ptsupport.jar, ptolemy/domains/pn/pn.jar, ptolemy/domains/pn/demo/QR/QR.jar">
<PARAM NAME="type" VALUE="application/x-java-applet;version=1.2.2">
<PARAM NAME="name" VALUE="QR">
<PARAM NAME="background" VALUE="#faf0e6">
<PARAM NAME="defaultStopTime" VALUE="100">
<COMMENT>
<EMBED type="application/x-java-applet;version=1.2.2" 
  code=ptolemy.domains.pn.demo.QR.QR
  codebase=../../../../.. 
  archive="ptolemy/ptsupport.jar, 
           ptolemy/domains/pn/pn.jar, 
           ptolemy/domains/pn/demo/QR/QR.jar" 
  name="QR" 
  width=600 height=600 background="#faf0e6" 
  defaultStopTime="100" 
  pluginspage="http://java.sun.com/products/plugin/1.2.2/plugin-install.html">
<NOEMBED></COMMENT>
<I>If you were able to run applets, you would have a demo here.</I> 
</NOEMBED>
</EMBED>
</OBJECT>

<P>
The above applet shows the result of a Process Network (PN) executing
the QR-algorithm on a continuous stream of data that is coming from an
array of antennas. Each execution of the algorithm on a new set of
data from the antennas, is called an update. The applet shows the
matrix R in a <I>MatrixViewer</I>. This matrix is of size NxN, where N
is the number of antenna's involved. The individual entries in the
matrix are also shown in the <I>Plotter</I>. The matrix R is obtained
after doing a certain number of QR-algorithm updates on a stream of
data coming from the antenna array of a certain size.
</p>

<P>
In the demo, if we select 10 QR-updates for an array of 6 antenna's,
the following R matrix must be found: </P>

<PRE>
# name: Rout 
# type: matrix 
# rows: 6 
# columns: 6 

270.843 206.234  60.482 -39.318 -89.100 -38.568 
  0.000 144.933 181.192 172.919 104.333  10.488 
  0.000   0.000  32.964  18.280  10.909   9.170 
  0.000   0.000   0.000  24.739   7.446   7.208 
  0.000   0.000   0.000   0.000  20.30   11.206 
  0.000   0.000   0.000   0.000   0.000   8.535
</PRE> 
<P>

The QR algorithm describes a linear algebra problem in which a matrix
A can be written as a product of two matrices Q and R (A=QR). The
matrix R is an upper triangular matrix and matrix Q is an orthogonal
matrix. A program that does this QR transformation is given below in
the Matlab programming language. The algorithm uses the Cordic
functions <I>Vectorize </I>and <I>Rotate </I>to find the QR
transform. If we execute this program in Matlab, we would find the
same matrix R.</P>

<PRE>
%% Initialize Matrix r
for j = 1:1:N,
  for i = j:1:N,
    [r(j,i)] = _ReadMatrix_Zeros_64x64();
  end
end
 
%% Initialize Matrix x
for k = 1:1:K,
  for j = 1:1:N,
    [x(k,j)] = _ReadMatrix_U_1000x16();
  end
end

%% do the QR updates
for k = 1:1:K,
  for j = 1:1:N,
    [r(j,j), x(k,j), t ] = Vectorize( r(j,j), x(k,j) );
    for i = j+1:1:N,
       [r(j,i), x(k,i), t] = Rotate( r(j,i), x(k,i), t );
    end
  end
end

%% After the K iterations, collect the values of the R Matrix
for j = 1:1:N,
  for i = j:1:N,
    [ Sink(j,i) ] = Rout( r(j,i) );
  end
end
</PRE>

<P>
However, we can also describe the same QR-algorithm as a <I>Process
Network</I>. In this process network description, the nodes ND_1,
ND_2, ND_3, ND_4, and ND_5 describe processes and the edges between
these nodes describe FIFO buffers that have a certain capacity. The
processes read from these buffers using a blocking-read semantics. In
the applet, we simulate this process network to get the value for the
R matrix. The big difference between the Matlab program and the
process network is that the process network executes in parallel
whereas the Matlab description executes sequentially. </P>

<P>
<center>
<IMG SRC="QRprocessnetwork.gif" WIDTH=622 HEIGHT=317>
</center>
</P> 

<P>
In process <A HREF="ND_2.java">ND_2</A>, a large matrix is stored that
contains 500 real data samples taken from 16 antennas. From this
matrix, the process reads a number of samples (the number of
antenna's) and sends these samples to either node <A
HREF="ND_3.java">ND_3</A> or <A HREF="ND_4.java">ND_4</A>. This
process is repeated a number of times, as many times as there will be
a QR-update. Process ND_3 and process ND_4 read data from incoming
edges and producing data on outgoing edges. After the numbers of
QR-updates are done, the final matrix R is sent to process <A
HREF="ND_5.java">ND_5</A>, which sends the matrix <I>R</I> to the
Plotter and the StreamToMatrix actor. The latter one reconstructs from
the incoming stream a matrix, which is sent to the MatrixViewer to be
visualized. Process <A HREF="ND_1.java">ND_1</A> is used to properly
initialize the process network by sending a specific number of zeros
to either process ND_3 or process ND_4.
</P>

<P>
Process networks have the characteristic that they execute in a
<I>deterministic order</I>, which means that the computation of the
result is independent of the schedule order of the processes. Thus,
process networks do not imposing any particular schedule order and a
process network can either be evaluated in parallel, as is done in the
Applet, or equally, in a sequential order, similar to the execution in
Matlab. The result we obtain, i.e. the matrix R, is in both cases the
same.</P></BODY>
</HTML>
