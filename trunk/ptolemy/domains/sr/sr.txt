
giotto input is the output from the last iteration
sr input is the same as the output at a given tick 

dt and sdf deals with loops by inserting delays
sr repeatedly fires until values converge

ct also repeatedly fires actors until convergence

hasToken may not be enough - may need isKnown
what did sedwards do?

self loops?

tokens can be defined (a value, or absent), or undefined (which could mean absent)

distinction:
1) not yet determined - unknown?
2) not determinable - undefined?
just use undefined and indeterminable?

static scheduler - recursive decomposition into strongly connected components
dynamic scheduler - chaotic iteration until convergence (shown correct in Ch 3)


receiver:
reset() discards token and sets known to false
isKnown() returns known
hasRoom() returns true - ?
unknown:hasToken() throws exception
absent:hasToken() returns super.hasToken (false)
present:hasToken() returns super.hasToken (true)
unknown:setAbsent() sets known to true
absent:setAbsent() does nothing
present:setAbsent() throws exception
unknown:get() throws exception
absent:get() calls super.get() (throws exception)
present:get() returns super.get()
unknown:put() calls super.put(), sets known to true
absent:put() throws exception
present:put() throws exception if token differs

receivers vs ports
types of exceptions
need to add methods to Receiver or AbstractReceiver?
maybe unknown:hasToken() should return false

stable number of known receivers indicates convergence
careful of mutation
should this check happen in fire or postfire?  probably fire
what about actors that may never fire or postfire?

actors:
hasFired()
isReactive()
isStrict() - ?


paper:

To execute under SR semantics, actors must be consistent in the sense that 
given the same inputs, an actor will produce the same output (or lack of 
output) in a given iteration.

An event occurs at each instant and on each channel.

The SR Director works by firing actors in an attempt to obtain a state in which each connection has a value, and these values have converged.  The values must eventually converge, because the ***** function is monotonic.  Transitions can only occur if the new value is ***** than the old value in the partially ordered set.  Thus, the only possible transition is for an undefined value to become a defined value.  A defined value can be either a token or absent.  However, a value determined to be absent or evaluated to a value can not change.  Thus, each value can change only once.  The maximum number of transitions before convergence equals the number of communication channels.  A channel value that remains undefined after convergence is called indeterminable*.

Minimizing the worst case execution time is important, because the user may desire to synchronize the model to real-time.  If the worst case evaluation time is greater than the period of the SR system, then the excution may not exhibit real-time behavior.
