/* Generated By:JavaScope: Do not edit this line. CompositeEntity.java */
/* A CompositeEntity is a cluster in a clustered graph.

 Copyright (c) 1997-2001 The Regents of the University of California.
 All rights reserved.
 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the above
 copyright notice and the following two paragraphs appear in all copies
 of this software.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.

                                        PT_COPYRIGHT_VERSION_2
                                        COPYRIGHTENDKEY

@ProposedRating Green (eal@eecs.berkeley.edu)
@AcceptedRating Green (bart@eecs.berkeley.edu)
*/

package ptolemy.kernel;

import ptolemy.kernel.util.Attribute;
import ptolemy.kernel.util.IllegalActionException;
import ptolemy.kernel.util.InternalErrorException;
import ptolemy.kernel.util.KernelException;
import ptolemy.kernel.util.NameDuplicationException;
import ptolemy.kernel.util.NamedList;
import ptolemy.kernel.util.Workspace;

import java.io.IOException;
import java.io.Writer;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List; import COM.sun.suntest.javascope.database.js$;import COM.sun.suntest.javascope.database.CoverageUnit; 

//////////////////////////////////////////////////////////////////////////
//// CompositeEntity
/**
A CompositeEntity is a cluster in a clustered graph.
I.e., it is a non-atomic entity, in that
it can contain other entities and relations.  It supports transparent ports,
where, in effect, the port of a contained entity is represented by a port
of this entity. Methods that "deeply" traverse the topology
see right through transparent ports.
It may be opaque, in which case its ports are opaque and methods
that "deeply" traverse the topology do not see through them.
For instance, deepEntityList() returns the opaque entities
directly or indirectly contained by this entity.
<p>
To add an entity or relation to this composite, call its setContainer() method
with this composite as an argument.  To remove it, call its setContainer()
method with a null argument (or another container). The entity must be
an instance of ComponentEntity and the relation of ComponentRelation or
an exception is thrown.  Derived classes may further constrain these
to subclasses.  To do that, they should override the protected methods
_addEntity() and _addRelation() and the public member newRelation().
<p>
A CompositeEntity may be contained by another CompositeEntity.
To set that up, call the setContainer() method of the inside entity.
Derived classes may further constrain the container to be
a subclass of CompositeEntity.  To do this, they should override
setContainer() to throw an exception.  Recursive containment
structures, where an entity directly or indirectly contains itself,
are disallowed, and an exception is thrown on an attempt to set up
such a structure.
<p>
A CompositeEntity can contain instances of ComponentPort.  By default
these ports will be transparent, although subclasses of CompositeEntity
can make them opaque by overriding the isOpaque() method to return
<i>true</i>. Derived classes may further constrain the ports to a
subclass of ComponentPort.
To do this, they should override the public method newPort() to create
a port of the appropriate subclass, and the protected method _addPort()
to throw an exception if its argument is a port that is not of the
appropriate subclass.

@author John S. Davis II, Edward A. Lee
@version $Id$
*/
public class CompositeEntity extends ComponentEntity { static private int js$t0 = js$.setDatabase("/home/eecs/cxh/jsdatabase");static private String[] js$p={"ptolemy","kernel",};static private CoverageUnit js$c=js$.c(js$p,"CompositeEntity","/export/maury/maury2/cxh/tmp/ptII/ptolemy/kernel/jsoriginal/CompositeEntity.java",976122022828L,js$n());  static final int[] js$a = js$c.counters; 

    /** Construct an entity in the default workspace with an empty string
     *  as its name. Add the entity to the workspace directory.
     *  Increment the version number of the workspace.
     */
    public CompositeEntity() {
        super(); try{  js$.g(CompositeEntity.js$a,1); 
	 js$.g(CompositeEntity.js$a,0);/*$js$*/ _addIcon(); }finally{js$.flush(CompositeEntity.js$c);} 
    }

    /** Construct an entity in the specified workspace with an empty
     *  string as a name. You can then change the name with setName().
     *  If the workspace argument is null, then use the default workspace.
     *  Add the entity to the workspace directory.
     *  Increment the version number of the workspace.
     *  @param workspace The workspace that will list the entity.
     */
    public CompositeEntity(Workspace workspace) {
	super(workspace); try{  js$.g(CompositeEntity.js$a,3); 
	 js$.g(CompositeEntity.js$a,2);/*$js$*/ _addIcon(); }finally{js$.flush(CompositeEntity.js$c);} 
    }

    /** Create an object with a name and a container.
     *  The container argument must not be null, or a
     *  NullPointerException will be thrown.  This entity will use the
     *  workspace of the container for synchronization and version counts.
     *  If the name argument is null, then the name is set to the empty string.
     *  Increment the version of the workspace.
     *  @param container The container entity.
     *  @param name The name of the entity.
     *  @exception IllegalActionException If the container is incompatible
     *   with this entity.
     *  @exception NameDuplicationException If the name coincides with
     *   an entity already in the container.
     */
    public CompositeEntity(CompositeEntity container, String name)
            throws IllegalActionException, NameDuplicationException {
        super(container, name); try{  js$.g(CompositeEntity.js$a,5); 
	 js$.g(CompositeEntity.js$a,4);/*$js$*/ _addIcon(); }finally{js$.flush(CompositeEntity.js$c);} 
    }

    ///////////////////////////////////////////////////////////////////
    ////                         public methods                    ////

    /** Allow or disallow connections that are created using the connect()
     *  method to cross levels of the hierarchy.
     *  The default is that such connections are disallowed.
     *  Generally it is a bad idea to allow level-crossing
     *  connections, since it breaks modularity.  This loss of modularity
     *  means, among other things, that this composite cannot be cloned.
     *  Nonetheless, this capability is provided for the benefit of users
     *  that feel they just must have it, and who are willing to sacrifice
     *  clonability and modularity.
     *  @param boole True to allow level-crossing connections.
     */
    public void allowLevelCrossingConnect(boolean boole) {try  { js$.g(CompositeEntity.js$a,7); 
         js$.g(CompositeEntity.js$a,6);/*$js$*/ _levelCrossingConnectAllowed = boole;
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Clone the object into the specified workspace. The new object is
     *  <i>not</i> added to the directory of that workspace (you must do this
     *  yourself if you want it there).
     *  NOTE: This will not work if there are level-crossing transitions.
     *  The result is an entity with clones of the ports of the original
     *  entity, the contained entities, and the contained relations.
     *  The ports of the returned entity are not connected to anything.
     *  The connections of the relations are duplicated in the new entity,
     *  unless they cross levels, in which case an exception is thrown.
     *  @param workspace The workspace for the cloned object.
     *  @exception CloneNotSupportedException If the entity contains
     *   level crossing transitions so that its connections cannot be cloned,
     *   or if one of the attributes cannot be cloned.
     *  @return A new CompositeEntity.
     */
    public Object clone(Workspace workspace)
            throws CloneNotSupportedException {try  { js$.g(CompositeEntity.js$a,25); 
         js$.g(CompositeEntity.js$a,8);/*$js$*/ CompositeEntity newEntity = (CompositeEntity)super.clone(workspace);

        newEntity._containedEntities = new NamedList(newEntity);
        newEntity._containedRelations = new NamedList(newEntity);

        // Clone the contained relations.
        Iterator relations = relationList().iterator();
        while ( ((( relations.hasNext() ) && ++CompositeEntity.js$a[26] != 0) || ++CompositeEntity.js$a[27] == 0) ) {
             js$.g(CompositeEntity.js$a,9);/*$js$*/ ComponentRelation relation =
                (ComponentRelation)relations.next();
            ComponentRelation newRelation =
                (ComponentRelation)relation.clone(workspace);
            // Assume that since we are dealing with clones,
            // exceptions won't occur normally.  If they do, throw a
            // CloneNotSupportedException.
            try {
                newRelation.setContainer(newEntity);
            } catch (KernelException ex) { js$.g(CompositeEntity.js$a,28); 
                 js$.g(CompositeEntity.js$a,10);/*$js$*/ throw new CloneNotSupportedException(
                        "Failed to clone a CompositeEntity: " +
                        ex.getMessage());
            }
        }

        // Clone the contained entities.
         js$.g(CompositeEntity.js$a,11);/*$js$*/ Iterator entities = entityList().iterator();
        while ( ((( entities.hasNext() ) && ++CompositeEntity.js$a[29] != 0) || ++CompositeEntity.js$a[30] == 0) ) {
             js$.g(CompositeEntity.js$a,12);/*$js$*/ ComponentEntity entity =
                (ComponentEntity)entities.next();
            ComponentEntity newSubentity = (ComponentEntity)entity.clone(workspace);
            // Assume that since we are dealing with clones,
            // exceptions won't occur normally.  If they do, throw a
            // CloneNotSupportedException.
            try {
                newSubentity.setContainer(newEntity);
            } catch (KernelException ex) { js$.g(CompositeEntity.js$a,31); 
                 js$.g(CompositeEntity.js$a,13);/*$js$*/ throw new CloneNotSupportedException(
                        "Failed to clone a CompositeEntity: " +
                        ex.getMessage());
            }

            // Clone the links of the ports of the cloned entities.
             js$.g(CompositeEntity.js$a,14);/*$js$*/ Iterator ports = entity.portList().iterator();
            while ( ((( ports.hasNext() ) && ++CompositeEntity.js$a[32] != 0) || ++CompositeEntity.js$a[33] == 0) ) {
                 js$.g(CompositeEntity.js$a,15);/*$js$*/ ComponentPort port = (ComponentPort)ports.next();
                Enumeration linkedRelations = port.linkedRelations();
                while ( ((( linkedRelations.hasMoreElements() ) && ++CompositeEntity.js$a[34] != 0) || ++CompositeEntity.js$a[35] == 0) ) {
                     js$.g(CompositeEntity.js$a,16);/*$js$*/ ComponentRelation rel =
                        (ComponentRelation)linkedRelations.nextElement();
                    // A null link (supported since indexed links) might
                    // yield a null relation here. EAL 7/19/00.
                    if ( ((( rel != null ) && ++CompositeEntity.js$a[36] != 0) || ++CompositeEntity.js$a[37] == 0) ) {
                        if ( ((( rel.getContainer() != this ) && ++CompositeEntity.js$a[38] != 0) || ++CompositeEntity.js$a[39] == 0) ) {
                             js$.g(CompositeEntity.js$a,17);/*$js$*/ throw new CloneNotSupportedException(
                                    "Cannot clone a CompositeEntity with " +
                                    "level crossing transitions.");
                        }
                         js$.g(CompositeEntity.js$a,18);/*$js$*/ ComponentRelation newRelation =
                            newEntity.getRelation(rel.getName());
                        Port newPort =
                            newSubentity.getPort(port.getName());
                        try {
                            newPort.link(newRelation);
                        } catch (IllegalActionException ex) { js$.g(CompositeEntity.js$a,40); 
                             js$.g(CompositeEntity.js$a,19);/*$js$*/ throw new CloneNotSupportedException(
                                    "Failed to clone a CompositeEntity: " +
                                    ex.getMessage());
                        }
                    }
                }
            }
        }

        // Clone the inside links from the ports of this entity.
         js$.g(CompositeEntity.js$a,20);/*$js$*/ Iterator ports = portList().iterator();
        while ( ((( ports.hasNext() ) && ++CompositeEntity.js$a[41] != 0) || ++CompositeEntity.js$a[42] == 0) ) {
             js$.g(CompositeEntity.js$a,21);/*$js$*/ ComponentPort port = (ComponentPort)ports.next();
            relations = port.insideRelationList().iterator();
            while ( ((( relations.hasNext() ) && ++CompositeEntity.js$a[43] != 0) || ++CompositeEntity.js$a[44] == 0) ) {
                 js$.g(CompositeEntity.js$a,22);/*$js$*/ Relation relation = (Relation)relations.next();
                ComponentRelation newRelation =
                    newEntity.getRelation(relation.getName());
                Port newPort =
                    newEntity.getPort(port.getName());
                try {
                    newPort.link(newRelation);
                } catch (IllegalActionException ex) { js$.g(CompositeEntity.js$a,45); 
                     js$.g(CompositeEntity.js$a,23);/*$js$*/ throw new CloneNotSupportedException(
                            "Failed to clone a CompositeEntity: " +
                            ex.getMessage());
                }
            }
        }

         js$.g(CompositeEntity.js$a,24);/*$js$*/ return newEntity;
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Create a new relation and use it to connect two ports.
     *  It creates a new relation using newRelation() with an automatically
     *  generated name and uses it to link the specified ports.
     *  The order of the ports determines the order in which the
     *  links to the relation are established, but otherwise has no
     *  importance.
     *  The name is of the form "_R<i>i</i>" where <i>i</i> is an integer.
     *  Level-crossing connections are not permitted unless
     *  allowLevelCrossingConnect() has been called with a <i>true</i>
     *  argument.  Note that is rarely a good idea to permit level crossing
     *  connections, since they break modularity and cloning.
     *  A reference to the newly created relation is returned.
     *  To remove the relation, call its setContainer() method with a null
     *  argument. This method is write-synchronized on the workspace
     *  and increments its version number.
     *  @param port1 The first port to connect.
     *  @param port2 The second port to connect.
     *  @exception IllegalActionException If one of the arguments is null, or
     *   if a disallowed level-crossing connection would result.
     */
    public ComponentRelation connect(ComponentPort port1, ComponentPort port2)
            throws IllegalActionException {try  { js$.g(CompositeEntity.js$a,48); 
         js$.g(CompositeEntity.js$a,46);/*$js$*/ try {
            return connect(port1, port2, uniqueName("_R"));
        } catch (NameDuplicationException ex) { js$.g(CompositeEntity.js$a,49); 
            // This exception should not be thrown.
             js$.g(CompositeEntity.js$a,47);/*$js$*/ throw new InternalErrorException(
                    "Internal error in ComponentRelation connect() method!"
                    + ex.getMessage());
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Create a new relation with the specified name and use it to
     *  connect two ports. Level-crossing connections are not permitted
     *  unless allowLevelCrossingConnect() has been called with a true
     *  argument.   Note that is rarely a good idea to permit level crossing
     *  connections, since they break modularity and cloning.
     *  A reference to the newly created alias relation is returned.
     *  To remove the relation, call its setContainer() method with a null
     *  argument. This method is write-synchronized on the workspace
     *  and increments its version number.
     *  @param port1 The first port to connect.
     *  @param port2 The second port to connect.
     *  @param relationName The name of the new relation.
     *  @exception IllegalActionException If one of the arguments is null, or
     *   if a disallowed level-crossing connection would result, or if the two
     *   ports are not in the same workspace as this entity.
     *  @exception NameDuplicationException If there is already a relation with
     *   the specified name in this entity.
     */
    public ComponentRelation connect(ComponentPort port1, ComponentPort port2,
            String relationName)
            throws IllegalActionException, NameDuplicationException {try  { js$.g(CompositeEntity.js$a,61); 
        if ( ((( port1 == null || port2 == null ) && ++CompositeEntity.js$a[62] != 0) || ++CompositeEntity.js$a[63] == 0) ) {
             js$.g(CompositeEntity.js$a,50);/*$js$*/ throw new IllegalActionException(this,
                    "Attempt to connect null port.");
        }
        if ( ((( port1.workspace() != port2.workspace() ||
                port1.workspace() != _workspace ) && ++CompositeEntity.js$a[64] != 0) || ++CompositeEntity.js$a[65] == 0) ) {
             js$.g(CompositeEntity.js$a,51);/*$js$*/ throw new IllegalActionException(port1, port2,
                    "Cannot connect ports because workspaces are different.");
        }
         js$.g(CompositeEntity.js$a,52);/*$js$*/ try {
            _workspace.getWriteAccess();
            ComponentRelation ar = newRelation(relationName);
            if ( ((( _levelCrossingConnectAllowed ) && ++CompositeEntity.js$a[66] != 0) || ++CompositeEntity.js$a[67] == 0) ) {
                 js$.g(CompositeEntity.js$a,53);/*$js$*/ port1.liberalLink(ar);
            } else {
                 js$.g(CompositeEntity.js$a,54);/*$js$*/ port1.link(ar);
            }
            // Have to catch the exception to restore the original state.
             js$.g(CompositeEntity.js$a,55);/*$js$*/ try {
                if ( ((( _levelCrossingConnectAllowed ) && ++CompositeEntity.js$a[68] != 0) || ++CompositeEntity.js$a[69] == 0) ) {
                     js$.g(CompositeEntity.js$a,56);/*$js$*/ port2.liberalLink(ar);
                } else {
                     js$.g(CompositeEntity.js$a,57);/*$js$*/ port2.link(ar);
                }
            } catch (IllegalActionException ex) { js$.g(CompositeEntity.js$a,70); 
                 js$.g(CompositeEntity.js$a,58);/*$js$*/ port1.unlink(ar);
                throw ex;
            }
             js$.g(CompositeEntity.js$a,59);/*$js$*/ return ar;
        } finally {
             js$.g(CompositeEntity.js$a,60);/*$js$*/ _workspace.doneWriting();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** List the opaque entities that are directly or indirectly
     *  contained by this entity.  The list will be empty if there
     *  are no such contained entities.
     *  This method is read-synchronized on the workspace.
     *  @return A list of opaque ComponentEntity objects.
     */
    public List deepEntityList() {try  { js$.g(CompositeEntity.js$a,77); 
         js$.g(CompositeEntity.js$a,71);/*$js$*/ try {
            _workspace.getReadAccess();
            LinkedList result = new LinkedList();

            Iterator entities = _containedEntities.elementList().iterator();

            while ( ((( entities.hasNext() ) && ++CompositeEntity.js$a[78] != 0) || ++CompositeEntity.js$a[79] == 0) ) {
                 js$.g(CompositeEntity.js$a,72);/*$js$*/ ComponentEntity entity = (ComponentEntity)entities.next();
                if ( ((( entity.isOpaque() ) && ++CompositeEntity.js$a[80] != 0) || ++CompositeEntity.js$a[81] == 0) ) {
                     js$.g(CompositeEntity.js$a,73);/*$js$*/ result.add(entity);
                } else {
                     js$.g(CompositeEntity.js$a,74);/*$js$*/ result.addAll(((CompositeEntity)entity).deepEntityList());
                }
            }
             js$.g(CompositeEntity.js$a,75);/*$js$*/ return result;
        } finally {
             js$.g(CompositeEntity.js$a,76);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Enumerate the opaque entities that are directly or indirectly
     *  contained by this entity.  The enumeration will be empty if there
     *  are no such contained entities.
     *  This method is read-synchronized on the workspace.
     *  @deprecated Use deepEntityList() instead.
     *  @return An enumeration of opaque ComponentEntity objects.
     */
    public Enumeration deepGetEntities() {try  { js$.g(CompositeEntity.js$a,83); 
         js$.g(CompositeEntity.js$a,82);/*$js$*/ return Collections.enumeration(deepEntityList());
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** List the contained entities in the order they were added
     *  (using their setContainer() method).
     *  The returned list is static in the sense
     *  that it is not affected by any subsequent additions or removals
     *  of entities.
     *  This method is read-synchronized on the workspace.
     *  @return An unmodifiable list of ComponentEntity objects.
     */
    public List entityList() {try  { js$.g(CompositeEntity.js$a,86); 
         js$.g(CompositeEntity.js$a,84);/*$js$*/ try {
            _workspace.getReadAccess();
            // Copy the list so we can create a static enumeration.
            NamedList entitiesCopy = new NamedList(_containedEntities);
            return entitiesCopy.elementList();
        } finally {
             js$.g(CompositeEntity.js$a,85);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Return a list of the component entities contained by this object that
     *  are instances of the specified class.  If there are no such
     *  instances, then return an empty list.
     *  This method is read-synchronized on the workspace.
     *  @param filter The class of ComponentEntity of interest.
     *  @return A list of instances of specified class.
     */
    public List entityList(Class filter) {try  { js$.g(CompositeEntity.js$a,92); 
         js$.g(CompositeEntity.js$a,87);/*$js$*/ try {
            _workspace.getReadAccess();
	    List result = new LinkedList();
            Iterator entities = _containedEntities.elementList().iterator();
            while ( ((( entities.hasNext() ) && ++CompositeEntity.js$a[93] != 0) || ++CompositeEntity.js$a[94] == 0) ) {
                 js$.g(CompositeEntity.js$a,88);/*$js$*/ Object entity = entities.next();
                if ( ((( filter.isInstance(entity) ) && ++CompositeEntity.js$a[95] != 0) || ++CompositeEntity.js$a[96] == 0) ) {
                     js$.g(CompositeEntity.js$a,89);/*$js$*/ result.add(entity);
                }
            }
             js$.g(CompositeEntity.js$a,90);/*$js$*/ return result;
        } finally {
             js$.g(CompositeEntity.js$a,91);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Return a sequence of MoML link attributes that describe
     *  any link between objects (ports, entities, and relations) that are
     *  present in the <i>filter</i> argument.  Both ends of the link
     *  must be present in <i>filter</i> for MoML to be generated for that
     *  link.  The <i>filter</i>
     *  argument normally contains ports, relations, and entities
     *  that are contained by this composite entity. If it contains
     *  an entity, then that is equivalent to containing all the ports
     *  contained by that entity.  It is recommended to use a collection
     *  class (such as HashSet) for which the contains() method is
     *  efficient.
     *  <p>
     *  If the argument is null, then return all the links that this
     *  composite is responsible for (i.e., apply no filtering).  If the
     *  argument is an empty collection, then return none of the links.  The
     *  links that this entity is responsible for is the inside links of
     *  its ports, and links on ports contained by contained entities.
     *  @param indentation The depth at which the output should be indented.
     *  @param filter A collection of ports, parameters, and entities, or
     *   null to apply no filtering.
     *  @exception IOException If an I/O error occurs.
     */
    public String exportLinks(int indentation, Collection filter)
            throws IOException {try  { js$.g(CompositeEntity.js$a,117); 
        // To get the ordering right,
        // we read the links from the ports, not from the relations.

         js$.g(CompositeEntity.js$a,97);/*$js$*/ StringBuffer result = new StringBuffer();

        // First, produce the inside links on contained ports.
        Iterator ports = portList().iterator();
        while ( ((( ports.hasNext() ) && ++CompositeEntity.js$a[118] != 0) || ++CompositeEntity.js$a[119] == 0) ) {
             js$.g(CompositeEntity.js$a,98);/*$js$*/ ComponentPort port = (ComponentPort)ports.next();
            Iterator relations = port.insideRelationList().iterator();
            // The following variables are used to determine whether to
            // specify the index of the link explicitly, or to leave
            // it implicit.
            int index = -1;
            boolean useIndex = false;
            while ( ((( relations.hasNext() ) && ++CompositeEntity.js$a[120] != 0) || ++CompositeEntity.js$a[121] == 0) ) {
                 js$.g(CompositeEntity.js$a,99);/*$js$*/ index++;
                ComponentRelation relation
                    = (ComponentRelation)relations.next();
                if ( ((( relation == null ) && ++CompositeEntity.js$a[122] != 0) || ++CompositeEntity.js$a[123] == 0) ) {
                    // Gap in the links.  The next link has to use an
                    // explicit index.
                     js$.g(CompositeEntity.js$a,100);/*$js$*/ useIndex = true;
                    continue;
                }
                // Apply filter.
                if ( ((( filter == null
                        || (filter.contains(relation)
                                && (filter.contains(port)
                                        ||  filter.contains(port.getContainer()))) ) && ++CompositeEntity.js$a[124] != 0) || ++CompositeEntity.js$a[125] == 0) ) {

                    // In order to support level-crossing links, consider the
                    // possibility that the relation is not contained by this.
                     js$.g(CompositeEntity.js$a,101);/*$js$*/ String relationName =null ;
                    if ( ((( relation.getContainer() == this ) && ++CompositeEntity.js$a[126] != 0) || ++CompositeEntity.js$a[127] == 0) ) {
                         js$.g(CompositeEntity.js$a,102);/*$js$*/ relationName = relation.getName();
                    } else {
                         js$.g(CompositeEntity.js$a,103);/*$js$*/ relationName = relation.getFullName();
                    }
                    if ( ((( useIndex ) && ++CompositeEntity.js$a[128] != 0) || ++CompositeEntity.js$a[129] == 0) ) {
                         js$.g(CompositeEntity.js$a,104);/*$js$*/ useIndex = false;
                        result.append(_getIndentPrefix(indentation)
                                + "<link port=\""
                                + port.getName()
                                + "\" insertAt=\""
                                + index
                                + "\" relation=\""
                                + relationName
                                + "\"/>\n");
                    } else {
                         js$.g(CompositeEntity.js$a,105);/*$js$*/ result.append(_getIndentPrefix(indentation)
                                + "<link port=\""
                                + port.getName()
                                + "\" relation=\""
                                + relationName
                                + "\"/>\n");
                    }
                }
            }
        }

        // Next, produce the links on ports contained by contained entities.
         js$.g(CompositeEntity.js$a,106);/*$js$*/ Iterator entities = entityList().iterator();
        while ( ((( entities.hasNext() ) && ++CompositeEntity.js$a[130] != 0) || ++CompositeEntity.js$a[131] == 0) ) {
             js$.g(CompositeEntity.js$a,107);/*$js$*/ ComponentEntity entity = (ComponentEntity)entities.next();
            ports = entity.portList().iterator();
            while ( ((( ports.hasNext() ) && ++CompositeEntity.js$a[132] != 0) || ++CompositeEntity.js$a[133] == 0) ) {
                 js$.g(CompositeEntity.js$a,108);/*$js$*/ ComponentPort port = (ComponentPort)ports.next();
                Iterator relations = port.linkedRelationList().iterator();
                // The following variables are used to determine whether to
                // specify the index of the link explicitly, or to leave
                // it implicit.
                int index = -1;
                boolean useIndex = false;
                while ( ((( relations.hasNext() ) && ++CompositeEntity.js$a[134] != 0) || ++CompositeEntity.js$a[135] == 0) ) {
                     js$.g(CompositeEntity.js$a,109);/*$js$*/ index++;
                    ComponentRelation relation
                        = (ComponentRelation)relations.next();
                    if ( ((( relation == null ) && ++CompositeEntity.js$a[136] != 0) || ++CompositeEntity.js$a[137] == 0) ) {
                        // Gap in the links.  The next link has to use an
                        // explicit index.
                         js$.g(CompositeEntity.js$a,110);/*$js$*/ useIndex = true;
                        continue;
                    }
                    // Apply filter.
                    if ( ((( filter == null
                            || (filter.contains(relation)
                                    && (filter.contains(port)
                                            ||  filter.contains(port.getContainer()))) ) && ++CompositeEntity.js$a[138] != 0) || ++CompositeEntity.js$a[139] == 0) ) {

                        // In order to support level-crossing links,
                        // consider the possibility that the relation
                        // is not contained by this.
                         js$.g(CompositeEntity.js$a,111);/*$js$*/ String relationName =null ;
                        if ( ((( relation.getContainer() == this ) && ++CompositeEntity.js$a[140] != 0) || ++CompositeEntity.js$a[141] == 0) ) {
                             js$.g(CompositeEntity.js$a,112);/*$js$*/ relationName = relation.getName();
                        } else {
                             js$.g(CompositeEntity.js$a,113);/*$js$*/ relationName = relation.getFullName();
                        }
                        if ( ((( useIndex ) && ++CompositeEntity.js$a[142] != 0) || ++CompositeEntity.js$a[143] == 0) ) {
                             js$.g(CompositeEntity.js$a,114);/*$js$*/ useIndex = false;
                            result.append(_getIndentPrefix(indentation)
                                    + "<link port=\""
                                    + entity.getName()
                                    + "."
                                    + port.getName()
                                    + "\" insertAt=\""
                                    + index
                                    + "\" relation=\""
                                    + relationName
                                    + "\"/>\n");
                        } else {
                             js$.g(CompositeEntity.js$a,115);/*$js$*/ result.append(_getIndentPrefix(indentation)
                                    + "<link port=\""
                                    + entity.getName()
                                    + "."
                                    + port.getName()
                                    + "\" relation=\""
                                    + relationName
                                    + "\"/>\n");
                        }
                    }
                }
            }
        }
         js$.g(CompositeEntity.js$a,116);/*$js$*/ return result.toString();
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Get the attribute with the given name. The name may be compound,
     *  with fields separated by periods, in which case the attribute
     *  returned is contained by a (deeply) contained attribute, port,
     *  relation, or entity.
     *  If the name contains one or more periods, then it is assumed
     *  to be the relative name of an attribute contained by one of
     *  the contained attributes, ports, entities or relations.
     *  This method is read-synchronized on the workspace.
     *  @param name The name of the desired attribute.
     *  @return The requested attribute if it is found, null otherwise.
     */
    public Attribute getAttribute(String name) {try  { js$.g(CompositeEntity.js$a,152); 
         js$.g(CompositeEntity.js$a,144);/*$js$*/ try {
            _workspace.getReadAccess();
            // Check attributes and ports first.
            Attribute result = super.getAttribute(name);
            if ( ((( result == null ) && ++CompositeEntity.js$a[153] != 0) || ++CompositeEntity.js$a[154] == 0) ) {
                // Check entities first.
                 js$.g(CompositeEntity.js$a,145);/*$js$*/ String[] subnames = _splitName(name);
                if ( ((( subnames[1] != null ) && ++CompositeEntity.js$a[155] != 0) || ++CompositeEntity.js$a[156] == 0) ) {
                     js$.g(CompositeEntity.js$a,146);/*$js$*/ ComponentEntity entity = getEntity(subnames[0]);
                    if ( ((( entity != null ) && ++CompositeEntity.js$a[157] != 0) || ++CompositeEntity.js$a[158] == 0) ) {
                         js$.g(CompositeEntity.js$a,147);/*$js$*/ result = entity.getAttribute(subnames[1]);
                    }
                    if ( ((( result == null ) && ++CompositeEntity.js$a[159] != 0) || ++CompositeEntity.js$a[160] == 0) ) {
                        // Check relations.
                         js$.g(CompositeEntity.js$a,148);/*$js$*/ ComponentRelation relation = getRelation(subnames[0]);
                        if ( ((( relation != null ) && ++CompositeEntity.js$a[161] != 0) || ++CompositeEntity.js$a[162] == 0) ) {
                             js$.g(CompositeEntity.js$a,149);/*$js$*/ result = relation.getAttribute(subnames[1]);
                        }
                    }
                }
            }
             js$.g(CompositeEntity.js$a,150);/*$js$*/ return result;
        } finally {
             js$.g(CompositeEntity.js$a,151);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Get a contained entity by name. The name may be compound,
     *  with fields separated by periods, in which case the entity
     *  returned is contained by a (deeply) contained entity.
     *  This method is read-synchronized on the workspace.
     *  @param name The name of the desired entity.
     *  @return An entity with the specified name, or null if none exists.
     */
    public ComponentEntity getEntity(String name) {try  { js$.g(CompositeEntity.js$a,170); 
         js$.g(CompositeEntity.js$a,163);/*$js$*/ try {
            _workspace.getReadAccess();
            String[] subnames = _splitName(name);
            if ( ((( subnames[1] == null ) && ++CompositeEntity.js$a[171] != 0) || ++CompositeEntity.js$a[172] == 0) ) {
                 js$.g(CompositeEntity.js$a,164);/*$js$*/ return (ComponentEntity)_containedEntities.get(name);
            } else {
                 js$.g(CompositeEntity.js$a,165);/*$js$*/ Object match = _containedEntities.get(subnames[0]);
                if ( ((( match == null ) && ++CompositeEntity.js$a[173] != 0) || ++CompositeEntity.js$a[174] == 0) ) {
                     js$.g(CompositeEntity.js$a,166);/*$js$*/ return null;
                } else {
                    if ( ((( match instanceof CompositeEntity ) && ++CompositeEntity.js$a[175] != 0) || ++CompositeEntity.js$a[176] == 0) ) {
                         js$.g(CompositeEntity.js$a,167);/*$js$*/ return ((CompositeEntity)match).getEntity(subnames[1]);
                    } else {
                         js$.g(CompositeEntity.js$a,168);/*$js$*/ return null;
                    }
                }
            }
        } finally {
             js$.g(CompositeEntity.js$a,169);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Enumerate the contained entities in the order they were added
     *  (using their setContainer() method).
     *  The returned enumeration is static in the sense
     *  that it is not affected by any subsequent additions or removals
     *  of entities.
     *  This method is read-synchronized on the workspace.
     *  @deprecated Use entityList() instead.
     *  @return An enumeration of ComponentEntity objects.
     */
    public Enumeration getEntities() {try  { js$.g(CompositeEntity.js$a,178); 
         js$.g(CompositeEntity.js$a,177);/*$js$*/ return Collections.enumeration(entityList());
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Get a contained port by name. The name may be compound,
     *  with fields separated by periods, in which case the port returned is
     *  contained by a (deeply) contained entity.
     *  This method is read-synchronized on the workspace.
     *  @param name The name of the desired port.
     *  @return A port with the specified name, or null if none exists.
     */
    public Port getPort(String name) {try  { js$.g(CompositeEntity.js$a,185); 
         js$.g(CompositeEntity.js$a,179);/*$js$*/ try {
            _workspace.getReadAccess();
            String[] subnames = _splitName(name);
            if ( ((( subnames[1] == null ) && ++CompositeEntity.js$a[186] != 0) || ++CompositeEntity.js$a[187] == 0) ) {
                 js$.g(CompositeEntity.js$a,180);/*$js$*/ return super.getPort(name);
            } else {
                 js$.g(CompositeEntity.js$a,181);/*$js$*/ ComponentEntity match =
                    (ComponentEntity)_containedEntities.get(subnames[0]);
                if ( ((( match == null ) && ++CompositeEntity.js$a[188] != 0) || ++CompositeEntity.js$a[189] == 0) ) {
                     js$.g(CompositeEntity.js$a,182);/*$js$*/ return null;
                } else {
                     js$.g(CompositeEntity.js$a,183);/*$js$*/ return match.getPort(subnames[1]);
                }
            }
        } finally {
             js$.g(CompositeEntity.js$a,184);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Get a contained relation by name. The name may be compound,
     *  with fields separated by periods, in which case the relation
     *  returned is contained by a (deeply) contained entity.
     *  This method is read-synchronized on the workspace.
     *  @param name The name of the desired relation.
     *  @return A relation with the specified name, or null if none exists.
     */
    public ComponentRelation getRelation(String name) {try  { js$.g(CompositeEntity.js$a,197); 
         js$.g(CompositeEntity.js$a,190);/*$js$*/ try {
            _workspace.getReadAccess();
            String[] subnames = _splitName(name);
            if ( ((( subnames[1] == null ) && ++CompositeEntity.js$a[198] != 0) || ++CompositeEntity.js$a[199] == 0) ) {
                 js$.g(CompositeEntity.js$a,191);/*$js$*/ return (ComponentRelation)_containedRelations.get(name);
            } else {
                 js$.g(CompositeEntity.js$a,192);/*$js$*/ Object match = _containedEntities.get(subnames[0]);
                if ( ((( match == null ) && ++CompositeEntity.js$a[200] != 0) || ++CompositeEntity.js$a[201] == 0) ) {
                     js$.g(CompositeEntity.js$a,193);/*$js$*/ return null;
                } else {
                    if ( ((( match instanceof CompositeEntity ) && ++CompositeEntity.js$a[202] != 0) || ++CompositeEntity.js$a[203] == 0) ) {
                         js$.g(CompositeEntity.js$a,194);/*$js$*/ return ((CompositeEntity)match)
                            .getRelation(subnames[1]);
                    } else {
                         js$.g(CompositeEntity.js$a,195);/*$js$*/ return null;
                    }
                }
            }
        } finally {
             js$.g(CompositeEntity.js$a,196);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Enumerate the relations contained by this entity.
     *  The returned enumeration is static in the sense
     *  that it is not affected by any subsequent additions or removals
     *  of relations.
     *  This method is read-synchronized on the workspace.
     *  @deprecated Use relationList() instead.
     *  @return An enumeration of ComponentRelation objects.
     */
    public Enumeration getRelations() {try  { js$.g(CompositeEntity.js$a,205); 
         js$.g(CompositeEntity.js$a,204);/*$js$*/ return Collections.enumeration(relationList());
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Return false since CompositeEntities are not atomic.
     *  Note that this will return false even if there are no contained
     *  entities or relations.  Derived classes may not override this.
     *  To hide the contents of the entity, they should override isOpaque().
     *  @return False.
     */
    public final boolean isAtomic() {try  { js$.g(CompositeEntity.js$a,207); 
	 js$.g(CompositeEntity.js$a,206);/*$js$*/ return false;
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Return false.  Derived classes may return true in order to hide
     *  their components behind opaque ports.
     *  @return True if the entity is opaque.
     *  @see ptolemy.kernel.CompositeEntity
     */
    public boolean isOpaque() {try  { js$.g(CompositeEntity.js$a,209); 
	 js$.g(CompositeEntity.js$a,208);/*$js$*/ return false;
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Create a new relation with the specified name, add it to the
     *  relation list, and return it. Derived classes can override
     *  this to create domain-specific subclasses of ComponentRelation.
     *  This method is write-synchronized on the workspace and increments
     *  its version number.
     *  @param name The name of the new relation.
     *  @return The new relation.
     *  @exception IllegalActionException If name argument is null.
     *  @exception NameDuplicationException If name collides with a name
     *   already in the container.
     */
    public ComponentRelation newRelation(String name)
            throws IllegalActionException, NameDuplicationException {try  { js$.g(CompositeEntity.js$a,212); 
         js$.g(CompositeEntity.js$a,210);/*$js$*/ try {
            _workspace.getWriteAccess();
            ComponentRelation rel = new ComponentRelation(this, name);
            return rel;
        } finally {
             js$.g(CompositeEntity.js$a,211);/*$js$*/ _workspace.doneWriting();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Return the number of contained entities.
     *  This method is read-synchronized on the workspace.
     *  @return The number of entities.
     */
    public int numEntities() {try  { js$.g(CompositeEntity.js$a,215); 
         js$.g(CompositeEntity.js$a,213);/*$js$*/ try {
            _workspace.getReadAccess();
            return _containedEntities.size();
        } finally {
             js$.g(CompositeEntity.js$a,214);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Return the number of contained relations.
     *  This method is read-synchronized on the workspace.
     *  @return The number of relations.
     */
    public int numRelations() {try  { js$.g(CompositeEntity.js$a,218); 
         js$.g(CompositeEntity.js$a,216);/*$js$*/ try {
            _workspace.getReadAccess();
            return _containedRelations.size();
        } finally {
             js$.g(CompositeEntity.js$a,217);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** List the relations contained by this entity.
     *  The returned list is static in the sense
     *  that it is not affected by any subsequent additions or removals
     *  of relations.
     *  This method is read-synchronized on the workspace.
     *  @return An unmodifiable list of ComponentRelation objects.
     */
    public List relationList() {try  { js$.g(CompositeEntity.js$a,221); 
         js$.g(CompositeEntity.js$a,219);/*$js$*/ try {
            _workspace.getReadAccess();
            // Copy the list so we can create a static enumeration.
            NamedList relationsCopy = new NamedList(_containedRelations);
            return relationsCopy.elementList();
        } finally {
             js$.g(CompositeEntity.js$a,220);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Remove all contained entities and unlink them from all relations.
     *  This is done by setting their containers to null.
     *  This method is read-synchronized on the workspace
     *  and increments its version number.
     */
    public void removeAllEntities() {try  { js$.g(CompositeEntity.js$a,226); 
         js$.g(CompositeEntity.js$a,222);/*$js$*/ try {
            _workspace.getReadAccess();
            Iterator entities = entityList().iterator();

            while ( ((( entities.hasNext() ) && ++CompositeEntity.js$a[227] != 0) || ++CompositeEntity.js$a[228] == 0) ) {
                 js$.g(CompositeEntity.js$a,223);/*$js$*/ ComponentEntity entity = (ComponentEntity)entities.next();
                try {
                    entity.setContainer(null);
                } catch (KernelException ex) { js$.g(CompositeEntity.js$a,229); 
                    // This exception should not be thrown.
                     js$.g(CompositeEntity.js$a,224);/*$js$*/ throw new InternalErrorException(
                            "Internal error in ComponentRelation "
                            + "removeAllEntities() method!"
                            + ex.getMessage());
                }
            }
        } finally {
             js$.g(CompositeEntity.js$a,225);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Remove all contained relations and unlink them from everything.
     *  This is done by setting their containers to null.
     *  This method is write-synchronized on the workspace
     *  and increments its version number.
     */
    public void removeAllRelations() {try  { js$.g(CompositeEntity.js$a,234); 
         js$.g(CompositeEntity.js$a,230);/*$js$*/ try {
            _workspace.getWriteAccess();
            Iterator relations = relationList().iterator();

            while ( ((( relations.hasNext() ) && ++CompositeEntity.js$a[235] != 0) || ++CompositeEntity.js$a[236] == 0) ) {
                 js$.g(CompositeEntity.js$a,231);/*$js$*/ ComponentRelation relation =
                    (ComponentRelation)relations.next();
                try {
                    relation.setContainer(null);
                } catch (KernelException ex) { js$.g(CompositeEntity.js$a,237); 
                    // This exception should not be thrown.
                     js$.g(CompositeEntity.js$a,232);/*$js$*/ throw new InternalErrorException(
                            "Internal error in ComponentRelation "
                            + "removeAllRelations() method!"
                            + ex.getMessage());
                }
            }
        } finally {
             js$.g(CompositeEntity.js$a,233);/*$js$*/ _workspace.doneWriting();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Return a name that is guaranteed to not be the name of
     *  any contained attribute, port, entity, or relation.
     *  @param prefix A prefix for the name.
     *  @return A unique name.
     */
<<<<<<< CompositeEntity.java
    public String uniqueName(String prefix) {try  { js$.g(CompositeEntity.js$a,241); 
         js$.g(CompositeEntity.js$a,238);/*$js$*/ String candidate = prefix + _uniqueNameIndex++;
        while( ((( getAttribute(candidate) != null
=======
    public String uniqueName(String prefix) {
        if(prefix == null)
            prefix = "null";
        String candidate = prefix;
        while(getAttribute(candidate) != null
>>>>>>> 1.75
                || getPort(candidate) != null
                || getEntity(candidate) != null
                || getRelation(candidate) != null ) && ++CompositeEntity.js$a[242] != 0) || ++CompositeEntity.js$a[243] == 0) ) {
             js$.g(CompositeEntity.js$a,239);/*$js$*/ candidate = prefix + _uniqueNameIndex++;
        }
         js$.g(CompositeEntity.js$a,240);/*$js$*/ return candidate;
    } finally{js$.flush(CompositeEntity.js$c);}} 

    ///////////////////////////////////////////////////////////////////
    ////                         protected methods                 ////

    /** Add an entity to this container. This method should not be used
     *  directly.  Call the setContainer() method of the entity instead.
     *  This method does not set
     *  the container of the entity to point to this composite entity.
     *  It assumes that the entity is in the same workspace as this
     *  container, but does not check.  The caller should check.
     *  Derived classes may override this method to constrain the
     *  the entity to a subclass of ComponentEntity.
     *  This method is <i>not</i> synchronized on the workspace, so the
     *  caller should be.
     *  @param entity Entity to contain.
     *  @exception IllegalActionException If the entity has no name, or the
     *   action would result in a recursive containment structure.
     *  @exception NameDuplicationException If the name collides with a name
     *  already in the entity.
     */
    protected void _addEntity(ComponentEntity entity)
            throws IllegalActionException, NameDuplicationException {try  { js$.g(CompositeEntity.js$a,246); 
        if ( ((( entity.deepContains(this) ) && ++CompositeEntity.js$a[247] != 0) || ++CompositeEntity.js$a[248] == 0) ) {
             js$.g(CompositeEntity.js$a,244);/*$js$*/ throw new IllegalActionException(entity, this,
                    "Attempt to construct recursive containment.");
        }
         js$.g(CompositeEntity.js$a,245);/*$js$*/ _containedEntities.append(entity);
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Add a relation to this container. This method should not be used
     *  directly.  Call the setContainer() method of the relation instead.
     *  This method does not set
     *  the container of the relation to refer to this container.
     *  This method is <i>not</i> synchronized on the workspace, so the
     *  caller should be.
     *  @param relation Relation to contain.
     *  @exception IllegalActionException If the relation has no name.
     *  @exception NameDuplicationException If the name collides with a name
     *   already on the contained relations list.
     */
    protected void _addRelation(ComponentRelation relation)
            throws IllegalActionException, NameDuplicationException {try  { js$.g(CompositeEntity.js$a,250); 
         js$.g(CompositeEntity.js$a,249);/*$js$*/ _containedRelations.append(relation);
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Return a description of the object.  The level of detail depends
     *  on the argument, which is an or-ing of the static final constants
     *  defined in the NamedObj class.  Lines are indented according to
     *  to the level argument using the protected method _getIndentPrefix().
     *  Zero, one or two brackets can be specified to surround the returned
     *  description.  If one is specified it is the the leading bracket.
     *  This is used by derived classes that will append to the description.
     *  Those derived classes are responsible for the closing bracket.
     *  An argument other than 0, 1, or 2 is taken to be equivalent to 0.
     *  This method is read-synchronized on the workspace.
     *  @param detail The level of detail.
     *  @param indent The amount of indenting.
     *  @param bracket The number of surrounding brackets (0, 1, or 2).
     *  @return A description of the object.
     */
    protected String _description(int detail, int indent, int bracket) {try  { js$.g(CompositeEntity.js$a,263); 
         js$.g(CompositeEntity.js$a,251);/*$js$*/ try {
            _workspace.getReadAccess();
            String result =null ;
            if ( ((( bracket == 1 || bracket == 2 ) && ++CompositeEntity.js$a[264] != 0) || ++CompositeEntity.js$a[265] == 0) ) {
                 js$.g(CompositeEntity.js$a,252);/*$js$*/ result = super._description(detail, indent, 1);
            } else {
                 js$.g(CompositeEntity.js$a,253);/*$js$*/ result = super._description(detail, indent, 0);
            }
            if ( ((( (detail & CONTENTS) != 0 ) && ++CompositeEntity.js$a[266] != 0) || ++CompositeEntity.js$a[267] == 0) ) {
                if ( ((( result.trim().length() > 0 ) && ++CompositeEntity.js$a[268] != 0) || ++CompositeEntity.js$a[269] == 0) ) {
                     js$.g(CompositeEntity.js$a,254);/*$js$*/ result += " ";
                }
                 js$.g(CompositeEntity.js$a,255);/*$js$*/ result += "entities {\n";
                Iterator entities = entityList().iterator();
                while ( ((( entities.hasNext() ) && ++CompositeEntity.js$a[270] != 0) || ++CompositeEntity.js$a[271] == 0) ) {
                     js$.g(CompositeEntity.js$a,256);/*$js$*/ ComponentEntity entity =
                        (ComponentEntity)entities.next();
                    result +=
                        entity._description(detail, indent+1, 2) + "\n";
                }
                 js$.g(CompositeEntity.js$a,257);/*$js$*/ result += _getIndentPrefix(indent) + "} relations {\n";
                Iterator relations = relationList().iterator();
                while ( ((( relations.hasNext() ) && ++CompositeEntity.js$a[272] != 0) || ++CompositeEntity.js$a[273] == 0) ) {
                     js$.g(CompositeEntity.js$a,258);/*$js$*/ Relation relation = (Relation)relations.next();
                    result += relation._description(detail, indent+1, 2) + "\n";
                }
                 js$.g(CompositeEntity.js$a,259);/*$js$*/ result += _getIndentPrefix(indent) + "}";
            }
            if ( ((( bracket == 2 ) && ++CompositeEntity.js$a[274] != 0) || ++CompositeEntity.js$a[275] == 0) ) {   js$.g(CompositeEntity.js$a,260);/*$js$*/ result += "}"; } 
             js$.g(CompositeEntity.js$a,261);/*$js$*/ return result;
        } finally {
             js$.g(CompositeEntity.js$a,262);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Write a MoML description of the contents of this object, which
     *  in this class are the attributes, ports, contained relations,
     *  and contained entities, plus all links.  The links are written
     *  in an order that respects the ordering in ports, but not necessarily
     *  the ordering in relations.  This method is called
     *  by exportMoML().  Each description is indented according to the
     *  specified depth and terminated with a newline character.
     *  @param output The output to write to.
     *  @param depth The depth in the hierarchy, to determine indenting.
     *  @exception IOException If an I/O error occurs.
     */
    protected void _exportMoMLContents(Writer output, int depth)
            throws IOException {try  { js$.g(CompositeEntity.js$a,281); 
         js$.g(CompositeEntity.js$a,276);/*$js$*/ super._exportMoMLContents(output, depth);

        Iterator entities = entityList().iterator();
        while ( ((( entities.hasNext() ) && ++CompositeEntity.js$a[282] != 0) || ++CompositeEntity.js$a[283] == 0) ) {
             js$.g(CompositeEntity.js$a,277);/*$js$*/ ComponentEntity entity = (ComponentEntity)entities.next();
            entity.exportMoML(output, depth);
        }
         js$.g(CompositeEntity.js$a,278);/*$js$*/ Iterator relations = relationList().iterator();
        while ( ((( relations.hasNext() ) && ++CompositeEntity.js$a[284] != 0) || ++CompositeEntity.js$a[285] == 0) ) {
             js$.g(CompositeEntity.js$a,279);/*$js$*/ ComponentRelation relation
                = (ComponentRelation)relations.next();
            relation.exportMoML(output, depth);
        }
        // Next write the links.
         js$.g(CompositeEntity.js$a,280);/*$js$*/ output.write(exportLinks(depth, null));
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Remove the specified entity. This method should not be used
     *  directly.  Call the setContainer() method of the entity instead with
     *  a null argument.
     *  The entity is assumed to be contained by this composite (otherwise,
     *  nothing happens). This does not alter the entity in any way.
     *  This method is <i>not</i> synchronized on the workspace, so the
     *  caller should be.
     *  @param entity The entity to remove.
     */
    protected void _removeEntity(ComponentEntity entity) {try  { js$.g(CompositeEntity.js$a,287); 
         js$.g(CompositeEntity.js$a,286);/*$js$*/ _containedEntities.remove(entity);
    } finally{js$.flush(CompositeEntity.js$c);}} 

    /** Remove the specified relation. This method should not be used
     *  directly.  Call the setContainer() method of the relation instead with
     *  a null argument.
     *  The relation is assumed to be contained by this composite (otherwise,
     *  nothing happens). This does not alter the relation in any way.
     *  This method is <i>not</i> synchronized on the workspace, so the
     *  caller should be.
     *  @param relation The relation to remove.
     */
    protected void _removeRelation(ComponentRelation relation) {try  { js$.g(CompositeEntity.js$a,289); 
         js$.g(CompositeEntity.js$a,288);/*$js$*/ _containedRelations.remove(relation);
    } finally{js$.flush(CompositeEntity.js$c);}} 

    ///////////////////////////////////////////////////////////////////
    ////                         protected variables               ////

    /** @serial List of contained entities. */
    protected NamedList _containedEntities = new NamedList(this);

    ///////////////////////////////////////////////////////////////////
    ////                         private methods                   ////

    private void _addIcon() {try  { js$.g(CompositeEntity.js$a,291); 
	 js$.g(CompositeEntity.js$a,290);/*$js$*/ _attachText("_iconDescription", "<svg>\n" +
                "<rect x=\"0\" y=\"0\" width=\"60\" " +
                "height=\"40\" style=\"fill:red\"/>\n" +
                "<rect x=\"3\" y=\"3\" width=\"54\" " +
                "height=\"34\" style=\"fill:white\"/>\n" +
                "<polygon points=\"10,10 50,20 10,30\" " +
                "style=\"fill:blue\"/>\n" +
                "</svg>\n");
    } finally{js$.flush(CompositeEntity.js$c);}} 

    ///////////////////////////////////////////////////////////////////
    ////                         private variables                 ////

    /** @serial List of contained ports. */
    private NamedList _containedRelations = new NamedList(this);

    /** @serial Flag indicating whether level-crossing connect is permitted. */
    private boolean _levelCrossingConnectAllowed = false; static private int js$n() {return 292;}  static private int js$t1=js$.flush(CompositeEntity.js$c);private int js$t2=js$.flush(CompositeEntity.js$c); 
