<!-- $Id$ -->
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>Code Generation</title>
<link href="default.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Code Generation</h1>
<p>
Ptolemy II includes the very beginnings a code generation framework.
Currently, there are four types of code generators:

<dl>
<dt> <a href="#deep">deep</a>
<dd> Reads in a .xml model and generates optimized .class files that
have few dependencies on the Ptolemy II packages.

<dt> <a href="#shallow">shallow</a>
<dd> Reads in a .xml file and generates a single
unoptimized .class file that has many dependencies on the Ptolemy II
packages.

<dt> <a href="#applet">applet</a>
<dd> Reads in a .xml file and generates files suitable for
putting a model up on a web page as an applet.

<dt> <a href="#interpreted">interpreted</a>
<dd> Reads in a .xml file and writes out the .xml file.
The interpreted code generator does very little code generation
and is used primary to compare the other code generators with
the standard Ptolemy II interpreted mode that is used when
the user does <code>View</code> -&gt; <code>Run</code>.
</dl>

<p>
The implementation here should be viewed as highly preliminary.
<font color="red">It is likely to fail on all but a few simple test
cases.</font>  It is at the stage of being a concept demonstration
only.  We expect it to mature considerably in the near future.
<p>The following <a name="limitations">limitations</a>
apply to all of the code generators:
<menu>
<li> The code generators uses <a href="#soot">Soot</a> to analyze a
model and generate a set of Java .class files.  Soot will not
work with JDK1.4, it requires JDK1.3
<li> The primary interface to the code generator is through
the makefiles and the 
<a href="codeDoc/ptolemy/copernicus/kernel/Copernicus.html"><code>$PTII/ptolemy/copernicus/kernel/Copernicus.java</code></a> class.  The
user interface is highly preliminary, and its limitations
are discussed in
the <a href="#userInterfaceLimitations">User Interface Limitations</a>
section.
<li> The limitations for the individual code generators are 
discussed below:
  <menu>
  <li> <a href="#deepLimitations">Deep Limitations</a>
  <li> <a href="#shallowLimitations">Shallow Limitations</a>
  <li> <a href="#appletLimitations">Applet Limitations</a>
  <li> <a href="#interpretedLimitations">Interpreted Limitations</a>
  </menu>
</menu>

<h2><a name="deep">Deep Code Generation Demonstration</a></h2>
Deep code generation is by the most interesting of the code generators
so we cover it first.  Stephen Neuendorffer is the primary author of
the deep code generator.

 <p>The Ptolemy II code generation system parses Ptolemy II actor
code, generates an Abstract Syntax Tree (AST), optimizes the tree
using standard and custom compiler optimization techniques and then
generates .class files that use very few of the Ptolemy II java
classes.  This approach is different from the Ptolemy Classic code
generation approach, where each actor contains target specific code.

<p>Most of the code generator uses <a href="#soot">Soot</a> to analyze a
model and generate a set of Java .class files.

<p>Our current deep code generator generates Java .class files, so the
user interface refers to the deep code generator as the
<code>java</code> code generator.  The deep code generator is
implemented in the <code>$PTII/ptolemy/copernicus/<b>java</b></code>
directory.  Other deep code generators could generate code in
different backend languages.

<p>Professor Shuvra S. Bhattacharyya of the University of Maryland is
working on C code generation for Ptolemy II Models using Soot, but
his work is still under development and not being released at this time.
For details about the status of the C code generation effort, see
the reports on the Ptolemy II website at
<a href="http://ptolemy.eecs.berkeley.edu/projects"><code>http://ptolemy.eecs.berkeley.edu/projects</code></a>

<p><a name="deepLimitations">Deep code generation has the following
limitations:</a>
<menu>
<li> Deep code generation still requires the <code>ptolemy.math</code>
and <code>ptolemy.data</code> packages.

Our hope is to eventually implement token unboxing so that the only
the <code>ptolemy.math</code> package is required at runtime.

<li> Deep code generation only works on flat SDF models.  Composite SDF
models and domains other than SDF are not supported.

<li> Deep code generation consumes quite a bit of memory.  We usually exec
the deep code generator as a separate process with the 
<CODE>-Xmx256</CODE> java command line argument, which sets the
initial heap size to 256Mb.  Deep code generation may not work on 
a on memory-limited platforms.
 <p>Currently, in Ptolemy II, it is not possible to generate custom code 
for an individual actor using a codeblock.
</menu>


<p>Below is a simple demonstration:
<ol>
<li> Open up the
<a href="../ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xml">SDF Orthogonal Communication Model</a>

<li> Select View -&gt; Code Generator

<li> Hit the Generate Button

<li> The code generator will invoke an separate java process that
generates code in 
<CODE>$PTII/ptolemy/copernicus/<b>java</b>/cg/OrthogonalCom</CODE>
<br>The deep code generator takes about 90 seconds to generate code.

<li> The code generators print out statistics about how long
the run took and how much memory was consumed.  A typical run will
look like:
<pre>
OrthogonalCom: Stats before execution:    0 ms. Memory: 1984K Free: 1805K (91%)
0
1
0
<i>etc.</i>
0
1
OrthogonalCom: Execution stats:           280 ms. Memory: 1984K Free: 1741K (88%)
OrthogonalCom: After Garbage Collection:  1392 ms. Memory: 1984K Free: 1804K (91%)
OrthogonalCom: construction size:         1984K - 1805K = 179K
OrthogonalCom: model alloc. while exec. : 1805K - 1804K = 1K
OrthogonalCom: model alloc. runtime data: 1804K - 1741K = 63K
280 ms. Memory: 1984K Free: 1741K (88%) Stat: 179K StatRT: 1K DynRT: 63K
All Done.
</pre>

The last line is the most significant, it indicates that the run

<menu>
 <li> took 280 milliseconds
 <li> Consumed at most 1984K of memory
 <li> Before garbage collection at the end of the run, there was
 1741K or 88% memory free.  That means that before
 garbage collection, the model consumed 243K (1984K-1741K) of memory.
 <li> The remaining three numbers are somewhat more subjective:
  <menu>
  <li> 179K of Memory was allocated during construction of the model
  <li> 1K was allocated while the model was running
  <li> 63K of data that was garbage collected.
  </menu>
</menu>
<li>To run the generated code again, click on the <code>compile</code>
radio button and turn it off, then hit the <code>Generate</code>
button.  This will show and run the generated code without rerunning
the 90 second long generator process.

</ol>

Things to note:
<menu>
<li> After a model is run, Ptolemy II prints out the amount of time
and memory the model consumed.  Usually, this output goes to standard
out, which could be hidden if Vergil was started by clicking on an
icon.  The <code>interpreted</code> code generator runs a model
in the usual Ptolemy II interpreted mode, but displays the 
runtime statistics in the code generator tableau window.  To
run the interpreted code generator:
 <ol>
 <li>Go to the code generator window and change <code>codeGenerator</code>
 to <code>interpreted</code>
 <li> Hit the Generate Button
 </ol>
 <p>
For 20 iterations, the interpreted code generator will print out
<pre>
OrthogonalCom: Stats before execution:    1722 ms. Memory: 1984K Free: 1104K (56%)
0
0
1
0
<i>etc.</i>
0
410 ms. Memory: 1984K Free: 1215K (61%)
OrthogonalCom: Execution stats:           2273 ms. Memory: 1984K Free: 1214K (61%)
OrthogonalCom: After Garbage Collection:  3425 ms. Memory: 1984K Free: 1519K (77%)
OrthogonalCom: construction size:         1984K - 1104K = 880K
OrthogonalCom: model alloc. while exec. : 1104K - 1519K = -415K
OrthogonalCom: model alloc. runtime data: 1519K - 1214K = 305K
2273 ms. Memory: 1984K Free: 1214K (61%) Stat: 880K StatRT: -415K DynRT: 305
</pre>
The most significant line is the last line.

<p>The 2273 ms. represents the amount of time in milliseconds
that was required to read in the model, parse it and run it.

<p>The 410 ms. represents the amount of time the model ran for.

From the above, we can see that for 20 iterations, 
the deep code generator took 280 ms. overall to run, whereas the
interpreted version too 2273 ms.  The difference in times
is primarily consumed by the MoML parser, which is fairly
complex.

<p>The actual run times, after parsing, were 280 ms. for the deep code
generation version and 410 ms. for the interpreted version.  

<li> Deep codegen shows a more significant improvement in speed when
the model is run for a larger number of iterations.

To increase the number of iterations in the model:
<ol>
<li>Close the code generator window and go to the
graph editor
<li> Click on the green SDF Director Icon and change the number
of iterations from 20 to 2000.
<li> Save the model with File -&gt; Save
<li> Bring up the code generator with
View -&gt; Code Generator -&gt; Generate.
<li> Run the model using the interpreted code generator
by goin to the code generator window and change <code>codeGenerator</code>
 to <code>interpreted</code>
<li> Hit the Generate Button
<li> You should see times like:
<pre>
3254 ms. Memory: 1984K Free: 1412K (71%)
OrthogonalCom: Execution stats:           5097 ms. Memory: 1984K Free: 1411K (71%)
OrthogonalCom: After Garbage Collection:  6299 ms. Memory: 1984K Free: 1519K (77%)
OrthogonalCom: construction size:         1984K - 1104K = 880K
OrthogonalCom: model alloc. while exec. : 1104K - 1519K = -415K
OrthogonalCom: model alloc. runtime data: 1519K - 1411K = 108K
5097 ms. Memory: 1984K Free: 1411K (71%) Stat: 880K StatRT: -415K DynRT: 108
</pre>

<li> Change the <code>codeGenerator</code> to <code>java</code>
<li> Hit the Generate Button
<li> You should see statistics like
<pre>
OrthogonalCom: Execution stats:           941 ms. Memory: 1984K Free: 1494K (75%)
OrthogonalCom: After Garbage Collection:  2103 ms. Memory: 1984K Free: 1804K (91%)
OrthogonalCom: construction size:         1984K - 1805K = 179K
OrthogonalCom: model alloc. while exec. : 1805K - 1804K = 1K
OrthogonalCom: model alloc. runtime data: 1804K - 1494K = 310K
941 ms. Memory: 1984K Free: 1494K (75%) Stat: 179K StatRT: 1K DynRT: 310K
</pre>
</ol>
Comparing the run times for 2000 iterations, we can see that the
interpreted version took 5097 ms. compared with the deep code generation
version taking 941 ms, so in in this case, deep code generation was
roughly 5 times faster than the regular interpreted version.

<li> Soot produces .class files, and we can run a disassembler
convert the .class files back to .java files.  Unfortunately, there
are various reasons that the resulting .java files will not compile.
See the <a href="#disassemblers">Disassemblers</a> section for
information about disassemblers.

</menu>

<h2><a name="shallow">Shallow code generation</a></h2>

Shallow code generation converts a model that has been specified in
MoML (typically using Vergil) into a Java class definition.  This class
definition can be used in an applet, which results in faster download
times because less of the Ptolemy II infrastructure is required
to execute it. Shallow code generation uses components built into
the Ptolemy II tree.  

<p>We primarily use shallow code generation as a test bed
for the code generation facility itself.  

<p>Below is a simple demonstration
<ol>
<li> Open up the
<a
href="../ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xml">SDF
Orthogonal Communication Model</a>

<li> Select View -&gt; Code Generator

<li> Change the <code>CodeGenerator</code> combo box from
<code>java</code> to <code>shallow</code>
<li> Hit the Generate Button

<li> The code generator will invoke an separate java process that
generates code in 
<CODE>$PTII/ptolemy/copernicus/<b>shallow</b>/cg/OrthogonalCom</CODE>
<br>If you do not have write permission to the Ptolemy II tree, then
the generated code will end up in the directory listed in the
<code>ptIIUserDirectory</code> parameter.

</ol>

Things to note:
<menu>

<li> When the MoML version Orthogonal Communcation model is run
through shallow code generation and a .class file is created, then
the .class file runs faster than the original MoML file because
the MoML parser is not invoked.  
<p>For 20 iterations, the shallow code generation print out the following:
<pre>
361 ms. Memory: 1984K Free: 1145K (58%)
</pre>
Which is almost half the 661 ms. that the interpreted version ran for
</menu>

<h3><a name="#shallowLimitations">Shallow Limitations</a></h3>
The shallow code generator does not have any shallow specific limitations.


<h2><a name="applet">Applet code generation</a></h2>
<p>The Applet code generator takes a model and creates HTML files for 
use as a web based applet.  

<p>The applet generator uses the soot framework, though in principle a
shell script could be used instead.  The applet generator reads
template files that end in <CODE>.in</CODE> from
<CODE>$PTII/ptolemy/copernicus/applet</CODE>, substitutes keywords and
writes out the files in the destination directory.  Users may modify
the template files to match their local setup

 <p>Making an applet available via the web is somewhat complex because
the Java Plugin has two sections, one for Netscape, the other for
Internet Explorer, so changes to the htm files must be replicated in 
both sections.  The codebase and the location of the jar files also add
to the problems.

<p>If a model is named <CODE>MyModel</CODE>, and the user selects
<CODE>foo.bar</CODE> as the package, then saving the model as an
applet will create a directory called <CODE>$PTII/foo/bar/MyModel</CODE>
and create the following files for that model:
<dl>
<dt> <CODE>makefile</CODE>
<dd> <CODE>make demo</CODE> will run appletviewer on the HTML files

<dt> <CODE>MyModel.xml</CODE>
<dd> A local copy of the model

<dt> <CODE>MyModel.htm</CODE>
<dd> An HTML file containing the code necessary to <CODE>MyModel.xml</CODE>


<dt> <CODE>MyModelVergil.htm</CODE>
<dd> An HTML file containing the code necessary to
display <CODE>MyModel.xml</CODE> graphically, using ptolemy.vergil.VergilApplet and in text format

</dl>

Below is a simple demonstration:
<ol>
<li> Open up the
<a
href="../ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xml">SDF
Orthogonal Communication Model</a>

<li> Select View -&gt; Code Generator

<li> Change the <code>CodeGenerator</code> combo box from
<code>java</code> to <code>applet</code>
<li> Hit the Generate Button

<li> The code generator will invoke an separate java process that
generates code in 
<CODE>$PTII/ptolemy/copernicus/<b>applet</b>/cg/OrthogonalCom</CODE>
<li> The co
</ol>

<h3><a name="#appletLimitations">Applet Limitations</a></h3>
<menu>
<li>It would be nice if the applet code generator would bundle
up the necessary class files in a single jar file so that
it was easier to install an applet
</menu>

<h2><a name="interpreted">Interpreted code generation</a></h2>
The interpreted code generator is really not a code generator at all!
It reads in a MoML file and writes out a MoML file, with very little
processing.  The interpreted code generator is used as to compare 
the performance of the other code generators.

<h3><a name="#interpretedLimitations">Interpreted Limitations</a></h3>
The interpreted code generator does not have any interpreted specific limitations.
<p><p><p>

<h2>The code generator user interface</h2>
Christopher Hylands and Professor Edward A. Lee developed an initial
draft of a graphical user interface to control code generation.  

 <p>The user interface reads its parameters from a moml file, the
 default is 
<a href="../ptolemy/copernicus/kernel/Generator.xml"><CODE>$PTII/ptolemy/copernicus/kernel/Generator.xml</CODE></a>.
This file lists the parameters, the initial default value
the documentation for the parameter.
 <p>The documentation for a parameter is viewable as a tool tip.
Try moving the mouse over the name of the parameter, a tool
tip should pop up.
 <p>There are quite a few different parameters, and parameters
can refer to each other by name.  The values of some parameters,
such as the <CODE>modelName</CODE> and <CODE>iterations</CODE>
are derived from the model itself and not actually settable.
 <p>There are several buttons:
<dl>

<dt> <CODE>More Info</CODE>
<dd> Brings up this file.

<dt> <CODE>Parameters</CODE>
<dd> Display the name of the parameter, the value, the value
the parameter evaluates to and the documentation.
<dt> <CODE>Generate</CODE>
<dd> Run the code generator.  Note that the 
<CODE>compile</CODE>, <CODE>show</CODE> and 
<CODE>run</CODE> checkboxes determine whether code is generated
shown and run.
<dt> <CODE>Cancel</CODE>
<dd> Stop a Generation that is in progress
<dt> <CODE>Clear</CODE>
<dd> Clear the output display
</dl>

<h3>How the user interface works</h3>

The code generator is controlled by a GeneratorAttribute
that contains parameters read in from the 
<I>initialParametersURL</I> parameter.  

 <p>When the user hits View -&gt; Code Generator, the model
is queried and any necessary updates to the Parameters occurs.

 <p>When the user hits the <CODE>Generate</CODE> button, the model is
again queried and any necessary updates occur.

 <p>Each of the code generators contains template files
that determine what command is actually run.
For example, the
java code generator uses
<a href="../ptolemy/copernicus/java/compileCommandTemplate.txt"><CODE>$PTII/ptolemy/copernicus/java/compileCommandTemplate.txt</CODE></a>
to determine what command to run to generate the code and
<a href="../ptolemy/copernicus/java/runCommandTemplate.txt"><CODE>$PTII/ptolemy/copernicus/java/runCommandTemplate.txt</CODE></a>
to determine what command to run the generated code.
The format of the files is fairly straightforward, parameters are
substituted in and the command is executed.

We use template files
so that the code generator can be run without requiring the
<CODE>make</CODE> program.

<h3><a name="userInterfaceLimitations">User Interface Limitations</a></h3>

Unfortunately, this UI has many design issues:
<menu>
<li> The interface is cluttered because there are many different
possible parameters to set.  It is fairly easy to make have an
interface that generates code in a default directory with default
names.  However, generating code in non-default locations requires
understanding how the parameter values affect code generation.

<li> The interface uses Ptolemy Parameters so that we can refer 
to other Parameters by name and use their values.  This means
that simple strings need to be enclosed in double quotes.

<li> It would be nice if there was an easier way to see what a
parameter evaluated to.

</menu>
 
<h2>Code Generation History</h2>

<h3>Ptolemy Classic code generation</h3>

In Ptolemy Classic code generation, each separate platform had a
separate domain. This was a slight misuse of the domain
concept, since all most all of the separate platforms really had SDF
semantics, and each separate platform was really a target for the SDF
domain.  However, because of assumptions in the Ptolemy Classic
software architecture, it was easier to add new code generation
targets as separate domains.

 <p>In Ptolemy Classic, if you wanted to generate code for a new
processor, you had to create a new domain and then populate the domain
with new basic blocks that contained codeblocks of code that were
generated when the basic block was used.  This is a bit of a
simplification, but basically it meant that for each new processor,
the author had to generate a new Ramp basic block, a new Add basic
block etc.  This was very time consuming, and tended to have problems,
since if a bug was fixed in one Ramp actor, the bug needed to be fixed
in other Ramp actors in each domain.

 <p>The Adaptive Computing System (ACS) domain was an effort to work
around this issue, where the interface to each actor was shared
between multiple implementations.  This helped make it easier to
switch between different target implementations, since the ACS Ramp
actor always had the same interface, whereas if there were two Ramp
actors in two separate domains, then they might have different port
names, which made switching between the domains difficult.

 <p>More information about the ACS domain can be found in
E. K. Pauer, C. S. Myers, P. D. Fiore, J. M. Smith, C. M. Crawford, E. A. Lee, J. Lundblad and C. Hylands,
<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/98/ACSmapping/">"Algorithm Analysis and Mapping Environment for Adaptive Computing Systems,"</a>
 Presented at the Second Annual Workshop on High Performance
 Embedded Computing, MIT Labs, Lexington, MA, September, 1998. 

 <p>The ACS domain is part of Ptolemy 0.7.2devel, see
<a href="http://ptolemy.eecs.berkeley.edu/ptolemyclassic/pt0.7.2/"><CODE>http://ptolemy.eecs.berkeley.edu/ptolemyclassic/pt0.7.2/</CODE></a>


The Ptolemy Classic style of code generation was used to customize
different actors to take advantage of different features of a
processor.  For example, the Motorola 56x FIR filter actor would pick
a different codeblock depending on how the FIR filter was configured.

 <p>However, the downside of this approach is that the inter-actor
communication tended to consume quite a bit of time, so even with
really great actor implementations, we were getting performance hits
when data was passed between these actors.  It seems to us that
looking at the whole model would yield further performance
improvements.


<h3>Deep Generation History</h3>

Deep code generation parses Java component definitions, and provides
an API for accessing the abstract syntax tree.  It is possible,
in principle, to generate implementations in languages other than
Java from this AST.  Thus, we hope that in the future, we will have
code generators that produce C code for embedded processors,
or VHDL code for hardware design.
<p>
In 2000, Jeff Tsay created an initial implementation of Deep code
generation as part of his  his Masters project:
Jeff Tsay, "<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/00/codegen/" target="_top">A Code Generation Framework for Ptolemy II</a>," ERL Technical Report UCB/ERL No. M00/25, Dept. EECS, University of California, Berkeley, CA  94720, May 19, 2000.

 <p>There is a shorter summary of Jeff's work at:
 <p>Jeff Tsay, Christopher Hylands and Edward Lee, 
<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/00/javacodegen">"A Code Generation Framework for Java Component-Based Designs,"</a>
 CASES 00, November 17-19, 2000, San Jose, CA.

 <p>Jeff's work was a prototype of how we could do code generation in a
different manner, described in the above references and below.
Unfortunately, his prototype code was not easy to extend to match
changes in the Ptolemy type system.  More specfically, the type system
is Yuhong Xiong's area of research, and Jeff's work was not easy to
extend to deal with ArrayTokens.


<h2><a name="soot">Soot</a></h2>
Stephen Neuendorffer developed the framework for the current code generators 
using Soot, which is a Java optimization framework from
<a href="http://www.sable.mcgill.ca/soot/" target="_top"><CODE>http://www.sable.mcgill.ca/soot/</CODE></a> 

<p>Soot operates on class files by applying a series of transformations
that usually do compiler things like common subexpression elimination
or loop unrolling.  We can add transformations that do things like
flattening a model into one class for shallow code generation, or
further processing the AST for deep code generation.

<p>The advantage of Soot over Jeff Tsay's work is that by using soot, we
do not have to parse java files, and the name resolution of objects is
done.  In Jeff's code, we spent a lot of time trying to figure out the
fully dot qualified name of an object who's base name was 'String'.

<p>Jeff Tsay's work was a proof of concept demonstration on what
could be done.  We hope that by using Soot, we can generate a stable system
for use in a production environment.

<h3>Multiprocessors and DSP targets</h3>

Partitioning a model between multiple processors is fairly tricky, and
was a large area of research in Ptolemy Classic.  Only models with a
high degree of parallelism are amenable to running on multiple
processors.  Simply assigning each actor to a processor is not likely
to yield performance improvements, since the inter-actor communication
will really bog things down, especially on a high latency system like
a switched ethernet network.

 <p>Java can take advantage of multiple processors, so in theory, if
we use the process domains in Ptolemy II without code generation on a
multi processor machine, we should see that each Java thread will be
run on a separate processor.  However we have not done much work in
this area.  We'd like to see someone take the PN domain and work on
running it on multiple processors and seeing what sort of improvements
can be made.

 <p>In theory, once we have deep code generation, and we are creating
an AST and generating .class files, we can generate code for any
processor by either writing a new back end, or using a native Java
compiler like gcj.

<h2>Future Plans</h2>
<menu>
<li> Deep code generation needs to have the tokens unboxed so
that it no longer depends on ptolemy.data
<li> Generating C code from a Ptolemy Model is in progress.
<li> We have demonstrated that the Ptolemy code generation framework can
be used to generate FGPA code using
JHDL from Brigham Young University (<a href="http://www.jhdl.org"><code>http://www.jhdl.org</code></a>
<menu>

<h2>Resources</h2>
Below are links to various resources:

<h3><a name="disassemblers">Disassemblers</a></h3>
Soot works with byte codes.  A Java decompiler or disassembler 
can help with debugging
<dl>
<dt> <CODE>jode</CODE>
<dd> <a href="http://jode.sourceforge.net/download.php"
target="_top">http://jode.sourceforge.net/download.php</a> - Written
in Java, but full GPL, so we can't distribute it.
<CODE>$PTII/bin/configure</CODE> looks for jode in 
<CODE>$PTII/vendors/jode/1.1.1</CODE>, and if it finds it, then
<CODE>$PTII/bin/jode</CODE> can be used to invoke jode.

<ol>
<li> Download <a href="http://prdownloads.sourceforge.net/jode/jode-1.1.1.jar"></a>
and save it as <CODE>$PTII/ptolemy/vendors/jode/1.1.1/jode.jar</CODE>

<li> Rerun configure:
<pre>
cd $PTII
rm config.*
./configure
</pre>

<li> Update <CODE>$PTII/bin/jode</CODE>:
<pre>
cd $PTII/bin
make

</pre>

<li> Test it out be decompiling NamedObj:
<pre>
$PTII/bin/jode ptolemy.kernel.util.NamedObj
</pre>

</ol>

 <br>For example, this command will decompile 
the Main class that is generated by the deep code generator:
<pre>
$PTII/bin/jode ptolemy.copernicus.java.cg.OrthogonalCom.Main 
</pre>

<dt> <CODE>javap</CODE>
<dd> <a href="http://java.sun.com/j2se/1.3/docs/tooldocs/solaris/javap.html" target="_top"><CODE>http://java.sun.com/j2se/1.3/docs/tooldocs/solaris/javap.html</CODE></a> - Shipped with Sun's JDK.

<dt> <code>Source Again</code>
<dd> <a href="http://www.ahpah.com/sourceagain/" target="_top"><code>http://www.ahpah.com/sourceagain/</code></a> - Commercial product

<dt> <code>WingDis</code>
<dd> <a href="http://www.wingsoft.com/wingdis.html" target="_top"><code>http://www.wingsoft.com/wingdis.html</code></a> - Commercial product

<dt> <CODE>jad</CODE>
<dd> <a href="http://www.geocities.com/SiliconValley/Bridge/8617/jad.html" target="_top"><CODE>http://www.geocities.com/SiliconValley/Bridge/8617/jad.html</CODE></a> - Jad home page - used to have binaries only, but now broken.
<br><a href="http://www.geocities.com/zz_xu/jad.html#download" target="_top"><code>http://www.geocities.com/zz_xu/jad.html#download</code></a> - Mirror site from 1999 - Jad 1.5.7
<br><a href="http://www.jproof.com/faq/MoreInfo.html" target="_top">http://www.jproof.com/faq/MoreInfo.html</a> - Jad 1.5.7

<a href="http://www.meurrens.org/ip-Links/Java/codeEngineering/jad15.html" target="_top">Mirror, though downloads do not work</a>

</dl>

Other possibilities:
<menu>
<li> <a href="http://bcel.sourceforge.net/" target="_top"><CODE>http://bcel.sourceforge.net/</CODE></a>
</menu>


<h2>Java To C converters</h2>
<dl>
<dl>
<dt> Java Coffee Break Decompiler links
<dd> <a href="http://www.javacoffeebreak.com/directory/index(32).html" target="_top"><CODE>http://www.javacoffeebreak.com/directory/index(32).html</CODE></a>
</dl>

<dt> GCJ - The GNU Compiler for Java
<dd> <a href="http://gcc.gnu.org/java/" target="_top"><CODE>http://gcc.gnu.org/java/</CODE></a>: JDK1.2 compliant
<BLOCKQUOTE>
<menu>
<li> Java source code directly to native machine code, 
<li> Java source code to Java bytecode (class files), 
<li>  and Java bytecode to native machine code. 
</menu>
</BLOCKQUOTE>


<dt> Jolt: Converting bytecode to C
<dd> <a href="http://www.meurrens.org/ip-Links/Java/codeEngineering/blackDown/jolt.html" target="_top"><CODE>http://www.meurrens.org/ip-Links/Java/codeEngineering/blackDown/jolt.html</CODE></a>: initial hack


<dt> Harissa
<dd> <a href="http://www.irisa.fr/compose/harissa/harissa.html" target="_top"><CODE>http://www.irisa.fr/compose/harissa/harissa.html</CODE></a>: 1999: JDK1.0.2?


<dt> Toba: A Java-to-C Translater
<dd> <a href="http://www.cs.arizona.edu/sumatra/toba/" target="_top"><CODE>http://www.cs.arizona.edu/sumatra/toba/</CODE></a>: Does not support JDK1.2

<dt> JCC
<dd> <a href="http://www.geocities.com/CapeCanaveral/Hangar/4040/jcc.html" target="_top"><CODE>http://www.geocities.com/CapeCanaveral/Hangar/4040/jcc.html</CODE></a>: 1997, probably does not support JDK1.2


</dl>

<h2>Misc</h2>
<menu>
<li> <a href="http://found.cs.nyu.edu/meyer/jasmin/">Jasmin</a> 
a Java Assembler Interface (1997)
<li> <a
href="http://www.geocrawler.com/archives/3/338/1996/8/0/1876595/">Jasmin
emacs mode</a>
</menu>
</body>
</html>

