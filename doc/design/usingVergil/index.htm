<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 6.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="index.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
 2.1  Introduction
</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<OL>
<LI CLASS="FM1Heading">
<A NAME="pgfId-158262"></A><A NAME="23919"></A>Using Vergil</LI>
</OL>
<P CLASS="Author">
<A NAME="pgfId-162678"></A>Authors:		Edward A. Lee</P>
<P CLASS="Author">
<A NAME="pgfId-169035"></A>		Steve Neuendorffer</P>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-164801"></A><A NAME="42160"></A>Introduction</H2>
<P CLASS="FirstBody">
<A NAME="pgfId-167666"></A>There are many ways to use Ptolemy II. It can be used as a framework for assembling software components, as a modeling and simulation tool, as a block-diagram editor, as a system-level rapid prototyping application, as a toolkit supporting research in component-based design, or as a toolkit for building Java applications. This chapter introduces its use as a modeling and simulation tool.</P>
<P CLASS="Body">
<A NAME="pgfId-167754"></A>In this chapter, we describe how to graphically construct models using <A NAME="marker-167752"></A>Vergil, a <A NAME="marker-167753"></A>graphical user interface (<A NAME="marker-167755"></A>GUI) for Ptolemy II. figure <A HREF="usingVergil.htm#74460" CLASS="XRef">See Example of a Vergil window.</A> shows a simple Ptolemy II model in Vergil, showing the graph editor, one of several editors available in Vergil. Keep in mind as you read this that graphical entry of models is only one of several possible mechanisms available in Ptolemy II. Moreover, only some of the execution engines (called domains) are represented here. A major emphasis of Ptolemy II is to provide a framework for the construction of modeling and design tools, so the specific modeling and design tools described here should be viewed as representative.</P>
<DIV>
<MAP NAME="index-1">
</MAP>
<IMG SRC="index-1.gif" USEMAP="#index-1">
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-165833"></A>Quick Start</H2>
<P CLASS="Body">
<A NAME="pgfId-165834"></A>The traditional first programming example is one that prints &quot;Hello World.&quot; Why break tradition?</P>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169820"></A>Starting Vergil</H3>
<P CLASS="Body">
<A NAME="pgfId-165846"></A>First start Vergil. From the command line, enter &quot;vergil&quot;, or select Vergil or Ptolemy II in the Start menu, or click on a <A NAME="marker-167735"></A>Web Start link on a web page supporting the <A NAME="marker-167734"></A>web edition. You should see a welcome screen that looks like the one in figure <A HREF="usingVergil.htm#66708" CLASS="XRef">See Welcome window.</A>. Feel free to explore the links in this window. Most useful is probably the &quot;Quick tour&quot; link.</P>
<DIV>
<MAP NAME="index-2">
</MAP>
<IMG SRC="index-2.gif" USEMAP="#index-2">
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-166445"></A>Creating a New Model</H3>
<P CLASS="Body">
<A NAME="pgfId-169824"></A>Create a new graph editor from the <A NAME="marker-166625"></A>File-&gt;New menu in the <A NAME="marker-166626"></A>welcome window. You should see something like the window shown in figure <A HREF="usingVergil.htm#30804" CLASS="XRef">See An empty Vergil Graph Editor.</A>. Ignoring the menus and toolbar for a moment, on the left is a palette of objects that can be dragged onto the page on the right. To begin with, the page on the right is blank. Open the <A NAME="marker-166627"></A>actor library in the palette, and go into the <A NAME="marker-166628"></A>sources library. Find the <A NAME="marker-166672"></A>Const actor and drag an instance over onto the blank page. Then go into the <A NAME="marker-166629"></A>sinks library and drag a <A NAME="marker-166673"></A>Display actor onto the page. Each of these actors can be dragged around on the page. However, we would like to connect one to the other. To do this, drag a connection from the output port on the right of the Const actor to the input port of the Display actor. Lastly, open the <A NAME="marker-166630"></A>director library and drag an <A NAME="marker-167737"></A>SDFDirector onto the page. The <A NAME="marker-167736"></A>director gives an execution meaning to the graph, but for now we don't have to be concerned about exactly what that is.</P>
<DIV>
<MAP NAME="index-3">
</MAP>
<IMG SRC="index-3.gif" USEMAP="#index-3">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-165895"></A>Now you should have something that looks like figure <A HREF="usingVergil.htm#56559" CLASS="XRef">See The Hello World example.</A>. The Const actor is going to create our string, and the Display actor is going to print it out for us. We need to take care of one small detail to make it look like figure <A HREF="usingVergil.htm#56559" CLASS="XRef">See The Hello World example.</A>: we need to tell the Const actor that we want the string &quot;Hello World&quot;. To do this we need to edit one of the parameters of the Const. To do this, either double click on the Const actor icon, or right click on the Const actor icon and select &quot;Configure&quot;. You should see the dialog box in figure <A HREF="usingVergil.htm#76275" CLASS="XRef">See The Const parameter editor.</A>. Enter the string &quot;Hello World&quot; for the value parameter and click the Commit button. Be sure to include the double quotes, so that the expression is interpreted as a string.</P>
<DIV>
<MAP NAME="index-4">
</MAP>
<IMG SRC="index-4.gif" USEMAP="#index-4">
</DIV>
<DIV>
<MAP NAME="index-5">
</MAP>
<IMG SRC="index-5.gif" USEMAP="#index-5">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-169832"></A>You may wish to save your model, using the File menu.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169828"></A>Running the Model</H3>
<P CLASS="Body">
<A NAME="pgfId-166518"></A>To run the example, go to the <A NAME="marker-166624"></A>View menu and select the <A NAME="marker-166623"></A>Run Window. If you click the &quot;Go&quot; button, you will see a large number of strings in the display at the right. To stop the execution, click the &quot;Stop button. To see only one string, change the <A NAME="marker-166631"></A>iterations parameter of the director to 1, which can be done in the run window, or in the graph editor in the same way you edited the parameter of the Const actor before. The run window is shown in figure <A HREF="usingVergil.htm#15942" CLASS="XRef">See Execution of the Hello World example.</A>.</P>
<DIV>
<MAP NAME="index-6">
</MAP>
<IMG SRC="index-6.gif" USEMAP="#index-6">
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169795"></A>Making Connections</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-169838"></A>The model constructed above contained only two actors and one connection between them. If you move either actor (by clicking and dragging), you will see that the connection is routed automatically (although not particularly intelligently). We can now explore how to create and manipulate more complicated connections.</P>
<P CLASS="Body">
<A NAME="pgfId-169954"></A>First create a model that includes an SDFDirector, a <A NAME="marker-169953"></A>Ramp actor (found in the sources) library, a Display actor, and a <A NAME="marker-169955"></A>SequencePlotter actor, found in the sinks library, as shown in figure <A HREF="usingVergil.htm#72088" CLASS="XRef">See Exception that occurs if you attempt to simply wire the output of the Ramp in figure 2.8 to the inputs of the other two actors.</A>. Suppose we wish to route the output of the Ramp to both the Display and the SequencePlotter. If we simply attempt to make the connections, we get the exception shown in figure <A HREF="usingVergil.htm#72088" CLASS="XRef">See Exception that occurs if you attempt to simply wire the output of the Ramp in figure 2.8 to the inputs of the other two actors.</A>. Don't panic! Exceptions are normal and common. The key line in this <A NAME="marker-169977"></A>exception report is the last one, which says</P>
<DIV>
<MAP NAME="index-7">
</MAP>
<IMG SRC="index-7.gif" USEMAP="#index-7">
</DIV>
<DIV>
<MAP NAME="index-8">
</MAP>
<IMG SRC="index-8.gif" USEMAP="#index-8">
</DIV>
<P CLASS="Code">
<A NAME="pgfId-169899"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169903"></A>Attempt to link more than one relation to a single port.</P>
<P CLASS="Code">
<A NAME="pgfId-169908"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-169909"></A>The line above that gives the names of the objects involved, which are </P>
<P CLASS="Code">
<A NAME="pgfId-169915"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169919"></A>.&lt;Unnamed Object&gt;.Ramp.output and .&lt;Unnamed Object&gt;.relation3</P>
<P CLASS="Code">
<A NAME="pgfId-169931"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-169932"></A>In Ptolemy II models, all objects have a <A NAME="dotted name"></A>dotted <A NAME="marker-169978"></A>name. The dots separate elements in the hierarchy. Thus, &quot;.&lt;Unnamed Object&gt;.Ramp.output&quot; is an object named &quot;output&quot; contained by an object named &quot;Ramp&quot;, which is contained by an unnamed object (the model itself). The model has no name because we have not assigned one (it acquires a name when we save it).</P>
<P CLASS="Body">
<A NAME="pgfId-169979"></A>Why did this exception occur? Ptolemy II supports two distinct flavors of ports, indicated in the diagrams by a filled triangle or an unfilled triangle. The output port of the Ramp actor is a <A NAME="marker-169980"></A>single port, indicated by a filled triangle, which means that it can only support a single connection. The input port of the Display and SequencePlotter actors are <A NAME="marker-169981"></A>multiports, indicated by unfilled triangles, which means that they can support multiple connections. Each connection is treated as a separate <A NAME="marker-169982"></A>channel.</P>
<P CLASS="Body">
<A NAME="pgfId-169983"></A>So how do we get the output of the Ramp to the other two actors? We need an explicit <A NAME="marker-169984"></A>relation in the diagram. A relation is represented in the diagram by a black diamond, as shown in figure <A HREF="usingVergil.htm#84069" CLASS="XRef">See A relation can be used to broadcast an output from a single port.</A>. It can be created by either control-clicking on the background or by clicking on the button in the toolbar with the black diamond on it.</P>
<DIV>
<MAP NAME="index-9">
</MAP>
<IMG SRC="index-9.gif" USEMAP="#index-9">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-170018"></A>Making a connection to a relation can be tricky, since if you just click and drag on the relation, the relation gets selected and moved. To make a connection, hold the control button while clicking and dragging on the relation.</P>
<P CLASS="Body">
<A NAME="pgfId-170023"></A>In the model shown in figure <A HREF="usingVergil.htm#84069" CLASS="XRef">See A relation can be used to broadcast an output from a single port.</A>, the relation is used to broadcast the output from a single port to a number of places. The single port still has only one connection to it, a connection to a relation. Relations can also be used to control the routing of wires in the diagram. However, as of the 2.0 release of Ptolemy II, a connection can only have a single relation on it, so the degree to which routing can be controlled is limited.</P>
<P CLASS="Body">
<A NAME="pgfId-170038"></A>To explore multiports, try putting some other signal source in the diagram and connecting it to the SequencePlotter or to the Display. If you explore this fully, you will discover that the SequencePlotter can only accept inputs of type double, or some type that can be losslessly converted to double, such as int. These data type issues are explored next.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-167800"></A>Tokens and Data Types</H2>
<P CLASS="Body">
<A NAME="pgfId-167804"></A>In the example of figure <A HREF="usingVergil.htm#56559" CLASS="XRef">See The Hello World example.</A>, the Const actor creates a sequence of values on its output port. The values are encapsulated as <A NAME="marker-167842"></A>tokens, and sent to the Display actor, which consumes them and displays them in the run window.</P>
<P CLASS="Body">
<A NAME="pgfId-167859"></A>The tokens produced by the Const actor can have any value that can be expressed in the Ptolemy II <A NAME="marker-167854"></A>expression language. We will say more about the expression language, but for now, try giving the value 1 (the integer with value one), or 1.0 (the floating-point number with value one), or {1.0} (An array containing a one), or {value=1, name=&quot;one&quot;} (A record with two elements: an integer named &quot;value&quot; and a string named &quot;name&quot;), or even [1,0;0,1] (the two-by-two identity matrix). These are all expressions.</P>
<P CLASS="Body">
<A NAME="pgfId-168187"></A>The Const actor is able to produce data with different <A NAME="marker-168186"></A>types, and the Display actor is able to display data with different types. Most actors in the actor library are <A NAME="marker-168188"></A>polymorphic, meaning that they can operate on or produce data with multiple types. The behavior may even be different for different types. Multiplying matrices, for example, is not the same as multiplying integers, but both are accomplished by the <A NAME="marker-168189"></A><A NAME="marker-168190"></A><A NAME="marker-168191"></A>MultiplyDivide actor in the <A NAME="marker-168192"></A>math library. Ptolemy II includes a sophisticated <A NAME="marker-168193"></A>type system that allows this to be done efficiently and safely.</P>
<P CLASS="Body">
<A NAME="pgfId-168209"></A>To explore <A NAME="marker-168194"></A>data types a bit further, try creating the model in figure <A HREF="usingVergil.htm#52798" CLASS="XRef">See Another example, used to explore data types in Ptolemy II.</A>. The <A NAME="marker-168208"></A>Ramp actor is listed under sources and the <A NAME="marker-168210"></A>AddSubtract actor is listed under math. Set the value parameter of the constant to be 0 and the iterations parameter of the director to 5. Running the model should result in 5 numbers between 0 and 4, as shown in the figure. These are the values produced by the Ramp, which are having the value of the Const actor subtracted from them. Experiment with changing the value of the Const actor and see how it changes the 5 numbers at the output.</P>
<DIV>
<MAP NAME="index-10">
</MAP>
<IMG SRC="index-10.gif" USEMAP="#index-10">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-168231"></A>Now for the real test: change the value of the Const actor back to &quot;Hello World&quot;. When you execute the model, you should see an <A NAME="marker-168211"></A>exception window, as shown in figure <A HREF="usingVergil.htm#66595" CLASS="XRef">See An example that triggers an exception when you attempt to execute it. Strings cannot be subtracted from integers.</A>. Do not worry; exceptions are a normal part of constructing (and <A NAME="debugging"></A>debugging) models. In this case, the exception window is telling you that you have tried to subtract a string value from an integer value, which doesn't make much sense at all (following Java, adding strings is allowed). This is an example of a <A NAME="type error"></A>type error.</P>
<DIV>
<MAP NAME="index-11">
</MAP>
<IMG SRC="index-11.gif" USEMAP="#index-11">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-168136"></A>Exceptions can be a very useful debugging tool, particularly if you are developing your own components in Java. To illustrate how to use them, click on the <A NAME="Display Stack Trace button"></A>Display Stack Trace button in the exception window of figure <A HREF="usingVergil.htm#66595" CLASS="XRef">See An example that triggers an exception when you attempt to execute it. Strings cannot be subtracted from integers.</A>. You should see the stack trace shown in figure <A HREF="usingVergil.htm#38273" CLASS="XRef">See Stack trace for the exception shown in figure 2.11.</A>. This window displays the execution sequence that resulted in the exception. For example, the line</P>
<DIV>
<MAP NAME="index-12">
</MAP>
<IMG SRC="index-12.gif" USEMAP="#index-12">
</DIV>
<P CLASS="Code">
<A NAME="pgfId-168266"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-168270"></A>at ptolemy.data.IntToken.subtract(IntToken.java:547)</P>
<P CLASS="Code">
<A NAME="pgfId-168275"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-168276"></A>indicates that the exception occurred within the subtract() method of the class ptolemy.data.IntToken, at line 547 of the source file IntToken.java. Since Ptolemy II is distributed with source code (except in the Web Edition), this can be very useful information. For type errors, you probably do not need to see the stack trace, but if you have extended the system with your own Java code, or you encounter a subtle error that you do not understand, then looking at the stack trace can be very illuminating.</P>
<P CLASS="Body">
<A NAME="pgfId-168405"></A>To find the file IntToken.java referred to above, find the Ptolemy II installation directory. If that directory is $PTII, then the location of this file is given by the full class name, but with the periods replaced by slashes; in this case, it is at <EM CLASS="Code">
$PTII</EM>
/ptolemy/data/IntToken.java (the slashes might be backslashes under Windows).</P>
<P CLASS="Body">
<A NAME="pgfId-168116"></A>Let's try a small change to the model to get something that does not trigger an exception. Disconnect the Const from the lower port of the <A NAME="marker-168117"></A>AddSubtract actor and connect it instead to the upper port, as shown in figure <A HREF="usingVergil.htm#23515" CLASS="XRef">See Addition of a string to an integer.</A>. You can do this by selecting the connection and deleting it (using the delete key), then adding a new connection, or by selecting it and dragging one of its endpoints to the new location. Notice that the upper port is hollow; this indicates that it is a <A NAME="marker-168121"></A>multiport, meaning that you can make more than one connection to it. Now when you run the model you should see strings like &quot;0HelloWorld&quot;, as shown in the figure.</P>
<DIV>
<MAP NAME="index-13">
</MAP>
<IMG SRC="index-13.gif" USEMAP="#index-13">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-166645"></A>There are two interesting things going on here. The first is that, as in Java, strings are added by concatenating them. The second is that the integers from the Ramp are converted to strings and concatenated with the string &quot;Hello World&quot;. All the connections to a multiport must have the same type. In this case, the multiport has a sequence of integers coming in (from the Ramp) and a sequence of strings (from the Const).</P>
<P CLASS="Body">
<A NAME="pgfId-168385"></A>Ptolemy II automatically converts the integers to strings when integers are provided to an actor that requires strings. But in this case, why does the AddSubtract actor require strings? Because it would not work to require integers; the string &quot;Hello World&quot; would have to be converted to an integer. As a rough guideline, Ptolemy II will perform automatic type conversions when there is no loss of information. An integer can be converted to a string, but not vice versa. An integer can be converted to a double, but not vice versa. An integer can be converted to a long, but not vice versa. The details are explained in the Data chapter, but many users will not need to understand the full sophistication of the system. You should find that most of the time it will just do what you expect.</P>
<P CLASS="Body">
<A NAME="pgfId-168409"></A>To further explore data types, try modifying the Ramp so that its parameters have different types. For example, try making init and step strings.</P>
</DIV>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-166138"></A>Hierarchy</H2>
<P CLASS="Body">
<A NAME="pgfId-170409"></A>Ptolemy II supports (and encourages) <A NAME="marker-170451"></A>hierarchical models. These are models that contain components that are themselves models. Such components are called <A NAME="marker-170452"></A>composite actors. Consider a small signal processing problem, where we are interested in recovering a signal based only on noisy measurements of it. We will create a composite actor modeling a communication channel that adds noise, and then use that actor in a model.</P>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-170413"></A>Creating a Composite Actor</H3>
<P CLASS="Body">
<A NAME="pgfId-170457"></A>First open a new document and drag in a <A NAME="marker-170410"></A>Typed <A NAME="marker-170411"></A>Composite Actor from the <A NAME="marker-170412"></A>utilities library. This actor is going to add noise to our measurements. First, using the <A NAME="marker-170414"></A>context menu (obtained by <A NAME="marker-170415"></A>right clicking over the composite actor), select &quot;Customize Name&quot;, and give the composite a better name, like &quot;Channel&quot;, as shown in figure <A HREF="usingVergil.htm#35621" CLASS="XRef">See Changing the name of an actor.</A>. Then, using the context menu again, select &quot;<A NAME="Look Inside"></A>Look Inside&quot; on the actor. You should get a blank graph editor, as shown in figure <A HREF="usingVergil.htm#12497" CLASS="XRef">See Looking inside a composite actor.</A>. The original graph editor is still open. To see it, move the new one using its title bar.</P>
<DIV>
<MAP NAME="index-14">
</MAP>
<IMG SRC="index-14.gif" USEMAP="#index-14">
</DIV>
<DIV>
<MAP NAME="index-15">
</MAP>
<IMG SRC="index-15.gif" USEMAP="#index-15">
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-170461"></A>Adding Ports to a Composite Actor</H3>
<P CLASS="Body">
<A NAME="pgfId-166651"></A>First we have to add some ports to the composite actor. There are several ways to do this, but clicking on the <A NAME="port buttons in the toolbar"></A>port buttons in the <A NAME="toolbar"></A>toolbar is probably the easiest. You can explore the ports in the toolbar by lingering with the mouse over each button in the toolbar. A tooltip pops up that explains the button. The buttons are summarized in figure <A HREF="usingVergil.htm#99828" CLASS="XRef">See Summary of toolbar buttons for creating new ports.</A>. Create an input port and an output port and rename them input and output right clicking on the ports and selecting &quot;<A NAME="Customize Name"></A>Customize Name&quot;. Note that, as shown in figure <A HREF="usingVergil.htm#94708" CLASS="XRef">See Right clicking on the background brings up a dialog that can be used to configure ports.</A>, you can also right click on the background of the composite actor and select <A NAME="marker-166657"></A>Configure Ports to change whether a port is an input, an output, or a multiport. The resulting dialog also allows you to set the type of the port, although much of the time you will not need to do this, since the <A NAME="marker-168724"></A>type inference mechanism in Ptolemy II will figure it out from the connections.</P>
<DIV>
<MAP NAME="index-16">
</MAP>
<IMG SRC="index-16.gif" USEMAP="#index-16">
</DIV>
<DIV>
<MAP NAME="index-17">
</MAP>
<IMG SRC="index-17.gif" USEMAP="#index-17">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-168725"></A>Then using these ports, create the diagram shown in figure <A HREF="usingVergil.htm#81645" CLASS="XRef">See A simple channel model defined as a composite actor.</A><A HREF="#pgfId-166915" CLASS="footnote">1</A>. The <A NAME="marker-166664"></A>Gaussian actor creates values from a Gaussian distributed random variable, and is found in the <A NAME="marker-168779"></A>random library. Now if you close this editor and return to the previous one, you should be able to easily create the model shown in figure <A HREF="usingVergil.htm#71815" CLASS="XRef">See A simple signal processing example that adds noise to a sinusoidal signal.</A>. The <A NAME="marker-166668"></A>Sinewave actor is listed under sources, and the <A NAME="marker-166670"></A>SequencePlotter actor is found in sinks. Notice that the Sinewave actor is also a hierarchical model, as suggested by its red outline (try looking inside). If you execute this model (you will probably want to set the iterations to something reasonable, like 100), you should see something like figure <A HREF="usingVergil.htm#72225" CLASS="XRef">See The output of the simple signal processing model in figure 2.19.</A>.</P>
<DIV>
<MAP NAME="index-18">
</MAP>
<IMG SRC="index-18.gif" USEMAP="#index-18">
</DIV>
<DIV>
<MAP NAME="index-19">
</MAP>
<IMG SRC="index-19.gif" USEMAP="#index-19">
</DIV>
<DIV>
<MAP NAME="index-20">
</MAP>
<IMG SRC="index-20.gif" USEMAP="#index-20">
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-170343"></A>Setting the Types of Ports</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-170465"></A>In the above example, we never needed to define the <A NAME="marker-170538"></A>types of any ports. The types were inferred from the connections. Indeed, this is usually the case in Ptolemy II, but occasionally, you will need to set the types of the ports. Notice in figure <A HREF="usingVergil.htm#94708" CLASS="XRef">See Right clicking on the background brings up a dialog that can be used to configure ports.</A> that there is a position in the dialog box that configures ports for specifying the type. The natural question you might have is &quot;how do I specify the type?&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-170473"></A>The answer to this question seems too obvious: you specify a <A NAME="marker-170474"></A>prototype, an expression that has the type that you want to specify. Thus, to specify that a port has type boolean, you could enter into the dialog of figure <A HREF="usingVergil.htm#94708" CLASS="XRef">See Right clicking on the background brings up a dialog that can be used to configure ports.</A> the value &quot;true&quot; or &quot;false&quot;. This, however, might not be too clear. For this reason, Ptolemy II has a built-in constant named &quot;boolean&quot; that happens to have value &quot;true&quot;. Thus, if you specify that the type is &quot;<A NAME="marker-170526"></A>boolean&quot;, then, well, you have specified that the type is boolean.</P>
<P CLASS="Body">
<A NAME="pgfId-170481"></A>There are several other constants that similarly can be used to specify types. They are <A NAME="marker-170527"></A>complex, <A NAME="marker-170528"></A>double, <A NAME="marker-170529"></A>fixedpoint, <A NAME="marker-170530"></A>general, <A NAME="marker-170531"></A>int, <A NAME="marker-170532"></A>long, <A NAME="marker-170533"></A>matrix, <A NAME="marker-170534"></A>object, <A NAME="marker-170535"></A>scalar, <A NAME="marker-170536"></A>string, and <A NAME="marker-170537"></A>unknown. So how would you specify that the type of a port is a double matrix? Easy:</P>
<P CLASS="Code">
<A NAME="pgfId-170539"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-170543"></A>[double]</P>
<P CLASS="Code">
<A NAME="pgfId-170544"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-170545"></A>This expression actually creates a 1 by 1 matrix containing a double (the value of which is irrelevant). It thus serves as a prototype to specify a double matrix type. Similarly, we can specify an array of complex numbers as</P>
<P CLASS="Code">
<A NAME="pgfId-170549"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-170553"></A>{complex}</P>
<P CLASS="Code">
<A NAME="pgfId-170554"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-170555"></A>In the Ptolemy II expression language, <A NAME="marker-170559"></A>square braces are used for matrices, and <A NAME="marker-170560"></A>curly braces are used for arrays. What about a record containing a string named &quot;name&quot; and an integer named &quot;address&quot;? Easy:</P>
<P CLASS="Code">
<A NAME="pgfId-170561"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-170565"></A>{name=string, address=int}</P>
<P CLASS="Code">
<A NAME="pgfId-170566"></A>&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-168727"></A>Annotations and Parameterization</H2>
<P CLASS="FirstBody">
<A NAME="pgfId-168830"></A>In this section, we will enhance the model in figure <A HREF="usingVergil.htm#71815" CLASS="XRef">See A simple signal processing example that adds noise to a sinusoidal signal.</A> in a number of ways.</P>
<P CLASS="Body">
<A NAME="pgfId-168893"></A>First, notice from figure <A HREF="usingVergil.htm#72225" CLASS="XRef">See The output of the simple signal processing model in figure 2.19.</A> that the noise overwhelms the sinusoid, making it barely visible. A useful channel model would have a parameter that sets the level of the noise. Look inside the channel model, and add a parameter by dragging one in from the utilities library, as shown in figure <A HREF="usingVergil.htm#80126" CLASS="XRef">See Adding a parameter to the channel model.</A>. Right click on the parameter to change its name to &quot;noisePower&quot;. (In order to be able to use this parameter in expressions, the name cannot have any spaces in it.) Also, right click or double click on the parameter to change its default value to 0.1.</P>
<DIV>
<MAP NAME="index-21">
</MAP>
<IMG SRC="index-21.gif" USEMAP="#index-21">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-168902"></A>Now we can use this parameter. First, let's use it to set the amount of noise. The <A NAME="marker-168903"></A>Gaussian actor has a parameter called <A NAME="marker-168914"></A>standardDeviation. In this case, the power of the noise is equal to the <A NAME="marker-168915"></A>variance of the Gaussian, not the <A NAME="marker-168916"></A>standard deviation. If you recall from basic statistics, the standard deviation is equal to the square root of the variance. Change the parameter of the Gaussian actor so its value is &quot;sqrt(noisePower)&quot;, as shown in figure <A HREF="usingVergil.htm#72094" CLASS="XRef">See The standard deviation of the Gaussian actor is set to the square root of the noise power.</A>. This is an expression that references the noisePower parameter. We will explain the expression language in the next section. But first, let check our improved model. Return to the top-level model, and edit the parameters of the Channel actor (by either double clicking or right clicking and selecting &quot;Configure&quot;). Change the noise power from the default 0.1 to 0.01. Run the model. You should now get a relatively clean sinusoid like that shown in figure <A HREF="usingVergil.htm#54485" CLASS="XRef">See The output of the simple signal processing model in figure 2.19.</A>.</P>
<DIV>
<MAP NAME="index-22">
</MAP>
<IMG SRC="index-22.gif" USEMAP="#index-22">
</DIV>
<DIV>
<MAP NAME="index-23">
</MAP>
<IMG SRC="index-23.gif" USEMAP="#index-23">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-168972"></A>Note that you can also add parameters to a composite actor without dragging from the utilities library by clicking on the &quot;Add&quot; button in the edit parameters dialog for the Channel composite. This dialog can be obtained by either double clicking on the Channel icon, or by right clicking and selecting &quot;Configure&quot;, or by right clicking on the background inside the composite and selecting &quot;Edit Parameters&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId-168981"></A>There are several other useful enhancements you could make to this model. Try dragging an <A NAME="marker-168985"></A>annotation from the utilities library and creating a title on the diagram. Also, try setting the title of the plot by clicking on the button at the upper right of the plotter that produces the tooltip &quot;Set the plot format&quot;.</P>
</DIV>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-168803"></A>Expressions</H2>
<P CLASS="Body">
<A NAME="pgfId-167419"></A>The values of parameters can be expressions. We have already seen a simple one,</P>
<P CLASS="Code">
<A NAME="pgfId-168988"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-168994"></A>sqrt(noisePower)</P>
<P CLASS="Code">
<A NAME="pgfId-169002"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-168989"></A>Expressions can be used to specify the value of a parameter, or to specify the calculation performed by the <A NAME="marker-171265"></A>Expression actor when it fires.</P>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-171261"></A><A NAME="42872"></A>Expression Actor</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-171267"></A>The <A NAME="marker-171268"></A>Expression actor is a particularly useful actor found in the <A NAME="marker-171269"></A>math library. By default, it has one output an no inputs, as shown in figure <A HREF="usingVergil.htm#95786" CLASS="XRef">See Illustration of the Expression actor.</A>(a). The first step in using it is to add ports, as shown in (b) and (c), resulting in a new icon as shown in (d). Then specify an expression using the port names, as shown in (e), resulting in the icon shown in (f).</P>
<DIV>
<MAP NAME="index-24">
</MAP>
<IMG SRC="index-24.gif" USEMAP="#index-24">
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-171266"></A>Constants and Literals</H3>
<P CLASS="Body">
<A NAME="pgfId-169751"></A>Expressions can include references to variables and some constants. By default, the <A NAME="marker-167421"></A>constants supported are <A NAME="marker-167422"></A>PI, <A NAME="marker-167423"></A>pi, <A NAME="marker-167424"></A>E, <A NAME="marker-167425"></A>e, <A NAME="marker-167426"></A>true, <A NAME="marker-167427"></A>false, <A NAME="marker-167428"></A>i, and <A NAME="marker-167429"></A>j. for example,</P>
<P CLASS="Code">
<A NAME="pgfId-167480"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-167488"></A>PI/2.0</P>
<P CLASS="Code">
<A NAME="pgfId-167489"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-167490"></A>is a valid expression, and can be given as the value of a parameter that can accept doubles. The constants i and j are complex numbers with value equal to 0.0 + 1.0i. In addition, <A NAME="marker-167430"></A>literal string constants are supported. Anything between quotes, &quot;...&quot;, is interpreted as a <A NAME="marker-167431"></A>string constant. Numerical values without decimal points, such as &quot;10&quot; or &quot;-3&quot; are <A NAME="marker-167432"></A>integers. Numerical values with decimal points, such as &quot;10.0&quot; or &quot;3.14159&quot; are <A NAME="marker-167433"></A>doubles. Integers followed by the character &quot;l&quot; (el) or &quot;L&quot; are <A NAME="marker-167434"></A>long integers.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169755"></A>Operators</H3>
<P CLASS="Body">
<A NAME="pgfId-167501"></A>The <A NAME="marker-166973"></A>arithmetic operators are +, <EM CLASS="Symbol">
&#8722;,</EM>
 *, /, ^, and %. Most of these operators operate on most data types, including matrices. The ^ operator computes &quot;to the power of&quot; where the power can only be an integer. The <A NAME="marker-166980"></A>bitwise operators are &amp;, |, and &#126;. They operate on integers, where &amp; is bitwise and, &#126; is bitwise not, and | is bitwise or. </P>
<P CLASS="Body">
<A NAME="pgfId-167512"></A>The <A NAME="marker-166983"></A>relational operators are &lt;, &lt;=, &gt;, &gt;=, <EM CLASS="Code">
==</EM>
 and !=. They return booleans. Boolean-valued expressions can be used to give conditional values. The syntax for this is </P>
<P CLASS="Code">
<A NAME="pgfId-167514"></A>boolean ? value1 : value2</P>
<P CLASS="LBody">
<A NAME="pgfId-167515"></A>If the boolean is true, <EM CLASS="Code">
value1</EM>
 is returned, else <EM CLASS="Code">
value2</EM>
 is returned. The <A NAME="marker-166986"></A>logical boolean operators are &amp;&amp;, ||, !, &amp; and |. They operate on booleans and return booleans. Note that the difference between logical &amp;&amp; and logical &amp; is that &amp; evaluates all the operands regardless of whether their value is now irrelevant. Similarly for logical || and |. This approach is borrowed from Java.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169759"></A>Variables</H3>
<P CLASS="Body">
<A NAME="pgfId-167529"></A>Expressions can contain references by name to parameters within the <EM CLASS="Emphasis">
scope</EM>
<A NAME="marker-167528"></A> of the expression. Consider a parameter P in actor X which is in turn contained by composite actor Y. The scope of an expression for P includes all the parameters contained by X and Y, plus those of the container of Y, its container, etc. That is, the scope includes any parameters defined above in the hierarchy. You can <A NAME="marker-167536"></A>add <A NAME="marker-167537"></A>parameters to actors (composite or not) by right clicking on the actor, selecting &quot;Configure&quot; and then clicking on &quot;Add&quot;, or by dragging in a parameter from the utilities library.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169763"></A>Arrays</H3>
<P CLASS="Body">
<A NAME="pgfId-167020"></A><A NAME="marker-167552"></A>Arrays are specified with curly brackets. E.g., &quot;{1, 2, 3}&quot; is an array of integers, while &quot;<EM CLASS="Code">
{&quot;x&quot;, &quot;y&quot;, &quot;z&quot;}</EM>
&quot; is an array of strings. An array is an ordered list of tokens of any type, with the only constraint being that the elements all have the same type. Thus, for example, &quot;{1, 2.3}&quot; is illegal because the first element is an integer and the second is a double. The elements of the array can be given by expressions, as in the example &quot;{2*pi, 3*pi}.&quot; Arrays can be nested; for example, &quot;{{1, 2}, {3, 4, 5}}&quot; is an array of arrays of integers.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169767"></A>Matrices</H3>
<P CLASS="Body">
<A NAME="pgfId-169058"></A>In Ptolemy II, arrays are ordered sets of tokens. Ptolemy II also supports <A NAME="marker-169143"></A>matrices, which are more specialized than arrays. They contain only primitive types, currently boolean, complex, double, fixedpoint, int, and long. Matrices cannot contain arbitrary tokens, so they cannot, for example, contain matrices. They are intended for data intensive computations.</P>
<P CLASS="Body">
<A NAME="pgfId-167023"></A><A NAME="marker-167575"></A>Matrices are specified with square brackets, using commas to separate row elements and semicolons to separate rows. E.g., &quot;[1, 2, 3; 4, 5, 5+1]&quot; gives a two by three integer matrix (2 rows and 3 columns). Note that an array or matrix element can be given by an expression, but all elements must have the same type, and that type must be one of the types for which matrices are defined. A row vector can be given as &quot;[1, 2, 3]&quot; and a column vector as &quot;[1; 2; 3]&quot;. Some Matlab-style array constructors are supported. For example, &quot;[1:2:9]&quot; gives an array of odd numbers from 1 to 9, and is equivalent to &quot;[1, 3, 5, 7, 9].&quot; Similarly, &quot;[1:2:9; 2:2:10]&quot; is equivalent to &quot;[1, 3, 5, 7, 9; 2, 4, 6, 8, 10].&quot; In the syntax &quot;[p:q:r]&quot;, p is the first element, q is the step between elements, and r is an upper bound on the last element. That is, the matrix will not contain an element larger than r.</P>
<P CLASS="FirstBody">
<A NAME="pgfId-167025"></A>Reference to matrices have the form &quot;<EM CLASS="Emphasis">
name</EM>
(<EM CLASS="Emphasis">
n</EM>
, <EM CLASS="Emphasis">
m</EM>
)&quot; where <EM CLASS="Emphasis">
name</EM>
 is the name of a matrix variable in scope, <EM CLASS="Emphasis">
n</EM>
 is the row index, and <EM CLASS="Emphasis">
m</EM>
 is the column index. Index numbers start with zero, as in Java, not 1, as in Matlab.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169771"></A><A NAME="75586"></A>Records</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-167028"></A>A <A NAME="marker-167027"></A>record token is a composite type where each element is named, and each element can have a distinct type. Records are delimited by curly braces, with each element given a name. For example, &quot;<EM CLASS="Code">
{a=1, b=&quot;foo&quot;}</EM>
&quot; is a record with two elements, named &quot;a&quot; and &quot;b&quot;, with values 1 (an integer) and &quot;foo&quot; (a string), respectively. The value of a record element can be an arbitrary expression, and records can be nested (an element of a record token may be a record token).</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169775"></A>Functions</H3>
<P CLASS="Body">
<A NAME="pgfId-169189"></A>The language includes an extensible set of <A NAME="marker-169188"></A>functions, such as sin(), cos(), etc. The functions that are built in include all static methods of the java.lang.Math class and the ptolemy.data.expr.UtilityFunctions class. This can easily be extended by registering another class that includes static methods. The functions currently available are shown in figures <A HREF="usingVergil.htm#99698" CLASS="XRef">See Functions available to the expression language from the java.lang.Math class.</A> and <A HREF="usingVergil.htm#17982" CLASS="XRef">See Functions available to the expression language from the ptolemy.data.expr.UtilityFunctions class. This class is still at a preliminary stage, and the function it provides will grow over time.</A>, with the argument types and return types<A HREF="#pgfId-169470" CLASS="footnote">2</A>.</P>
<DIV>
<IMG SRC="index-25.gif">
</DIV>
<DIV>
<IMG SRC="index-26.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-167314"></A>One slightly subtle function is the <A NAME="marker-167313"></A>random() function shown in figure <A HREF="usingVergil.htm#99698" CLASS="XRef">See Functions available to the expression language from the java.lang.Math class.</A>. It takes no arguments, and hence is written &quot;<EM CLASS="Code">
random()</EM>
&quot;. It returns a random number. However, this function is evaluated only when the expression within which it appears is evaluated. The result of the expression may be used repeatedly without re-evaluating the expression. The random() function is not called again. Thus, for example, if the value parameter of the Const actor is set to &quot;<EM CLASS="Code">
random()</EM>
&quot;, then its output will be a random constant; i.e., it will not change on each firing.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169779"></A>Methods</H3>
<P CLASS="Body">
<A NAME="pgfId-167316"></A>Every element and subexpression in an expression represents an instance of the Token class in Ptolemy II (or more likely, a class derived from Token). The expression language supports invocation of any <A NAME="marker-167317"></A>method of a given token, as long as the arguments of the method are of type Token and the return type is Token (or a class derived from Token, or something that the expression parser can easily convert to a token, such as a string, double, int, etc.). The syntax for this is (<EM CLASS="Emphasis">
token</EM>
).<EM CLASS="Emphasis">
name</EM>
(<EM CLASS="Emphasis">
args</EM>
), where <EM CLASS="Emphasis">
name</EM>
 is the name of the method and <EM CLASS="Emphasis">
args</EM>
 is a comma-separated set of arguments. Each argument can itself be an expression. Note that the parentheses around the <EM CLASS="Emphasis">
token</EM>
 are not required, but might be useful for clarity. As an example, the ArrayToken class has a <A NAME="marker-167318"></A>getElement(int) method, which can be used as follows:</P>
<P CLASS="Code">
<A NAME="pgfId-167319"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-167320"></A>{1, 2, 3}.getElement(1)</P>
<P CLASS="Code">
<A NAME="pgfId-167321"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-167322"></A>This returns the integer 2. Another useful function of array token is illustrated by the following example:</P>
<P CLASS="Code">
<A NAME="pgfId-167323"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-167325"></A>{1, 2, 3}.<A NAME="marker-167324"></A>length()</P>
<P CLASS="Code">
<A NAME="pgfId-167326"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-167327"></A>which returns the integer 3.</P>
<P CLASS="Body">
<A NAME="pgfId-167329"></A>The <A NAME="marker-167328"></A>MatrixToken classes have three particularly useful methods, illustrated in the following examples:</P>
<P CLASS="Code">
<A NAME="pgfId-167330"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-167332"></A>[1, 2; 3, 4; 5, 6].<A NAME="marker-167331"></A>getRowCount()</P>
<P CLASS="Code">
<A NAME="pgfId-167333"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-167334"></A>which returns 3, and</P>
<P CLASS="Code">
<A NAME="pgfId-167335"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-167337"></A>[1, 2; 3, 4; 5, 6].<A NAME="marker-167336"></A>getColumnCount()</P>
<P CLASS="Code">
<A NAME="pgfId-167338"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-167339"></A>which returns 2, and</P>
<P CLASS="Code">
<A NAME="pgfId-167340"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-167342"></A>[1, 2; 3, 4; 5, 6].<A NAME="marker-167341"></A>toArray()</P>
<P CLASS="Code">
<A NAME="pgfId-167343"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-167344"></A>which returns {1, 2, 3, 4, 5, 6}. The latter function can be particularly useful for creating arrays using Matlab-style syntax. For example, to obtain an array with the integers from 1 to 100, you can enter:</P>
<P CLASS="Code">
<A NAME="pgfId-167345"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-167346"></A>[1:1:100].toArray()</P>
<P CLASS="Code">
<A NAME="pgfId-167347"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-167348"></A>The get() method of RecordToken accesses a record field, as in the following example:</P>
<P CLASS="Code">
<A NAME="pgfId-167349"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-167350"></A>{a=1, b=2}.get(&quot;a&quot;)</P>
<P CLASS="Code">
<A NAME="pgfId-167351"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-167352"></A>which returns 1.</P>
<P CLASS="Body">
<A NAME="pgfId-169720"></A>The Token classes from the data package form the primitives of the language. For example the number 10 becomes an IntToken with the value 10 when evaluating an expression. Normally this is invisible to the user. The expression language is object-oriented, of course, so methods can be invoked on these primitives. A sophisticated user, therefore, can make use of the fact that &quot;10&quot; is in fact an object to invoke methods of that object. </P>
<P CLASS="Body">
<A NAME="pgfId-169722"></A>In particular, the <A NAME="marker-169721"></A>convert() method of the Token class might be useful, albeit a bit subtle in how it is used. For example:</P>
<P CLASS="Code">
<A NAME="pgfId-169723"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169724"></A>double.convert(1)</P>
<P CLASS="Code">
<A NAME="pgfId-169725"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-169726"></A>creates a DoubleToken with value 1.0. The variable double is a built-in constant with type double. The convert() method of DoubleToken converts the argument to a DoubleToken, so the result of this expression is 1.0. A more peculiar way to write this is</P>
<P CLASS="Code">
<A NAME="pgfId-169727"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169728"></A>(1.2).convert(1)</P>
<P CLASS="Code">
<A NAME="pgfId-169729"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-169730"></A>Any double constant will work in place of 1.2. Its value is irrelevant.</P>
<P CLASS="Body">
<A NAME="pgfId-169734"></A>The convert() method supports only lossless type conversion. Lossy conversion has to be done explicitly via a function call.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169783"></A>Supported Types</H3>
<P CLASS="Body">
<A NAME="pgfId-167354"></A>The <A NAME="marker-167588"></A>types currently supported in the expression language are boolean, complex, fixedpoint, double, int, long, array, matrix, record, and string. Note that there is no float or byte (as yet). Use double or int instead. A <A NAME="marker-167355"></A>long is defined by appending an integer with &quot;l&quot; (lower case L) or &quot;L&quot;, as in Java. A <A NAME="marker-167356"></A>complex is defined by appending an &quot;i&quot; or a &quot;j&quot; to a double for the imaginary part. This gives a purely imaginary complex number which can then leverage the polymorphic operations in the Token classes to create a general complex number. Thus &quot;<EM CLASS="Code">
2 + 3i</EM>
&quot; will result in the expected complex number. A fixed point number is defined using the &quot;fix&quot; function, as will be explained below.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-169787"></A>Comments</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-167558"></A>In expressions, anything inside /*...*/ is ignored, so you can insert <A NAME="marker-167557"></A>comments.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-171756"></A>Fixed Point Numbers</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-171760"></A>Ptolemy II includes a preliminary <A NAME="marker-171757"></A>fixed point data type. We represent a fixed point value in the expression language using the following format: </P>
<P CLASS="Code">
<A NAME="pgfId-171766"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171768"></A><A NAME="marker-171767"></A>fix(value, integerBits, fractionBits)</P>
<P CLASS="Code">
<A NAME="pgfId-171769"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-171770"></A>Thus, a fixed point value of 5.375 that uses 8 bit precision of which 4 bits are used to represent the integer part can be represented as:</P>
<P CLASS="Code">
<A NAME="pgfId-171771"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171772"></A>fix(5.375, 8, 4)</P>
<P CLASS="Code">
<A NAME="pgfId-171773"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-171777"></A>The value can also be a matrix of doubles. The values are rounded, yielding the nearest value representable with the specified precision. If the value to represent is out of range, then it is saturated, meaning that the maximum or minimum fixed point value is returned, depending on the sign of the specified value. For example,</P>
<P CLASS="Code">
<A NAME="pgfId-171778"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171779"></A>fix(5.375, 8, 3)</P>
<P CLASS="Code">
<A NAME="pgfId-171780"></A>&nbsp;</P>
<P CLASS="LBody">
<A NAME="pgfId-171781"></A>will yield 3.968758, the maximum value possible with the (8/3) precision.</P>
<P CLASS="Body">
<A NAME="pgfId-171783"></A>In addition to the fix() function, the expression language offers a <A NAME="marker-171782"></A>quantize() function. The arguments are the same as those of the fix() function, but the return type is a DoubleToken or DoubleMatrixToken instead of a FixToken or FixMatrixToken. This function can therefore be used to quantize double-precision values without ever explicitly working with the fixed-point representation.</P>
<P CLASS="Body">
<A NAME="pgfId-171805"></A>To make the FixToken accessible within the expression language, the following functions are available: </P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-171806"></A>To create a single FixPoint Token using the expression language:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171807"></A>fix(5.34, 10, 4)</P>
<P CLASS="Indented">
<A NAME="pgfId-171808"></A>This will create a FixToken. In this case, we try to fit the number 5.34 into a 10 bit representation with 4 bits used in the integer part. This may lead to quantization errors. By default the round quantizer is used. </P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-171809"></A>To create a Matrix with FixPoint values using the expression language:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171810"></A>fix([ -.040609, -.001628, .17853 ], 10,  2) </P>
<P CLASS="Indented">
<A NAME="pgfId-171811"></A>This will create a FixMatrixToken with 1 row and 3 columns, in which each element is a FixPoint value with precision (10/2). The resulting FixMatrixToken will try to fit each element of the given double matrix into a 10 bit representation with 2 bits used for the integer part. It uses by default the round quantizer.</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-171812"></A>To create a single DoubleToken, which is the quantized version of the double value given, using the expression language:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171813"></A>quantize(5.34, 10, 4)</P>
<P CLASS="Indented">
<A NAME="pgfId-171814"></A>This will create a DoubleToken. The resulting DoubleToken contains the double value obtained by fitting the number 5.34 into a 10 bit representation with 4 bits used in the integer part. This may lead to quantization errors. By default the round quantizer is used. </P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-171815"></A>To create a Matrix with doubles quantized to a particular precision using the expression language:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171816"></A>quantize([ -.040609, -.001628, .17853 ], 10,  2) </P>
<P CLASS="Indented">
<A NAME="pgfId-171817"></A>This will create a DoubleMatrixToken with 1 row and 3 columns. The elements of the token are obtained by fitting the given matrix elements into a 10 bit representation with 2 bits used for the integer part. Instead of being a fixed point value, the values are converted back to their double representation and by default the round quantizer is used.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-166337"></A>Navigating Larger Models</H2>
<P CLASS="FirstBody">
<A NAME="pgfId-168635"></A><A NAME="marker-170132"></A>Sometimes, a model gets large enough that it is not convenient to view it all at once. There are four toolbar buttons, shown in figure <A HREF="usingVergil.htm#62758" CLASS="XRef">See Summary of toolbar buttons for zooming and fitting.</A>, that help. These buttons permit zooming in and out. The &quot;Zoom reset&quot; button restores the zoom factor to the &quot;normal&quot; one, and the &quot;Zoom fit&quot; calculates the zoom factor so that the entire model is visible in the editor window.</P>
<DIV>
<MAP NAME="index-27">
</MAP>
<IMG SRC="index-27.gif" USEMAP="#index-27">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-170131"></A>In addition, it is possible to <A NAME="marker-170133"></A>pan over a model. Consider the window shown in figure <A HREF="usingVergil.htm#52421" CLASS="XRef">See The pan window at the lower left has a red box representing the visible are of the model in the main editor window. This red box can be moved around to view different parts of the model.</A>. Here, we have zoomed in so that icons are larger than the default. The <A NAME="marker-170164"></A>pan window at the lower left shows the entire model, with a red box showing the visible portion of the model. By clicking and dragging in the pan window, it is easy to navigate around the entire model. Clicking on the &quot;Zoom fit&quot; button in the toolbar results in the editor area showing the entire model, just as the pan window does.</P>
<DIV>
<MAP NAME="index-28">
</MAP>
<IMG SRC="index-28.gif" USEMAP="#index-28">
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-168634"></A>Domains</H2>
<P CLASS="FirstBody">
<A NAME="pgfId-170167"></A>A key innovation in Ptolemy II is that, unlike other design and modeling environments, there are several available <A NAME="marker-170168"></A>models of computation that define the meaning of a diagram. In the above examples, we directed you to drag in an SDFDirector without justifying why. A <A NAME="marker-170169"></A>director in Ptolemy II gives meaning (<A NAME="marker-170170"></A>semantics) to a diagram. It specified what a connection means, and how the diagram should be executed. In Ptolemy II terminology, the director realizes a <A NAME="marker-170176"></A>domain. Thus, when you construct a model with an SDF director, you have constructed a model &quot;in the SDF domain.&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-170171"></A>The SDF director is fairly easy to understand. &quot;SDF&quot; stands for &quot;synchronous dataflow.&quot; In dataflow models, actors are invoked (<A NAME="marker-170172"></A>fired) when their input data is available. SDF is particularly simple case of dataflow where the order of invocation of the actors can be determined statically from the model. It does not depend on the data that is processed (the tokens that are passed between actors).</P>
<P CLASS="Body">
<A NAME="pgfId-170175"></A>But there are several other models of computation available in Ptolemy II. It can be difficult to determine which one to use without having experience with several. Moreover, you will find that although most actors in the library do something in any domain in which you use them, they do not always do something useful. It is important to understand the domain you are working with and the actors you are using. Here, we give a very brief introduction to some of the domains. But we begin first by explaining some of the subtleties in SDF.</P>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-168472"></A>SDF and Multirate Systems</H3>
<P CLASS="Body">
<A NAME="pgfId-166341"></A>So far we have been dealing with relatively simple systems. They are simple in the sense that each actor produces and consumes one token from each port at a time. In this case, the SDF director simply ensures that an actor fires after the actors whose output values it depends on. The number of output values that are created by each actor is determined by the number of iterations.</P>
<P CLASS="Body">
<A NAME="pgfId-166684"></A>It turns out that the <A NAME="marker-166687"></A>SDF scheduler is actually much more sophisticated. It is capable of scheduling the execution of actors with arbitrary prespecified data rates. Not all actors produce and consume just a single sample each time they are fired. Some require several input token before they can be fired, and produce several tokens when they are fired.</P>
<P CLASS="Body">
<A NAME="pgfId-166688"></A>One such actor is a spectral estimation actor. Figure <A HREF="usingVergil.htm#46190" CLASS="XRef">See A multirate SDF model. The Spectrum actor requires 256 to fire, so one iteration of this model results in 256 firings of Sinewave, Channel, and SequencePlotter, and one firing of Spectrum.</A> shows a system that computes the <A NAME="marker-166700"></A>spectrum of the same noisy sine wave that we constructed in figure <A HREF="usingVergil.htm#71815" CLASS="XRef">See A simple signal processing example that adds noise to a sinusoidal signal.</A>. The <A NAME="marker-170193"></A>Spectrum actor has a single parameter, which gives the order of the <A NAME="marker-166701"></A>FFT used to calculate the spectrum. Figure <A HREF="usingVergil.htm#25033" CLASS="XRef">See A single iteration of the SDF model in figure 2.29 produces 256 output tokens.</A> shows the output of the model with order set to 8 and the number of iterations set to 1. Note that there are 256 output samples. This is because the Spectrum actor requires 2^8, or 256 input samples to fire, and produces 2^8, or 256 output samples when it fires. Thus, one iteration of the model produces 256 samples. The Spectrum actor makes this a <A NAME="marker-170236"></A>multirate model, because the firing rates of the actors are not all identical.</P>
<DIV>
<MAP NAME="index-29">
</MAP>
<IMG SRC="index-29.gif" USEMAP="#index-29">
</DIV>
<DIV>
<MAP NAME="index-30">
</MAP>
<IMG SRC="index-30.gif" USEMAP="#index-30">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-170218"></A>It is common in SDF to construct models that require exactly one iteration to produce a useful result. In some multirate models, it can be complicated to determine how many firings of each actor occur per iteration of the model. See the SDF chapter for details.</P>
<P CLASS="Body">
<A NAME="pgfId-170224"></A>A second subtlety with SDF models is that if there is a feedback loop, as in figure <A HREF="usingVergil.htm#62878" CLASS="XRef">See A multirate SDF model. The Spectrum actor requires 256 to fire, so one iteration of this model results in 256 firings of Sinewave, Channel, and SequencePlotter, and one firing of Spectrum.</A>, then the loop must have at least one instance of the <A NAME="marker-170233"></A>SampleDelay actor in it (found in the <A NAME="marker-170234"></A>flow control library). Without this actor, the loop will <A NAME="marker-170235"></A>deadlock. The SampleDelay actor produces initial tokens on its output, before the model begins firing. The initial tokens produced are given by a parameter, which specifies an array of tokens. These initial tokens enable downstream actors and break the circular dependencies that would result otherwise from a feedback loop.</P>
<DIV>
<MAP NAME="index-31">
</MAP>
<IMG SRC="index-31.gif" USEMAP="#index-31">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-170292"></A>A final issue to consider with the SDF domain is time. Notice that in all the examples above we have suggested using the <A NAME="marker-170295"></A>SequencePlotter actor, not the <A NAME="marker-170296"></A>TimedPlotter actor, which is in the same sinks library. This is because the SDF domain does not include in its semantics a notion of time. Time does not advance as an SDF model executes, so the TimedPlotter actor would produce very uninteresting results, where the horizontal axis value would always be zero. An experimental domain, <A NAME="marker-170572"></A>discrete time (<A NAME="marker-170573"></A>DT), adds time to SDF. This turns out to be somewhat subtle for multirate systems, and this domain has not yet (as of version 2.0) reached the maturity of SDF.</P>
<P CLASS="Body">
<A NAME="pgfId-170571"></A>The SequencePlotter actor uses the index in the sequence for the horizontal axis. The first token received is plotted at horizontal position 0, the second at 1, the third at 2, etc. The next domain we consider, DE, includes much stronger notion of time, and it is almost always more appropriate in the DE domain to use the TimedPlotter actor.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-166726"></A>Discrete-Event Systems</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-170574"></A>In <A NAME="marker-170576"></A>discrete-event (<A NAME="marker-170575"></A>DE) systems, the connections between actors carry <A NAME="marker-170584"></A>signals that consist of <A NAME="marker-170583"></A>events placed on a time line. Each event has both a value and a <A NAME="marker-170579"></A>time stamp, where its time stamp is a double-precision floating-point number. This is different from dataflow, where a signal consists of a sequence of tokens, and there is no time significance in the signal.</P>
<P CLASS="Body">
<A NAME="pgfId-170587"></A>A DE model executes chronologically, processing the oldest events first. Time advances as events are processed. There is potential confusion, however, between <A NAME="marker-170588"></A>model time, the time that evolves in the model, and <A NAME="marker-170589"></A>real time, the time that elapses in the real world while the model executes (also called <A NAME="marker-170628"></A>wall-clock time). Model time may advance more rapidly than real time or more slowly. The DE director has a parameter, <A NAME="marker-170590"></A>synchronizeToRealTime, that, when set to true, attempts to synchronize the two notions of time. It does this by delaying execution of the model, if necessary, allowing real time to catch up with model time.</P>
<P CLASS="Body">
<A NAME="pgfId-170593"></A>Consider the DE model shown in figure <A HREF="usingVergil.htm#69767" CLASS="XRef">See Model time vs. real time (wall clock time).</A>. This model includes a <A NAME="marker-170629"></A>PoissonClock actor, a <A NAME="marker-170630"></A>CurrentTime actor, and a <A NAME="marker-170631"></A>WallClockTime actor, all found in the sources library. The <A NAME="marker-170633"></A>PoissonClock actor generates a sequence of events with random times, where the time between events is exponentially distributed. Such an event sequence is known as a <A NAME="marker-170637"></A>Poisson process. The value of the events produced by the <A NAME="marker-170639"></A>PoissonClock actor is a constant, but the value of that constant is ignored in this model. Instead, these events trigger the <A NAME="marker-170646"></A>CurrentTime and <A NAME="marker-170648"></A>WallClockTime actors. The first of these outputs an event with the same time stamp as the input, but whose value is the current model time (equal to the time stamp of the input). The second of these outputs an event with the same time stamp as the input, but whose value is the current real time, in seconds since initialization of the model.</P>
<DIV>
<MAP NAME="index-32">
</MAP>
<IMG SRC="index-32.gif" USEMAP="#index-32">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-170654"></A>The plot in the figure shows an execution. Note that model time has advanced approximately 10 seconds, but real time has advanced almost not at all. In this model, model time advances much more rapidly than real time. If you build this model, and set the <A NAME="marker-170655"></A>synchronizeToRealTime parameter of the director to true, then you will find that the two plots coincide almost perfectly.</P>
<P CLASS="Body">
<A NAME="pgfId-170656"></A>A significant subtlety in using the DE domain is in how <A NAME="marker-170657"></A>simultaneous events are handled. Simultaneous events are simply events with the same time stamp. We have stated that events are processed in chronological order, but if two events have the same time stamp, then there is some ambiguity. Which one should be processed first? If the two events are on the same signal, then the answer is simple: process first the one that was produced first. However, if the two events are on different signals, then the answer is not so clear.</P>
<P CLASS="Body">
<A NAME="pgfId-170730"></A>Consider the model shown in figure <A HREF="usingVergil.htm#56792" CLASS="XRef">See Histogram of interarrival times, illustrating handling of simultaneous events.</A>, which produces a <A NAME="marker-170900"></A>histogram of the <A NAME="marker-170901"></A>interarrival times of events from the <A NAME="marker-170902"></A>PoissonClock actor. In this model, we calculate the difference between the current event time and the previous event time, resulting in the plot that is shown in the figure. The <A NAME="marker-170919"></A>Previous actor is a zero-delay actor, meaning that it produces an output with the same time stamp as the input (except on the first firing, where in this case it produces no output). Thus, when the PoissonClock actor produces an output, there will be two simultaneous events, one at the input to the plus port of the AssSubtract actor, and one at the input of the Previous actor. Should the director fire the AddSubtract actor or the Previous actor? Either seems OK if it is to respect chronological order, but it seems intuitive that the Previous actor should be fired first.</P>
<DIV>
<MAP NAME="index-33">
</MAP>
<IMG SRC="index-33.gif" USEMAP="#index-33">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-170775"></A>It is helpful to know how the AddSubtract actor works. When it fires, it adds all available tokens on the plus port, and subtracts all available tokens on the minus port. If the AddSubtract actor fires before the Previous actor, then the only available token will be the one on the plus port, and the expected subtraction will not occur. Intuitively, we would expect the director to invoke the Previous actor before the AddSubtract actor so that the subtraction occurs.</P>
<P CLASS="Body">
<A NAME="pgfId-170953"></A>How does the director deliver on the intuition that the Previous actor should be fired first? Before executing the model, the DE director constructs a <A NAME="marker-170954"></A>topological sort of the model. A topological sort is simply a list of the actors in data-precedence order. For the model in figure <A HREF="usingVergil.htm#56792" CLASS="XRef">See Histogram of interarrival times, illustrating handling of simultaneous events.</A>, there is only one allowable topological sort:</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-170958"></A>PoissonClock, CurrentTime, Previous, AddSubtract, HistogramPlotter</LI>
</UL>
<P CLASS="LBody">
<A NAME="pgfId-170873"></A>In this list, AddSubtract is after Previous. So the when they have simultaneous events, the DE director fires Previous first.</P>
<P CLASS="Body">
<A NAME="pgfId-170881"></A>Thus, the DE director, by analyzing the structure of the model, usually delivers the intuitive behavior, where actors that produce data are fired before actors that consume their results, even in the presence of simultaneous events.</P>
<P CLASS="Body">
<A NAME="pgfId-170882"></A>There remains one key subtlety. If the model has a directed loop, then a topological sort is not possible. In the DE domain, every feedback loop is required to have at least one actor in it that introduces a time delay, such as the <A NAME="marker-170979"></A>TimedDelay actor, which can be found in the <A NAME="marker-170980"></A>domain specific library under discrete-event (this library is shown on the left in figure <A HREF="usingVergil.htm#46165" CLASS="XRef">See Discrete-event model with feedback, which requires a delay actor such as TimedDelay. Notice the library of domain-specific actors at the left.</A>). Consider for example the model shown in figure <A HREF="usingVergil.htm#46165" CLASS="XRef">See Discrete-event model with feedback, which requires a delay actor such as TimedDelay. Notice the library of domain-specific actors at the left.</A>. That model has a <A NAME="marker-171026"></A>Clock actor, which is set to produce events every 1.0 time units. Those events trigger the Ramp actor, which produces outputs that start at 0 and increase by 1 on each firing. In this model, the output of the Ramp goes into an AddSubtract actor, which subtracts from the Ramp output its own prior output delayed by one time unit. The result is shown in the plot in the figure.</P>
<DIV>
<MAP NAME="index-34">
</MAP>
<IMG SRC="index-34.gif" USEMAP="#index-34">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-171032"></A>Occasionally, you will need to put a TimedDelay actor in a feedback loop with a delay of 0.0. This is particularly true if you are building complex models that mix domains, and there is a delay inside a composite actor that the DE director cannot recognize as a delay. The TimedDelay actor with a delay of 0.0 can be thought of as a way to let the director know that there is a time delay in the preceding actor, without specifying the amount of the time delay.</P>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-170874"></A>Continuous-Time Systems</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-171090"></A>The <A NAME="marker-171091"></A>continuous-time domain (<A NAME="marker-171092"></A>CT) is another relatively mature domain with semantics considerably different from either DE or SDF. In CT, the signals sent along connections between actors are continuous-time signals, or in some cases, discrete-events that behave similarly to those in DE, with some restrictions. The typical application of the CT domain is to model differential equations. Consider the following set of three differential equations:</P>
<DIV>
<H4 CLASS="Equation">
<A NAME="pgfId-171067"></A><IMG SRC="index-35.gif" ALIGN="BASELINE">
&nbsp;</H4>
<P CLASS="LBody">
<A NAME="pgfId-171089"></A>There are three variables, <IMG SRC="index-36.gif" ALIGN="BASELINE">
, <IMG SRC="index-37.gif" ALIGN="BASELINE">
, and <IMG SRC="index-38.gif" ALIGN="BASELINE">
, and three constants, <IMG SRC="index-39.gif" ALIGN="BASELINE">
, <IMG SRC="index-40.gif" ALIGN="BASELINE">
, and <IMG SRC="index-41.gif" ALIGN="BASELINE">
. The variables vary continuously with time, and hence represent continuous-time signals. The notation <IMG SRC="index-42.gif" ALIGN="BASELINE">
 refers to the time derivative of <IMG SRC="index-43.gif" ALIGN="BASELINE">
.</P>
<P CLASS="Body">
<A NAME="pgfId-171152"></A>A model of these differential equations in the CT domain is shown in figure <A HREF="usingVergil.htm#83299" CLASS="XRef">See Realization of the Lorenz attractor model in the CT domain.</A>. As is customary in modeling differential equations, we use <A NAME="marker-171182"></A>integrators instead of <A NAME="marker-171183"></A>differentiators. Integrators are much more numerically robust. They are arranged in a feedback loop, so that the input to an integrator is simply the derivative of the output. Thus, the output of Integrator 1 is <IMG SRC="index-44.gif" ALIGN="BASELINE">
, and its input is <IMG SRC="index-45.gif" ALIGN="BASELINE">
. A feedback loop is used to specify the value of <IMG SRC="index-46.gif" ALIGN="BASELINE">
 in terms of <IMG SRC="index-47.gif" ALIGN="BASELINE">
, <IMG SRC="index-48.gif" ALIGN="BASELINE">
, and <IMG SRC="index-49.gif" ALIGN="BASELINE">
.</P>
<DIV>
<MAP NAME="index-50">
</MAP>
<IMG SRC="index-50.gif" USEMAP="#index-50">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-171151"></A>This set of differential equations describe a famous <A NAME="marker-171224"></A>chaotic system called a <A NAME="marker-171225"></A>Lorenz attractor. It is a special case of a family of <A NAME="marker-171226"></A>nonlinear feedback systems that exhibit <A NAME="marker-171227"></A>strange attractor behavior. The &quot;<A NAME="marker-171228"></A>attractors&quot; are the two nodes in the plot in figure <A HREF="usingVergil.htm#83299" CLASS="XRef">See Realization of the Lorenz attractor model in the CT domain.</A> that the trace seems to be alternately orbiting.</P>
<P CLASS="Body">
<A NAME="pgfId-171229"></A>The model in figure <A HREF="usingVergil.htm#83299" CLASS="XRef">See Realization of the Lorenz attractor model in the CT domain.</A> illustrates several points. First, in CT, every feedback loop must contain an integrator. Second, the <A NAME="marker-171243"></A>XYPlotter actor is used to plot <IMG SRC="index-51.gif" ALIGN="BASELINE">
 vs. <IMG SRC="index-52.gif" ALIGN="BASELINE">
. Third, three instances of the Expression actor are used instead of complex block diagrams to specify arithmetic expressions. Use of the Expression actor is explained in <A HREF="index.htm#42872" CLASS="XRef">See Expression Actor</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-171230"></A>The CT domain can also handle discrete events. These events are usually related to a continuous-time signal, for example representing a <A NAME="marker-171352"></A>zero-crossing of the continuous-time signal. The CT director is quite sophisticated in its handling of such mixed signal systems. For details, refer to the CT chapter.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM3Heading">
<A NAME="pgfId-170329"></A>FSM and Modal Models</H3>
<P CLASS="FirstBody">
<A NAME="pgfId-170308"></A>The <A NAME="marker-171363"></A>finite-state machine domain (<A NAME="marker-171364"></A>FSM) in Ptolemy II is a relatively less mature domain (but mature enough to be useful) with semantics very different from the domains covered so far. An FSM model looks different in Vergil. An example is shown in figure <A HREF="usingVergil.htm#22613" CLASS="XRef">See Finite-state machine model used in the bouncing ball example.</A>. Notice that the component library on the left and the toolbar at the top are different for this model. We will explain how to construct this model.</P>
<DIV>
<MAP NAME="index-53">
</MAP>
<IMG SRC="index-53.gif" USEMAP="#index-53">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-171389"></A>First, the FSM domain is almost always used in combination with other domains in Ptolemy II to create <A NAME="marker-171390"></A>modal models. A modal model is one that has <A NAME="marker-171393"></A>modes, which represent regimes of operation. Each mode in a modal model is represented by a <A NAME="marker-171394"></A>state in a finite-state machine. The circles in figure <A HREF="usingVergil.htm#22613" CLASS="XRef">See Finite-state machine model used in the bouncing ball example.</A> are states, and the arcs between circles are <A NAME="marker-171406"></A>transitions between states.</P>
<P CLASS="Body">
<A NAME="pgfId-171407"></A>A modal model is typically a component in a larger model. You can create a modal model by dragging one in from the utilities library. By default, it has no ports. To make it useful, you will probably need to add ports. Figure <A HREF="usingVergil.htm#29532" CLASS="XRef">See Top-level of the bouncing ball example. The Ball Model actor is an instance of modal model from the utilities library. It has been renamed.</A> shows a top-level continuous-time model with a single modal model that has been renamed Ball Model. It represents a bouncing ball. Three outputs have been added, but only the top one is used. It gives the vertical distance of the ball from the surface on which it bounces.</P>
<DIV>
<MAP NAME="index-54">
</MAP>
<IMG SRC="index-54.gif" USEMAP="#index-54">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-171433"></A>If you create a new modal model by dragging it in from the utilities library, and then look inside, you will get an FSM editor like that in figure <A HREF="usingVergil.htm#22613" CLASS="XRef">See Finite-state machine model used in the bouncing ball example.</A>, except that it will be almost blank. The only items in it will be the ports you have added. You may want to move these ports to reasonable locations.</P>
<P CLASS="Body">
<A NAME="pgfId-171440"></A>To create a finite-state machine like that in figure <A HREF="usingVergil.htm#22613" CLASS="XRef">See Finite-state machine model used in the bouncing ball example.</A>, drag in states (white circles). You can rename these states by right clicking on them and selecting &quot;Customize Name&quot;. Choose names that are pertinent to your application. In figure <A HREF="usingVergil.htm#22613" CLASS="XRef">See Finite-state machine model used in the bouncing ball example.</A>, there is an init state for initialization, a free state for when the ball is in the air, and a stop state for when the ball is no longer bouncing. You must specify the initial state of the FSM by right clicking on the background, selecting &quot;Configure&quot;, and specifying an initial state name. In this example, the initial state is init.</P>
<P CLASS="Body">
<A NAME="pgfId-171454"></A>To create <A NAME="marker-171455"></A>transitions, you must hold the control button on the keyboard while clicking and dragging from one state to the next (a transition can also go back to the same state). The handles on the transition can be used to customize its curvature and orientation. Double clicking on the transition (or right clicking and selecting &quot;Configure&quot;) allows you to configure the transition. The dialog for the transition from init to free is shown in figure <A HREF="usingVergil.htm#21684" CLASS="XRef">See Transition dialog for the transition from init to free in figure 2.36.</A>. In that dialog, we see the following:</P>
<DIV>
<MAP NAME="index-55">
</MAP>
<IMG SRC="index-55.gif" USEMAP="#index-55">
</DIV>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-171487"></A>The <A NAME="marker-171491"></A>guard expression is true, so this transition is always enabled. The transition will be taken as soon as the model begins executing. A guard expression can be any boolean-valued expression that depends on the inputs, parameters, or even the outputs of any refinement of the current state (see below). Thus, this transition is used to initialize the model.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171492"></A>The <A NAME="marker-171493"></A>output actions are empty, meaning that when this transition is taken, no output is specified. This parameter can have a list of assignments of values to output ports, separated by semicolons. Those values will be assigned to output ports when the transition is taken.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171536"></A>The <A NAME="marker-171537"></A>set actions contain the following statements:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171538"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171542"></A>free.initialPosition = initialPosition; free.initialVelocity = 0.0</P>
<P CLASS="Code">
<A NAME="pgfId-171551"></A>&nbsp;</P>
<P CLASS="Indented">
<A NAME="pgfId-171552"></A>The &quot;free&quot; in these expressions refers to the mode refinement in the &quot;free&quot; state. Thus, &quot;free.initialPosition&quot; is a parameter of that mode refinement. Here, it's value is assigned to the value of the parameter &quot;initialPosition&quot;. The parameter &quot;free.initialVelocity&quot; is set to zero.</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-171557"></A>The <A NAME="marker-171561"></A>reset parameter is set to true, meaning that the destination mode should be initialized when the transition is taken.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171562"></A>The preemptive parameter is set to false. In this case, it makes no difference, since the init state has no refinement. Normally, if a transition out of a state is enabled and preemptive is true, then the transition will be taken without first firing the refinement.</LI>
</UL>
<P CLASS="LBody">
<A NAME="pgfId-171563"></A>To create a refinement for a state, right click on the state, and select &quot;<A NAME="marker-171567"></A>Add Refinement&quot;. You will see a dialog like that in figure <A HREF="usingVergil.htm#15407" CLASS="XRef">See Dialog for creating a refinement of a state.</A>. You can specify the class name for the refinement, but for now, it is best to accept the default. Once you have created a refinement, you can look inside a state. For the bouncing ball example, the refinement of the free state is shown in figure <A HREF="usingVergil.htm#86932" CLASS="XRef">See Refinement of the free state of the modal model in figure 2.36.</A>. This model exhibits certain key properties of state refinements:</P>
<DIV>
<MAP NAME="index-56">
</MAP>
<IMG SRC="index-56.gif" USEMAP="#index-56">
</DIV>
<DIV>
<MAP NAME="index-57">
</MAP>
<IMG SRC="index-57.gif" USEMAP="#index-57">
</DIV>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-171623"></A>Refinements must contain directors. In this case, the <A NAME="CTEmbeddedDirector"></A>CTEmbeddedDirector is used. When a continuous-time model is used inside a mode, this director must be used instead of the default CTDirector (see the CT chapter for details).</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171628"></A>The refinement has the same ports as the modal model, and can read input value and specify output values. When the state machine is in the state of which this is the refinement, this model will be executed to read the inputs and produce the outputs.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171629"></A>In this case, the refinement simply defines the <A NAME="laws of gravity"></A>laws of <A NAME="gravity"></A>gravity. An acceleration of -10 m/sec2 (roughly) is integrated to get the velocity. This, in turn, is integrated to get the vertical position.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171635"></A>A <A NAME="ZeroCrossingDetector actor"></A>ZeroCrossingDetector actor is used to detect when the vertical position of the actor is zero. This results in production of an event on the (discrete) output bump. Examining figure <A HREF="usingVergil.htm#22613" CLASS="XRef">See Finite-state machine model used in the bouncing ball example.</A>, you can see that this event triggers a state transition back to the same free state, but where the initialVelocity parameter is changed to reverse the sign and attenuate it by the elasticity. This results in the ball bouncing, and losing energy.</LI>
</UL>
<P CLASS="LBody">
<A NAME="pgfId-171494"></A>As you can see from figure <A HREF="usingVergil.htm#22613" CLASS="XRef">See Finite-state machine model used in the bouncing ball example.</A>, when the position and velocity of the ball drop below a specified threshold, the state machine transitions to the state stop, which has no refinement. This results in the model producing no further output. The result of an execution is shown in figure <A HREF="usingVergil.htm#99745" CLASS="XRef">See Result of execution of the bouncing ball model.</A>. Notice that the ball bounces until it stops, after which there are no further outputs.</P>
<DIV>
<MAP NAME="index-58">
</MAP>
<IMG SRC="index-58.gif" USEMAP="#index-58">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-171675"></A>This model illustrates an interesting property of the CT domain. The stop state, it turns out, is essential. Without it, the time between bounces keeps decreasing, as does the magnitude of each bounce. At some point, these numbers get smaller than the representable precision, and large errors start to occur. Try removing the stop state from the FSM, and re-run the model. What happens? Why?</P>
<P CLASS="Body">
<A NAME="pgfId-171500"></A>Modal models can be used in any domain. Their behavior is simple. When the modal model is fired, the following sequence of events occurs:</P>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-171501"></A>The refinement of the current state, if there is one, is fired (unless preemptive is true, and one of the guards on outgoing transitions evaluates to true).</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171509"></A>The guard expressions on all the outgoing transitions are evaluated. If none are true, the firing is complete. If one is true, then that transition is taken. If more than one is true, then an exception is thrown (the FSM is nondeterministic).</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171510"></A>When a transition is taken, its output actions and set actions are evaluated.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-171511"></A>If reset is true, then the refinement of the destination mode (if there is one) is initialized.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM2Heading">
<A NAME="pgfId-168491"></A>Using the <A NAME="marker-166766"></A>Plotter</H2>
<P CLASS="FirstBody">
<A NAME="pgfId-166744"></A>Several of the plots shown above have flaws that can be fixed using the features of the plotter. For instance, the plot shown in figure <A HREF="usingVergil.htm#25033" CLASS="XRef">See A single iteration of the SDF model in figure 2.29 produces 256 output tokens.</A> has the default (uninformative) title, the axes are not labeled, and the horizontal axis ranges from 0 to 255<A HREF="#pgfId-166823" CLASS="footnote">3</A>, because in one iteration, the Spectrum actor produces 256 output tokens. These outputs represent frequency bins that range between <IMG SRC="index-59.gif" ALIGN="BASELINE">
 and <IMG SRC="index-60.gif" ALIGN="BASELINE">
 radians per second.</P>
<P CLASS="Body">
<A NAME="pgfId-166784"></A>The <A NAME="marker-166767"></A>SequencePlotter actor has some pertinent parameters, shown in figure <A HREF="usingVergil.htm#15407" CLASS="XRef">See Dialog for creating a refinement of a state.</A>. The xInit parameter specifies the value to use on the horizontal axis for the first token. The xUnit parameter specifies the value to increment this by for each subsequent token. Setting these to &quot;-PI&quot; and &quot;PI/128&quot; respectively results in the plot shown in figure <A HREF="usingVergil.htm#21802" CLASS="XRef">See Better labeled plot, where the horizontal axis now properly represents the frequency values.</A>.</P>
<DIV>
<MAP NAME="index-61">
</MAP>
<IMG SRC="index-61.gif" USEMAP="#index-61">
</DIV>
<DIV>
<MAP NAME="index-62">
</MAP>
<IMG SRC="index-62.gif" USEMAP="#index-62">
</DIV>
<P CLASS="Body">
<A NAME="pgfId-166828"></A>This plot is better, but still missing useful information. To control more precisely the visual appearance of the plot, click on the second button from the right in the row of buttons at the top right of the plot. This button brings up a format control window. It is shown in figure <A HREF="usingVergil.htm#28511" CLASS="XRef">See Format control window for a plot.</A>, filled in with values that result in the plot shown in figure <A HREF="usingVergil.htm#56406" CLASS="XRef">See Still better labeled plot.</A>. Most of these are self-explanatory, but the following pointers may be useful:</P>
<DIV>
<MAP NAME="index-63">
</MAP>
<IMG SRC="index-63.gif" USEMAP="#index-63">
</DIV>
<DIV>
<MAP NAME="index-64">
</MAP>
<IMG SRC="index-64.gif" USEMAP="#index-64">
</DIV>
<UL>
<LI CLASS="Bulleted">
<A NAME="pgfId-166883"></A>The grid is turned off to reduce clutter.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-166887"></A>Titles and axis labels have been added.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-166888"></A>The X range and Y range are determined by the fill button at the upper right of the plot.</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-166889"></A>Stem plots can be had by clicking on &quot;Stems&quot;</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-166890"></A>Individual tokens can be shown by clicking on &quot;dots&quot;</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-166891"></A>Connecting lines can be eliminated by deselecting &quot;connect&quot;</LI>
<LI CLASS="Bulleted">
<A NAME="pgfId-166892"></A>The X axis label has been changed to symbolically indicate multiples of PI/2. This is done by entering the following in the X Ticks field:</LI>
</UL>
<P CLASS="Indented">
<A NAME="pgfId-166870"></A>-PI -3.14159, -PI/2 -1.570795, 0 0.0, PI/2 1.570795, PI 3.14159</P>
<P CLASS="Indented">
<A NAME="pgfId-166896"></A>The syntax in general is:</P>
<P CLASS="Indented">
<A NAME="pgfId-166897"></A>label value, label value, ...</P>
<P CLASS="Indented">
<A NAME="pgfId-166898"></A>where the label is any string (enclosed in quotation marks if it includes spaces), and the value is a number.</P>
</DIV>
<HR>
<DIV CLASS="footnotes">
<DIV CLASS="footnote">
<P CLASS="Footnote">
<SPAN CLASS="footnoteNumber">
1.</SPAN>
<A NAME="pgfId-166915"></A>Hint: to create a <A NAME="marker-166918"></A><A NAME="marker-166919"></A>connection starting on one of the external ports, hold down the <A NAME="marker-166921"></A>control key when dragging.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="Footnote">
<SPAN CLASS="footnoteNumber">
2.</SPAN>
<A NAME="pgfId-169470"></A>At this time, in release 2.0, the types must match exactly for the expression evaluator to work. Thus, &quot;sin(1)&quot; fails, because the argument to the sin() function is required to be a double.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="Footnote">
<SPAN CLASS="footnoteNumber">
3.</SPAN>
<A NAME="pgfId-166823"></A>Hint: Notice the &quot;x102 &quot; at the bottom right, which indicates that the label &quot;2.5&quot; stands for &quot;250&quot;.</P>
</DIV>
</DIV>
</BODY>
</HTML>
