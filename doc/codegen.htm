<!-- $Id$ -->
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>Code Generation</title>
<link href="default.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Code Generation</h1>
<h2>Contents</h2>

<ul>
<li><a href="#overview">Overview</a>
<li><a href="#deep">Deep Code Generation</a>
 <ul>
 <li><a href="#deepDemo">Deep Code Generation Demonstration</a>
 <li><a href="#treeShaking">Tree Shaking</a>
 <li><a href="#gcj">GCJ</a>
 </ul>
<li><a href="#shallow">Shallow Code Generation</a>
 <ul>
 <li><a href="#shallowDemo">Shallow Code Generation Demonstration</a>
 </ul>
<li><a href="#applet">Applet Code Generation</a>
 <ul>
 <li><a href="#appletDemo">Applet Code Generation Demonstration</a>
 </ul>
<li><a href="#interpreted">Interpreted Code Generation</a>
<li><a href="#ui">The Code Generator User Interface</a>
<li><a href="#history">Code Generation History</a>
<li><a href="#soot">Soot</a>
<li><a href="#future">Future Plans</a>
<li><a href="#resources">Resources</a>
</ul>

<h2><a name="overview">Overview</a></h2>
<p>
Ptolemy II includes the very beginnings a code generation framework.
Currently, there are four types of code generators:

<dl>
<dt> <a href="#deep">deep</a>
<dd> Reads in a .xml model and generates optimized .class files that
have few dependencies on the Ptolemy II packages.

<dt> <a href="#shallow">shallow</a>
<dd> Reads in a .xml file and generates a single
unoptimized .class file that has many dependencies on the Ptolemy II
packages.

<dt> <a href="#applet">applet</a>
<dd> Reads in a .xml file and generates files suitable for
putting a model up on a web page as an applet.

<dt> <a href="#interpreted">interpreted</a>
<dd> Reads in a .xml file and writes out the .xml file.
The interpreted code generator does very little code generation
and is used primary to compare the other code generators with
the standard Ptolemy II interpreted mode that is used when
the user does <code>View</code> -&gt; <code>Run</code>.
</dl>

<p>
The implementation here should be viewed as highly preliminary.
<font color="red">It is likely to fail on all but a few simple test
cases.</font>  It is at the stage of being a concept demonstration
only.  We expect it to mature considerably in the near future.
<p>The following <a name="limitations">limitations</a>
apply to all of the code generators:
<ul>
<li> The code generators uses <a href="#soot">Soot</a> to analyze a
model and generate a set of Java .class files.  Soot will not
work with JDK1.4, it requires JDK1.3.
<pre>
Date: Mon, 13 May 2002 11:49:30 -0700
To: soot-list@sable.mcgill.ca
From: Stephen Neuendorffer &lt;neuendor@eecs.berkeley.edu&gt;
Subject: jdk1.4 problems.


See attached java file...  This uses the HashMap class.  under jdk1.4, 
there are some conflict with new java.util classes (IdentityHashMap and 
LinkedHashMap) that use private abstract inner classes...

Under soot 1.2.2:
Steve% soot --app -W test
TINI_DIR: not found
CLASSPATHSEPARATOR: not found
TINI_DIR: not found
"d:/jdk1.4/bin/java" "-Dptolemy.ptII.dir=c:/users/neuendor/ptII" 
-classpath "c:\
users\neuendor\ptII;c:/users/neuendor/ptII/lib/sootclasses.jar;c:/users/neuendor
/ptII/lib/jasminclasses.jar;d:\jdk1.4\jre\lib\rt.jar" soot.Main --app -W test
Soot started on Mon May 13 11:38:10 PDT 2002
java.lang.RuntimeException: could not resolve concrete dispatch!
Type: java.util.LinkedHashMap$LinkedHashIterator
Method: &lt;java.util.Iterator: java.lang.Object next()&gt;
         at soot.Hierarchy.resolveConcreteDispatch(Hierarchy.java:455)
         at soot.Hierarchy.resolveAbstractDispatch(Hierarchy.java:503)
         at 
 soot.jimple.toolkits.invoke.ClassHierarchyAnalysis.newInvokeGraph(Cla
ssHierarchyAnalysis.java:91)
         at 
 soot.jimple.toolkits.invoke.InvokeGraphBuilder.internalTransform(Invo
keGraphBuilder.java:47)
         at soot.SceneTransformer.transform(SceneTransformer.java:46)
         at soot.SceneTransformer.transform(SceneTransformer.java:58)
         at 
 soot.jimple.toolkits.invoke.StaticInliner.internalTransform(StaticInl
iner.java:61)
         at soot.SceneTransformer.transform(SceneTransformer.java:46)
         at soot.Pack.apply(Pack.java:79)
         at soot.Main.run(Main.java:1535)
         at java.lang.Thread.run(Thread.java:536)


Under soot 1.2.3 a different problem appears:
soot --app -W test
TINI_DIR: not found
CLASSPATHSEPARATOR: not found
TINI_DIR: not found
"d:/jdk1.4/bin/java" "-Dptolemy.ptII.dir=c:/users/neuendor/ptII" 
-classpath "c:\
users\neuendor\ptII;c:/users/neuendor/ptII/lib/sootclasses.jar;c:/users/neuendor
/ptII/lib/jasminclasses.jar;d:\jdk1.4\jre\lib\rt.jar" soot.Main --app -W test
Soot started on Mon May 13 11:24:12 PDT 2002
java.util.ConcurrentModificationException
         at soot.util.HashChain$LinkIterator.hasNext(HashChain.java:465)
         at 
 soot.jimple.toolkits.invoke.ClassHierarchyAnalysis.newInvokeGraph(Cla
ssHierarchyAnalysis.java:68)
         at 
 soot.jimple.toolkits.invoke.ClassHierarchyAnalysis.newInvokeGraph(Cla
ssHierarchyAnalysis.java:42)
         at 
 soot.jimple.toolkits.invoke.InvokeGraphBuilder.internalTransform(Invo
keGraphBuilder.java:47)
         at soot.SceneTransformer.transform(SceneTransformer.java:46)
         at soot.SceneTransformer.transform(SceneTransformer.java:58)
         at 
 soot.jimple.toolkits.invoke.StaticInliner.internalTransform(StaticInl
iner.java:61)
         at soot.SceneTransformer.transform(SceneTransformer.java:46)
         at soot.Pack.apply(Pack.java:79)
         at soot.Main.run(Main.java:1611)
         at java.lang.Thread.run(Thread.java:536)
Steve%

This test works under jdk1.3.1 with both versions of soot...

--=====================_613917086==_
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: attachment; filename="test.java"

import java.util.*;

public class test {
    public static void main(String args[]) {
        Map map = new HashMap();
        map.put(new Object(), new Integer(1));
        map.put(new Object(), new Integer(2));
        map.get(new Object());
    }
}

--=====================_613917086==_--

</pre>

<li> The primary interface to the code generator is through
the makefiles and the 
<a href="codeDoc/ptolemy/copernicus/kernel/Copernicus.html"><code>$PTII/ptolemy/copernicus/kernel/Copernicus.java</code></a> class.  The
user interface is highly preliminary, and its limitations
are discussed in
the <a href="#userInterfaceLimitations">User Interface Limitations</a>
section.
<li> The limitations for the individual code generators are 
discussed below:
  <ul>
  <li> <a href="#deepLimitations">Deep Limitations</a>
  <li> <a href="#shallowLimitations">Shallow Limitations</a>
  <li> <a href="#appletLimitations">Applet Limitations</a>
  <li> <a href="#interpretedLimitations">Interpreted Limitations</a>
  </ul>
</ul>

<h2><a name="deep">Deep Code Generation</a></h2>
Deep code generation is by the most interesting of the code generators
so we cover it first.  Stephen Neuendorffer is the primary author of
the deep code generator.

 <p>The Ptolemy II code generation system parses Ptolemy II actor
code, generates an Abstract Syntax Tree (AST), optimizes the tree
using standard and custom compiler optimization techniques and then
generates .class files that use very few of the Ptolemy II java
classes.  This approach is different from the Ptolemy Classic code
generation approach, where each actor contains target specific code.

<p>Most of the code generator uses <a href="#soot">Soot</a> to analyze a
model and generate a set of Java .class files.

<p>Our current deep code generator generates Java .class files, so the
user interface refers to the deep code generator as the
<code>java</code> code generator.  The deep code generator is
implemented in the <code>$PTII/ptolemy/copernicus/<b>java</b></code>
directory.  Other deep code generators could generate code in
different backend languages.

<p>Professor Shuvra S. Bhattacharyya of the University of Maryland is
working on C code generation for Ptolemy II Models using Soot, but
his work is still under development and not being released at this time.
For details about the status of the C code generation effort, see
the reports on the Ptolemy II website at
<a href="http://ptolemy.eecs.berkeley.edu/projects" target="_top"><code>http://ptolemy.eecs.berkeley.edu/projects</code></a>

<p><a name="deepLimitations">Deep code generation has the following
limitations:</a>
<ul>
<li> Deep code generation still requires the <code>ptolemy.math</code>
and <code>ptolemy.data</code> packages.

Our hope is to eventually implement token unboxing so that the only
the <code>ptolemy.math</code> package is required at runtime.

<li> Deep code generation only works on flat SDF models.  Composite SDF
models and domains other than SDF are not supported.

<li> Deep code generation consumes quite a bit of memory.  We usually exec
the deep code generator as a separate process with the 
<CODE>-Xmx256</CODE> java command line argument, which sets the
initial heap size to 256Mb.  Deep code generation may not work on 
a on memory-limited platforms.
 <p>Currently, in Ptolemy II, it is not possible to generate custom code 
for an individual actor using a codeblock.


<li> If you run deep code generation of a model that uses a plot,
then a plot will be displayed while the deep code generator is run.
This is because the code generator calls initialize() and the plot
actors render the plotter during initialize().


<li> The deep code generator does not handle plot configurations,
so if your model has a custom configuration for a plot, then
that information is lost. 

<li> Deep code generation does not work under Mac OSX because
the deep code generator cannot find the Java <CODE>rt.jar</CODE>

</ul>


<p><a name="deepDemo">Below is a simple demonstration:</a>
 <p>Note that codegen will not work in an applet, you must
download the Web Start version, or the Windows Installer version
or rebuild from source.
<ol>
<li> Open up the
<a href="../ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xml">SDF Orthogonal Communication Model</a>

<li> Select View -&gt; Code Generator

<li> Hit the Generate Button

<li> The code generator will invoke an separate java process that
generates code in 
<CODE>$PTII/ptolemy/copernicus/<b>java</b>/cg/OrthogonalCom</CODE>
<br>The deep code generator takes about 90 seconds to generate code.

<li> The code generators print out statistics about how long
the run took and how much memory was consumed.  A typical run will
look like:
<pre>
OrthogonalCom: Stats before execution:    0 ms. Memory: 1984K Free: 1805K (91%)
0
1
0
<i>etc.</i>
0
1
OrthogonalCom: Execution stats:           280 ms. Memory: 1984K Free: 1741K (88%)
OrthogonalCom: After Garbage Collection:  1392 ms. Memory: 1984K Free: 1804K (91%)
OrthogonalCom: construction size:         1984K - 1805K = 179K
OrthogonalCom: model alloc. while exec. : 1805K - 1804K = 1K
OrthogonalCom: model alloc. runtime data: 1804K - 1741K = 63K
280 ms. Memory: 1984K Free: 1741K (88%) Stat: 179K StatRT: 1K DynRT: 63K
All Done.
</pre>

The last line is the most significant, it indicates that the run

<ul>
 <li> took 280 milliseconds
 <li> Consumed at most 1984K of memory
 <li> Before garbage collection at the end of the run, there was
 1741K or 88% memory free.  That means that before
 garbage collection, the model consumed 243K (1984K-1741K) of memory.
 <li> The remaining three numbers are somewhat more subjective:
  <ul>
  <li> 179K of Memory was allocated during construction of the model
  <li> 1K was allocated while the model was running
  <li> 63K of data that was garbage collected.
  </ul>
</ul>
<li>To run the generated code again, click on the <code>compile</code>
radio button and turn it off, then hit the <code>Generate</code>
button.  This will show and run the generated code without rerunning
the 90 second long generator process.

</ol>

Things to note:
<ul>
<li> After a model is run, Ptolemy II prints out the amount of time
and memory the model consumed.  Usually, this output goes to standard
out, which could be hidden if Vergil was started by clicking on an
icon.  The <code>interpreted</code> code generator runs a model
in the usual Ptolemy II interpreted mode, but displays the 
runtime statistics in the code generator tableau window.  To
run the interpreted code generator:
 <ol>
 <li>Go to the code generator window and change <code>codeGenerator</code>
 to <code>interpreted</code></li>
 <li> Hit the Generate Button</li>
 </ol>
</li>

<li> Deep codegen shows a more significant improvement in speed when
the model is run for a larger number of iterations.

To increase the number of iterations in the model:
<ol>
<li>Close the code generator window and go to the
graph editor</li>
<li> Click on the green SDF Director Icon and change the number
of iterations from 20 to 2000.</li>
<li> Save the model with File -&gt; Save</li>
<li> Bring up the code generator with
View -&gt; Code Generator -&gt; Generate.</li>
<li> Run the model using the interpreted code generator</li>
by goin to the code generator window and change <code>codeGenerator</code>
 to <code>interpreted</code></li>
<li> Hit the Generate Button</li>
<li> You should see times like:
<pre>
3254 ms. Memory: 1984K Free: 1412K (71%)
OrthogonalCom: Execution stats:           5097 ms. Memory: 1984K Free: 1411K (71%)
OrthogonalCom: After Garbage Collection:  6299 ms. Memory: 1984K Free: 1519K (77%)
OrthogonalCom: construction size:         1984K - 1104K = 880K
OrthogonalCom: model alloc. while exec. : 1104K - 1519K = -415K
OrthogonalCom: model alloc. runtime data: 1519K - 1411K = 108K
5097 ms. Memory: 1984K Free: 1411K (71%) Stat: 880K StatRT: -415K DynRT: 108
</pre>
</li>
<li> Change the <code>codeGenerator</code> to <code>java</code></li>
<li> Hit the Generate Button</li>
<li> You should see statistics like
<pre>
OrthogonalCom: Execution stats:           941 ms. Memory: 1984K Free: 1494K (75%)
OrthogonalCom: After Garbage Collection:  2103 ms. Memory: 1984K Free: 1804K (91%)
OrthogonalCom: construction size:         1984K - 1805K = 179K
OrthogonalCom: model alloc. while exec. : 1805K - 1804K = 1K
OrthogonalCom: model alloc. runtime data: 1804K - 1494K = 310K
941 ms. Memory: 1984K Free: 1494K (75%) Stat: 179K StatRT: 1K DynRT: 310K
</pre>
</li>
</ol>
Comparing the run times for 2000 iterations, we can see that the
interpreted version took 5097 ms. compared with the deep code generation
version taking 941 ms, so in in this case, deep code generation was
roughly 5 times faster than the regular interpreted version.

<li> Soot produces .class files, and we can run a disassembler
convert the .class files back to .java files.  Unfortunately, there
are various reasons that the resulting .java files will not compile.
See the <a href="#disassemblers">Disassemblers</a> section for
information about disassemblers.</li>

</ul>

<h3><a name="treeShaking">Tree Shaking</a></h3>
Tree shaking is a form of optimization where a system is run
and unused code is removed.  Tree shaking is one way of
reducing the code foot print, which is especially important
in embedded applications with small amounts of memory.

<p>The deep code generator includes a prototype tree shaker that
is implemented using a shell script at
<code>$PTII/util/testsuite/treeshake</code>.
(This script requires shell utilities, so it will probably
only work when Ptolemy II was built from scratch, it is not likely
to work under Web Start.)
<p>The treeshaker runs the model using
<code>java -v</code> to generate a list of classes, creates a jar
file using those classes, and then runs the model using the new jar file.

<p>The <code>treeShakeAll</code> rule in 
<code>$PTII/ptolemy/copernicus/java/makefile</code> runs 
<code>treeshake</code>:
<ul>
<li> on the standard .xml file, which is similar to using the
<code>interpreted</code> code generator
<li> The various intermediate stages of the deep compiler
<li> The final output of the deep compiler
</ul>
At the end, the <code>treeShakeAll</code> rule prints out the sizes
of the jar files.  For the OrthogonalCom demo, the standard
interpreted run treeshakes down to a 570k jar file, and the final
output is a 283k jar file.

<p>The 283k jar file uncompresses in to about 657k of files, distributed
as follows:
<pre>
1	ptolemy/actor/lib
1	ptolemy/actor
37	ptolemy/copernicus/java/cg/OrthogonalCom
37	ptolemy/copernicus/java/cg
37	ptolemy/copernicus/java
37	ptolemy/copernicus
153	ptolemy/data/expr
90	ptolemy/data/type
399	ptolemy/data
59	ptolemy/graph
19	ptolemy/kernel/util
19	ptolemy/kernel
142	ptolemy/math
657	ptolemy
</pre>

Once we have token unboxing, we should be able to eliminate the ptolemy/data 
packages, which account for 399k of the 657k.

<p>The treeshaking script performs tree shaking on a per class basis,
where if one method from a class is reported in the <code>java -v</code>
output, then the entire class is included.

Another optimization would be to do tree shaking on a per
method basis, which would result in further reductions, especially
in the ptolemy/math package.

<h3><a name="gcj">GCJ</a></h3>

GCJ is the GNU compiler for Java.  GCJ reads in .java or .class files
and generates native code.  Building GCJ is a fairly complex task,
and as of 1/02, GCJ would not build under Cygwin because the Windows file
system is badly designed and case insensitive but case preserving.

<p>Under Solaris 8 with GCJ installed in <code>/users/ptII/vendors/gcj</code>,
we were able to build a native OrthogonalCom
executable that ran about 20% faster
than the regular deep code generation output:

<pre>
set path = ( /users/ptII/vendors/gcj/bin $path)
setenv LD_LIBRARY_PATH /users/ptII/vendors/gcj/lib:/usr/local/lib
cd $PTII/ptolemy/copernicus
make gcj
</pre>
GCJ support in Ptolemy II is extremely experimental and not likely to work.


<h2><a name="shallow">Shallow Code Generation</a></h2>

Shallow code generation converts a model that has been specified in
MoML (typically using Vergil) into a Java class definition.  This class
definition can be used in an applet, which results in faster download
times because less of the Ptolemy II infrastructure is required
to execute it. Shallow code generation uses components built into
the Ptolemy II tree.  

<p>We primarily use shallow code generation as a test bed
for the code generation facility itself.  

<p><a name="shallowDemo">Below is a simple demonstration:</a>
<ol>
<li> Open up the
<a
href="../ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xml">SDF
Orthogonal Communication Model</a>

<li> Select View -&gt; Code Generator

<li> Change the <code>CodeGenerator</code> combo box from
<code>java</code> to <code>shallow</code>
<li> Hit the Generate Button

<li> The code generator will invoke an separate java process that
generates code in 
<CODE>$PTII/ptolemy/copernicus/<b>shallow</b>/cg/OrthogonalCom</CODE>
<br>If you do not have write permission to the Ptolemy II tree, then
the generated code will end up in the directory listed in the
<code>ptIIUserDirectory</code> parameter.

</ol>

Things to note:
<ul>

<li> When the MoML version Orthogonal Communication model is run
through shallow code generation and a .class file is created, then
the .class file runs faster than the original MoML file because
the MoML parser is not invoked.  
<p>For 20 iterations, the shallow code generation print out the following:
<pre>
361 ms. Memory: 1984K Free: 1145K (58%)
</pre>
Which is almost half the 661 ms. that the interpreted version ran for
</ul>

<h3><a name="shallowLimitations">Shallow Limitations</a></h3>
The shallow code generator does not have any shallow specific limitations.


<h2><a name="applet">Applet Code Generation</a></h2>

<p>The Applet code generator takes a model and creates HTML files for 
use as a web based applet.  

<p>The applet generator uses the soot framework, though in principle a
shell script could be used instead.  The applet generator reads
template files that end in <CODE>.in</CODE> from
<CODE>$PTII/ptolemy/copernicus/applet</CODE>, substitutes keywords and
writes out the files in the destination directory.  Users may modify
the template files to match their local setup

 <p>Making an applet available via the web is somewhat complex because
the Java Plugin has two sections, one for Netscape, the other for
Internet Explorer, so changes to the htm files must be replicated in 
both sections.  The codebase and the location of the jar files also add
to the problems.

<p>If a model is named <CODE>MyModel</CODE>, and the user selects
<CODE>foo.bar</CODE> as the package, then saving the model as an
applet will create a directory called <CODE>$PTII/foo/bar/MyModel</CODE>
and create the following files for that model:
<dl>
<dt> <CODE>makefile</CODE>
<dd> <CODE>make demo</CODE> will run appletviewer on the HTML files

<dt> <CODE>MyModel.xml</CODE>
<dd> A local copy of the model

<dt> <CODE>MyModel.htm</CODE>
<dd> An HTML file containing the code necessary to <CODE>MyModel.xml</CODE>


<dt> <CODE>MyModelVergil.htm</CODE>
<dd> An HTML file containing the code necessary to
display <CODE>MyModel.xml</CODE> graphically, using ptolemy.vergil.VergilApplet and in text format

</dl>

<p><a name="appletDemo">Below is a simple demonstration:</a>
<ol>
<li> Open up the
<a
href="../ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xml">SDF
Orthogonal Communication Model</a>

<li> Select View -&gt; Code Generator

<li> Change the <code>CodeGenerator</code> combo box from
<code>java</code> to <code>applet</code>
<li> Hit the Generate Button

<li> The code generator will invoke an separate java process that
generates code in 
<CODE>$PTII/ptolemy/copernicus/<b>applet</b>/cg/OrthogonalCom</CODE>
</ol>

If you would like to generate an applet in a directory outside
of the Ptolemy tree, follow these steps:

<ol> 
<li> Open your model
<li> Select View -&gt; Code Generator
<li> Change the <code>CodeGenerator</code> combo box from
<code>java</code> to <code>applet</code>

<li> Change the <CODE>ptIIUserDirectory</CODE> to
the directory where you would like the applet to be created.
Be sure to place the directory name in double quotes:
<pre>
"d:/tmp/testapplet2"
</pre>
Note that the directory must already exist.  If it does
not exist, then the default directory will automatically
be used.

<li> Change the <CODE>targetPath</CODE> to the string
<CODE>modelName</CODE>.  Note that no double quotes are used
here.  This will 

<li> Hit the Parameters button, which will update the
parameters and display their values.

<li> Hit the Generate Button

<li> The code generator will invoke an separate java process that
generates an applet.
</ol>

See the limitations below for information about how to
handle missing classes at runtime.





<h3><a name="appletLimitations">Applet Limitations</a></h3>
<ul>

<li> Under Web Start, you may need to add classes to the
<CODE>necessaryClasses</CODE> parameter so that
the <CODE>necessaryClassPath</CODE> parameter will get
updated with the appropriate jar files and passed
to the subprocess that invokes the applet code generator.
  <br>The reason this is necessary is because Web Start
is invoked using a special class loader that
accesses separate jar files in the Web Start cache.
The applet code generator does not have direct
access to the Web Start class loader, so we tell
it what classes we need so that they can be added
to the class path.


<li>It would be nice if the applet code generator would bundle
up the necessary class files in a single jar file so that
it was easier to install an applet.
<li>The applet code generator could use tree shaking to
create a much smaller jar file that contains only the classes
that are used.  One issue is that the user would need
to exercise the applet by invoking all the features
of the GUI, such as the plot format window.

<li>The applet code generator should read the value of the
<code>_vergilSize</code> attribute and use it when generating
the <code><i>xxx</i>Model.htm</code> file.
<li>The applet code generator should grab the top level text
annotations from the MoML file and use them as comments.
<li>If the model is a FSM modal Model, then diva.jar
is not included automatically.
</ul>

<h2><a name="interpreted">Interpreted Code Generation</a></h2>
The interpreted code generator is really not a code generator.
It reads in a MoML file and writes out a MoML file, with very little
processing.  The interpreted code generator is used as to compare 
the performance of the other code generators.

<h3><a name="interpretedLimitations">Interpreted Limitations</a></h3>
The interpreted code generator does not have any interpreted specific limitations.
<p><p><p>

<h2><a name="ui">The Code Generator User Interface</a></h2>
Christopher Hylands and Professor Edward A. Lee developed an initial
draft of a graphical user interface to control code generation.  

 <p>The user interface reads its parameters from a moml file, the
 default is 
<a href="../ptolemy/copernicus/kernel/Generator.xml"><CODE>$PTII/ptolemy/copernicus/kernel/Generator.xml</CODE></a>.
This file lists the parameters, the initial default value
the documentation for the parameter.
 <p>The documentation for a parameter is viewable as a tool tip.
Try moving the mouse over the name of the parameter, a tool
tip should pop up.
 <p>There are quite a few different parameters, and parameters
can refer to each other by name.  The values of some parameters,
such as the <CODE>modelName</CODE> and <CODE>iterations</CODE>
are derived from the model itself and not actually settable.
 <p>There are several buttons:
<dl>

<dt> <CODE>More Info</CODE>
<dd> Brings up this file.

<dt> <CODE>Parameters</CODE>
<dd> Display the name of the parameter, the value, the value
the parameter evaluates to and the documentation.
<dt> <CODE>Generate</CODE>
<dd> Run the code generator.  Note that the 
<CODE>compile</CODE>, <CODE>show</CODE> and 
<CODE>run</CODE> checkboxes determine whether code is generated
shown and run.
<dt> <CODE>Cancel</CODE>
<dd> Stop a Generation that is in progress
<dt> <CODE>Clear</CODE>
<dd> Clear the output display
</dl>

<h3>How the user interface works</h3>

The code generator is controlled by a GeneratorAttribute
that contains parameters read in from the 
<I>initialParametersURL</I> parameter.  

 <p>When the user hits View -&gt; Code Generator, the model
is queried and any necessary updates to the Parameters occurs.

 <p>When the user hits the <CODE>Generate</CODE> button, the model is
again queried and any necessary updates occur.

 <p>Each of the code generators contains template files
that determine what command is actually run.
For example, the
java code generator uses
<a href="../ptolemy/copernicus/java/compileCommandTemplate.txt"><CODE>$PTII/ptolemy/copernicus/java/compileCommandTemplate.txt</CODE></a>
to determine what command to run to generate the code and
<a href="../ptolemy/copernicus/java/runCommandTemplate.txt"><CODE>$PTII/ptolemy/copernicus/java/runCommandTemplate.txt</CODE></a>
to determine what command to run the generated code.
The format of the files is fairly straightforward, parameters are
substituted in and the command is executed.

We use template files
so that the code generator can be run without requiring the
<CODE>make</CODE> program.

<h3><a name="userInterfaceLimitations">User Interface Limitations</a></h3>

Unfortunately, this UI has many design issues:
<ul>
<li> The interface is cluttered because there are many different
possible parameters to set.  It is fairly easy to make have an
interface that generates code in a default directory with default
names.  However, generating code in non-default locations requires
understanding how the parameter values affect code generation.

<li> The interface uses Ptolemy Parameters so that we can refer 
to other Parameters by name and use their values.  This means
that simple strings need to be enclosed in double quotes.

<li> It would be nice if there was an easier way to see what a
parameter evaluated to.

</ul>
 
<h2><a name="history">Code Generation History</a></h2>

<h3>Ptolemy Classic code generation</h3>

In Ptolemy Classic code generation, each separate platform had a
separate domain. This was a slight misuse of the domain
concept, since all most all of the separate platforms really had SDF
semantics, and each separate platform was really a target for the SDF
domain.  However, because of assumptions in the Ptolemy Classic
software architecture, it was easier to add new code generation
targets as separate domains.

 <p>In Ptolemy Classic, if you wanted to generate code for a new
processor, you had to create a new domain and then populate the domain
with new basic blocks that contained codeblocks of code that were
generated when the basic block was used.  This is a bit of a
simplification, but basically it meant that for each new processor,
the author had to generate a new Ramp basic block, a new Add basic
block etc.  This was very time consuming, and tended to have problems,
since if a bug was fixed in one Ramp actor, the bug needed to be fixed
in other Ramp actors in each domain.

 <p>The Adaptive Computing System (ACS) domain was an effort to work
around this issue, where the interface to each actor was shared
between multiple implementations.  This helped make it easier to
switch between different target implementations, since the ACS Ramp
actor always had the same interface, whereas if there were two Ramp
actors in two separate domains, then they might have different port
names, which made switching between the domains difficult.

 <p>More information about the ACS domain can be found in
E. K. Pauer, C. S. Myers, P. D. Fiore, J. M. Smith, C. M. Crawford, E. A. Lee, J. Lundblad and C. Hylands,
<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/98/ACSmapping/">"Algorithm Analysis and Mapping Environment for Adaptive Computing Systems,"</a>
 Presented at the Second Annual Workshop on High Performance
 Embedded Computing, MIT Labs, Lexington, MA, September, 1998. 

 <p>The ACS domain is part of Ptolemy 0.7.2devel, see
<a href="http://ptolemy.eecs.berkeley.edu/ptolemyclassic/pt0.7.2/"><CODE>http://ptolemy.eecs.berkeley.edu/ptolemyclassic/pt0.7.2/</CODE></a>


The Ptolemy Classic style of code generation was used to customize
different actors to take advantage of different features of a
processor.  For example, the Motorola 56x FIR filter actor would pick
a different codeblock depending on how the FIR filter was configured.

 <p>However, the downside of this approach is that the inter-actor
communication tended to consume quite a bit of time, so even with
really great actor implementations, we were getting performance hits
when data was passed between these actors.  It seems to us that
looking at the whole model would yield further performance
improvements.


<h3>Deep Generation History</h3>

Deep code generation parses Java component definitions, and provides
an API for accessing the abstract syntax tree.  It is possible,
in principle, to generate implementations in languages other than
Java from this AST.  Thus, we hope that in the future, we will have
code generators that produce C code for embedded processors,
or VHDL code for hardware design.
<p>
In 2000, Jeff Tsay created an initial implementation of Deep code
generation as part of his  his Masters project:
Jeff Tsay, "<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/00/codegen/" target="_top">A Code Generation Framework for Ptolemy II</a>," ERL Technical Report UCB/ERL No. M00/25, Dept. EECS, University of California, Berkeley, CA  94720, May 19, 2000.

 <p>There is a shorter summary of Jeff's work at:
 <p>Jeff Tsay, Christopher Hylands and Edward Lee, 
<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/00/javacodegen">"A Code Generation Framework for Java Component-Based Designs,"</a>
 CASES 00, November 17-19, 2000, San Jose, CA.

 <p>Jeff's work was a prototype of how we could do code generation in a
different manner, described in the above references and below.
Unfortunately, his prototype code was not easy to extend to match
changes in the Ptolemy type system.  More specfically, the type system
is Yuhong Xiong's area of research, and Jeff's work was not easy to
extend to deal with ArrayTokens.


<h2><a name="soot">Soot</a></h2>
Stephen Neuendorffer developed the framework for the current code generators 
using Soot, which is a Java optimization framework from
<a href="http://www.sable.mcgill.ca/soot/" target="_top"><CODE>http://www.sable.mcgill.ca/soot/</CODE></a> 

<p>Soot operates on class files by applying a series of transformations
that usually do compiler things like common subexpression elimination
or loop unrolling.  We can add transformations that do things like
flattening a model into one class for shallow code generation, or
further processing the AST for deep code generation.

<p>The advantage of Soot over Jeff Tsay's work is that by using soot, we
do not have to parse java files, and the name resolution of objects is
done.  In Jeff's code, we spent a lot of time trying to figure out the
fully dot qualified name of an object who's base name was 'String'.

<p>Jeff Tsay's work was a proof of concept demonstration on what
could be done.  We hope that by using Soot, we can generate a stable system
for use in a production environment.

<h3>Multiprocessors and DSP targets</h3>

Partitioning a model between multiple processors is fairly tricky, and
was a large area of research in Ptolemy Classic.  Only models with a
high degree of parallelism are amenable to running on multiple
processors.  Simply assigning each actor to a processor is not likely
to yield performance improvements, since the inter-actor communication
will really bog things down, especially on a high latency system like
a switched ethernet network.

 <p>Java can take advantage of multiple processors, so in theory, if
we use the process domains in Ptolemy II without code generation on a
multi processor machine, we should see that each Java thread will be
run on a separate processor.  However we have not done much work in
this area.  We'd like to see someone take the PN domain and work on
running it on multiple processors and seeing what sort of improvements
can be made.

 <p>In theory, once we have deep code generation, and we are creating
an AST and generating .class files, we can generate code for any
processor by either writing a new back end, or using a native Java
compiler like gcj.

<h2><a name="future">Future Plans</a></h2>
<ul>
<li> Deep code generation needs to have the tokens unboxed so
that it no longer depends on ptolemy.data
<li> Generating C code from a Ptolemy Model is in progress.
<li> We have demonstrated that the Ptolemy code generation framework can
be used to generate FGPA code using
JHDL from Brigham Young University (<a href="http://www.jhdl.org" target="_top"><code>http://www.jhdl.org</code></a>)
</ul>

<h2><a name="resources">Resources</a></h2>
Below are links to various resources:

Soot uses jasmin
<ul>
<li> <a href="http://found.cs.nyu.edu/meyer/jasmin/" target="_top">Jasmin</a> 
a Java Assembler Interface (1997)
<li> <a
href="http://www.geocrawler.com/archives/3/338/1996/8/0/1876595/" target="_top">Jasmin
emacs mode</a>
</ul>

<h3><a name="disassemblers">Disassemblers</a></h3>
Soot works with byte codes.  A Java decompiler or disassembler 
can help with debugging
<dl>
<dt> <CODE>jode</CODE>
<dd> <a href="http://jode.sourceforge.net/download.php" target="_top">http://jode.sourceforge.net/download.php</a> - Written
in Java, but full GPL, so we can't distribute it.
<CODE>$PTII/bin/configure</CODE> looks for jode in 
<CODE>$PTII/vendors/jode/1.1.1</CODE>, and if it finds it, then
<CODE>$PTII/bin/jode</CODE> can be used to invoke jode.

<ol>
<li> Download <a href="http://prdownloads.sourceforge.net/jode/jode-1.1.1.jar"><code>http://prdownloads.sourceforge.net/jode/jode-1.1.1.jar</code></a>
and save it as <CODE>$PTII/ptolemy/vendors/jode/1.1.1/jode.jar</CODE>

<li> Rerun configure:
<pre>
cd $PTII
rm config.*
./configure
</pre>

<li> Update <CODE>$PTII/bin/jode</CODE>:
<pre>
cd $PTII/bin
make

</pre>

<li> Test it out be decompiling NamedObj:
<pre>
$PTII/bin/jode ptolemy.kernel.util.NamedObj
</pre>

</ol>

 <br>For example, this command will decompile 
the Main class that is generated by the deep code generator:
<pre>
$PTII/bin/jode ptolemy.copernicus.java.cg.OrthogonalCom.Main 
</pre>

<dt> <CODE>javap</CODE>
<dd> <a href="http://java.sun.com/j2se/1.3/docs/tooldocs/solaris/javap.html" target="_top"><CODE>http://java.sun.com/j2se/1.3/docs/tooldocs/solaris/javap.html</CODE></a> - Shipped with Sun's JDK.

<dt> <code>Source Again</code>
<dd> <a href="http://www.ahpah.com/sourceagain/" target="_top"><code>http://www.ahpah.com/sourceagain/</code></a> - Commercial product

<dt> <code>WingDis</code>
<dd> <a href="http://www.wingsoft.com/wingdis.html" target="_top"><code>http://www.wingsoft.com/wingdis.html</code></a> - Commercial product

<dt> <CODE>jad</CODE>
<dd> <a href="http://www.geocities.com/SiliconValley/Bridge/8617/jad.html" target="_top"><CODE>http://www.geocities.com/SiliconValley/Bridge/8617/jad.html</CODE></a> - Jad home page - used to have binaries only, but now broken.
<br><a href="http://www.geocities.com/zz_xu/jad.html#download" target="_top"><code>http://www.geocities.com/zz_xu/jad.html#download</code></a> - Mirror site from 1999 - Jad 1.5.7
<br><a href="http://www.jproof.com/faq/MoreInfo.html" target="_top">http://www.jproof.com/faq/MoreInfo.html</a> - Jad 1.5.7

<a href="http://www.meurrens.org/ip-Links/Java/codeEngineering/jad15.html" target="_top">Mirror, though downloads do not work</a>

</dl>

Other possibilities:
<ul>
<li> <a href="http://bcel.sourceforge.net/" target="_top"><CODE>http://bcel.sourceforge.net/</CODE></a>
</ul>


<h3>Java To C converters</h3>
<dl>
<dt> Java Coffee Break Decompiler links
<dd> <a href="http://www.javacoffeebreak.com/directory/index(32).html" target="_top"><CODE>http://www.javacoffeebreak.com/directory/index(32).html</CODE></a>

<dt> GCJ - The GNU Compiler for Java
<dd> <a href="http://gcc.gnu.org/java/" target="_top"><CODE>http://gcc.gnu.org/java/</CODE></a>: JDK1.2 compliant
<BLOCKQUOTE>
<ul>
<li> Java source code directly to native machine code, 
<li> Java source code to Java bytecode (class files), 
<li>  and Java bytecode to native machine code. 
</ul>
</BLOCKQUOTE>


<dt> Jolt: Converting bytecode to C
<dd> <a href="http://www.meurrens.org/ip-Links/Java/codeEngineering/blackDown/jolt.html" target="_top"><CODE>http://www.meurrens.org/ip-Links/Java/codeEngineering/blackDown/jolt.html</CODE></a>: initial hack


<dt> Harissa
<dd> <a href="http://compose.labri.fr/prototypes/harissa" target="_top"><code>http://compose.labri.fr/prototypes/harissa</code></a>: 1999: JDK1.0.2?


<dt> Toba: A Java-to-C Translater
<dd> <a href="http://www.cs.arizona.edu/sumatra/toba/" target="_top"><CODE>http://www.cs.arizona.edu/sumatra/toba/</CODE></a>: Does not support JDK1.2

</dl>

</body>
</html>

