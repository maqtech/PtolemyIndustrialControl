<!-- $Id$ -->
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>Code Generation</title>
<link href="default.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Code Generation</h1>
<p>
Ptolemy II includes the very beginnings a code generation framework.
Currently, there are two levels of code generation, shallow and deep.
Shallow code generation converts a model that has been specified in
MoML (typically using Vergil) into a Java class definition.  This class
definition can be used in an applet, which results in faster download
times because less of the Ptolemy II infrastructure is required
to execute it. Shallow code generation uses components built into
the Ptolemy II tree.  Eventually, the process of creating an applet,
include packaging the requisite code in a jar file, will be more
automated.
<p>
Deep code generation parses the component definitions (which are
written in Java), and produces optimized code that does not require
code from the Ptolemy II tree.  Currently, this only works for some
models, and only in the SDF domain.  Also, the code generation process,
as currently implemented, requires vast amounts of memory, and thus
may not work at all on memory-limited platforms.
<p>
The implementation here should be viewed as highly preliminary.
<font color="red">It is likely to fail on all but a few simple test
cases.</font>  It is at the stage of being a concept demonstration
only.  We expect it to mature considerably in the near future.
<p>
Deep code generation parses Java component definitions, and provides
an API for accessing the abstract syntax tree.  It is possible,
in principle, to generate implementations in languages other than
Java from this AST.  Thus, we hope that in the future, we will have
code generators that produce C code for embedded processors,
or VHDL code for hardware design.
<p>
The deep code generation framework
was created by Jeff Tsay
as part of his Masters project.
(Jeff Tsay, "<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/00/codegen/" target="_top">A Code Generation Framework for Ptolemy II</a>," ERL Technical Report UCB/ERL No. M00/25, Dept. EECS, University of California, Berkeley, CA  94720, May 19, 2000.)
 <p>Shuvra Bhattacharyya created the shallow code generator.
 <p>Christopher Hylands and Edward A. Lee contributed to both code generators
 <p>See the release notes for a complete list of
<a href="ptII1.0.release.htm#CodeGenerationBugs">Code Generation Bugs</a>.
<p>

<h2>Deep Code Generation</h2>

 <p>The Ptolemy II code generation system parses Ptolemy II actor
code, generates an Abstract Syntax Tree (AST), optimizes the tree and
then generates standalone Java files.  This approach is different from
the Ptolemy Classic code generation approach, where each actor
contains target specific code.  With Ptolemy Classic, we found that
the interblock communication glue code ended up consuming a significant
portion of time, so we decided to try a different approach.

<p>The code generation facility is not complete, but it is possible
to generate Java code for SDF systems and run it.  We were able
to run simple Ptolemy II simulations on the under PalmOS by using
KVM.

<h2>Deep Code Demonstrations</h2>
<h3>Print out the AST</h3>
<pre>
cd $PTII/ptolemy/lang/java
make PrintTree
</pre>
This rule sets the CLASSPATH and then runs
<pre>
java ptolemy.lang.java.PrintTree ./nodetypes/IntLitNode.java
</pre>
and prints out the AST.

<h3>Regenerate Code</h3>
<pre>
cd $PTII/ptolemy/lang/java
make RegenerateCode
</pre>
This rule sets the CLASSPATH and then runs
<pre>
java ptolemy.lang.java.RegenerateCode ./nodetypes/IntLitNode.java
</pre>
which reads in IntLitNote.java and then regenerates code for it without
comments and whitespace

<h3>Static Semantic Analysis</h3>
<pre>
cd $PTII/ptolemy/lang/java
make analysis
</pre>
This rule sets the CLASSPATH and then runs
<pre>
java ptolemy.lang.java.Main ./nodetypes/IntLitNode.java
</pre>
which reads in IntLitNote.java and then performs static
semantic analysis, which resolves names.

<h3>SDF Code generation</h3>
<pre>
cd $PTII/ptolemy/lang/java
make codegen
</pre>
This rule sets the CLASSPATH and then reads in the Ptolemy
simulation from
<a href="../ptolemy/domains/sdf/demo/OrthogonalCom"><code>ptolemy/domains/sdf/demo/OrthogonalCom</code></a> and generates code in
<code>$PTII/cg/OrthogonalCom</code>
<pre>
java -verbose:class  ptolemy.domains.sdf.codegen.SDFCodeGenerator \
     -class  ptolemy.domains.sdf.demo.OrthogonalCom.OrthogonalComSystem \
     -iterations 50 \
     -outdir $(ROOT) -outpkg cg.OrthogonalCom
</pre>
<dl>
<dt><code>-iterations</code
<dd>Number of iterations.  If set to <code>0</code>, then run forever
<dt><code>-outdir</code
<dd>Root directory for output, usually set to $PTII
<dt><code>-outpkg</code
<dd>Package of output classes, usually set to <code>cg.<i>system</i></code>.
If <code>outdir</code> is set to <code>$PTII</code>, and
<code>outpkg</code> is set to <code>cg.OrthogonalCom</code>, then
the output classes will be created in <code>$PTII/cg/OrthogonalCom</code>

</dl>
Compile the newly created java classes with:
<pre>
cd $PTII/cg/OrthogonalCom
javac -classpath ../.. CG_Main.java
</pre>

Run the code generation classes
<pre>
cd $PTII/cg/OrthogonalCom
java -classpath ../.. cg.OrthogonalCom.CG_Main
</pre>


<h2>How Deep Code Generation Works</h2>
Code Generation parses a Java file that contains a Ptolemy II system and
then generates Java code in a separate directory.
<h3>Packages and directories</h3>
<dl>
<dt><a href="../ptolemy/lang"><code>ptolemy/codegen</code></a>
<dd> Domain independent classes that implement Tokens, Exceptions and
generate code for actors.
<dt><a href="../ptolemy/lang"><code>ptolemy/lang</code></a>
<dd>
<dt><a href="../ptolemy/lang/java"><code>ptolemy/lang/java</code></a>
<dd>
<dt><a href="../ptolemy/lang/java/extended"><code>ptolemy/lang/java/extended</code></a>
<dd>
<dt><a href="../ptolemy/lang/java/nodetypes"><code>ptolemy/lang/java/nodetypes</code></a>
<dd> The <code>.java</code> files in this directory are
generated by running <code>make run_GenerateVisitor</code>
in <code>$PTII/ptolemy/lang/java</code> which reads in
<code>$PTII/ptolemy/lang/java/NodeTypes.def</code> which reads in

<dt><a href="../ptolemy/lang/java"><code>ptolemy/lang/java/ptbyacc</code></a>
<dd> C Source code for a Ptolemy II specific version of
<a href="#ptbyacc"><code>ptbyacc</code></a>.

<dt><a href="../ptolemy/domains/sdf/codegen"><code>ptolemy/domains/sdf/codegen</code></a>
<dd> Classes used to generate Java code with SDF semantics including
SDF code generator and buffer handling.
The SDFTypeIdentifier class identifies TypedAtomicActor and SDF ports.
</dl>

<h2><a name="ptbyacc"><code>ptbyacc</code></a></h2>
<code>ptbyacc</code> is a parser generator written in C that
read in
<a href="../ptolemy/lang/java/jparser.y"><code>ptolemy/lang/java/jparser.y</code></a>,
and generates
<a href="../ptolemy/lang/java/JavaParserval.java"><code>ptolemy/lang/java/JavaParserval.java</code></a>
and the <code>.tbl</code> files in
<code>ptolemy/lang/java</code>

<p> The original <code>byacc</code> source can be found at
<a href="http://www.lincom-asg.com/~rjamison/byacc" target="_top">http://www.lincom-asg.com/~rjamison/byacc</a>.  The top of JavaParser.java contains
a list of the modifications we have made.

<p> Usually it is only necessary to build or run <code>ptbyacc</code>
if there are large scale modifications to the Java parser.  Often, one
can just modify JavaParser.java directly.

<p> When JavaParser runs, it needs to load tables that contain
the parse data.  JavaParser first looks for <code>.bin</code> files
the directory where the JavaParser class is located.  If the <code>.bin</code>
files cannot be found, then the <code>.tbl</code> files are loaded
and <code>.bin</code> files are generated.
To regenerate the <code>.bin</code> files, run
<code>make update_tables</code> in
<code>$PTII/ptolemy/lang/java</code>.
<br><bold>FIXME: make the read method static so that this is true</bold>

</body>
</html>
