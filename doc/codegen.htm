<!-- $Id$ -->
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>Code Generation</title>
<link href="default.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Code Generation</h1>
<p>
Ptolemy II includes the very beginnings a code generation framework.
Currently, there are two levels of code generation, shallow and deep.
Shallow code generation converts a model that has been specified in
MoML (typically using Vergil) into a Java class definition.  This class
definition can be used in an applet, which results in faster download
times because less of the Ptolemy II infrastructure is required
to execute it. Shallow code generation uses components built into
the Ptolemy II tree.  Eventually, the process of creating an applet,
include packaging the requisite code in a jar file, will be more
automated.
<p>
Deep code generation parses the component definitions (which are
written in Java), and produces optimized code that does not require
code from the Ptolemy II tree.  Currently, this only works for some
models, and only in the SDF domain.  Also, the code generation process,
as currently implemented, requires vast amounts of memory, and thus
may not work at all on memory-limited platforms.
<p>
The implementation here should be viewed as highly preliminary.
<font color="red">It is likely to fail on all but a few simple test
cases.</font>  It is at the stage of being a concept demonstration
only.  We expect it to mature considerably in the near future.
<p>
Deep code generation parses Java component definitions, and provides
an API for accessing the abstract syntax tree.  It is possible,
in principle, to generate implementations in languages other than
Java from this AST.  Thus, we hope that in the future, we will have
code generators that produce C code for embedded processors,
or VHDL code for hardware design.
<p>
The deep code generation framework
was created by Jeff Tsay
as part of his Masters project.
(Jeff Tsay, "<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/00/codegen/" target="_top">A Code Generation Framework for Ptolemy II</a>," ERL Technical Report UCB/ERL No. M00/25, Dept. EECS, University of California, Berkeley, CA  94720, May 19, 2000.)
 <p>Shuvra Bhattacharyya created the shallow code generator.
 <p>Christopher Hylands and Edward A. Lee contributed to both code generators
<p>

<h2>Deep Code Generation</h2>

 <p>The Ptolemy II code generation system parses Ptolemy II actor
code, generates an Abstract Syntax Tree (AST), optimizes the tree and
then generates standalone Java files.  This approach is different from
the Ptolemy Classic code generation approach, where each actor
contains target specific code.  With Ptolemy Classic, we found that
the interblock communication glue code ended up consuming a significant
portion of time, so we decided to try a different approach.

<p>The code generation facility is not complete, but it is possible
to generate Java code for SDF systems and run it.  We were able
to run simple Ptolemy II simulations on the under PalmOS by using
KVM.

<h2>Deep Code Demonstrations</h2>
<h3>Print out the AST</h3>
<pre>
cd $PTII/ptolemy/lang/java
make PrintTree
</pre>
This rule sets the CLASSPATH and then runs
<pre>
java ptolemy.lang.java.PrintTree ./nodetypes/IntLitNode.java
</pre>
and prints out the AST.

<h3>Regenerate Code</h3>
<pre>
cd $PTII/ptolemy/lang/java
make RegenerateCode
</pre>
This rule sets the CLASSPATH and then runs
<pre>
java ptolemy.lang.java.RegenerateCode ./nodetypes/IntLitNode.java
</pre>
which reads in IntLitNote.java and then regenerates code for it without
comments and whitespace

<h3>Static Semantic Analysis</h3>
<pre>
cd $PTII/ptolemy/lang/java
make analysis
</pre>
This rule sets the CLASSPATH and then runs
<pre>
java ptolemy.lang.java.Main ./nodetypes/IntLitNode.java
</pre>
which reads in IntLitNote.java and then performs static
semantic analysis, which resolves names.

<h3>SDF Code generation</h3>
<pre>
cd $PTII/ptolemy/lang/java
make codegen
</pre>
This rule sets the CLASSPATH and then reads in the Ptolemy
simulation from
<a href="../ptolemy/domains/sdf/demo/OrthogonalCom"><code>ptolemy/domains/sdf/demo/OrthogonalCom</code></a> and generates code in
<code>$PTII/cg/OrthogonalCom</code>
<pre>
java -verbose:class  ptolemy.domains.sdf.codegen.SDFCodeGenerator \
     -class  ptolemy.domains.sdf.demo.OrthogonalCom.OrthogonalComSystem \
     -iterations 50 \
     -outdir $(ROOT) -outpkg cg.OrthogonalCom
</pre>
<dl>
<dt><code>-iterations</code
<dd>Number of iterations.  If set to <code>0</code>, then run forever
<dt><code>-outdir</code
<dd>Root directory for output, usually set to $PTII
<dt><code>-outpkg</code
<dd>Package of output classes, usually set to <code>cg.<i>system</i></code>.
If <code>outdir</code> is set to <code>$PTII</code>, and
<code>outpkg</code> is set to <code>cg.OrthogonalCom</code>, then
the output classes will be created in <code>$PTII/cg/OrthogonalCom</code>

</dl>
Compile the newly created java classes with:
<pre>
cd $PTII/cg/OrthogonalCom
javac -classpath ../.. CG_Main.java
</pre>

Run the code generation classes
<pre>
cd $PTII/cg/OrthogonalCom
java -classpath ../.. cg.OrthogonalCom.CG_Main
</pre>


<h2>How Deep Code Generation Works</h2>
Code Generation parses a Java file that contains a Ptolemy II system and
then generates Java code in a separate directory.
<h3>Packages and directories</h3>
<dl>
<dt><a href="../ptolemy/lang"><code>ptolemy/codegen</code></a>
<dd> Domain independent classes that implement Tokens, Exceptions and
generate code for actors.
<dt><a href="../ptolemy/lang"><code>ptolemy/lang</code></a>
<dd>
<dt><a href="../ptolemy/lang/java"><code>ptolemy/lang/java</code></a>
<dd>
<dt><a href="../ptolemy/lang/java/extended"><code>ptolemy/lang/java/extended</code></a>
<dd>
<dt><a href="../ptolemy/lang/java/nodetypes"><code>ptolemy/lang/java/nodetypes</code></a>
<dd> The <code>.java</code> files in this directory are
generated by running <code>make run_GenerateVisitor</code>
in <code>$PTII/ptolemy/lang/java</code> which reads in
<code>$PTII/ptolemy/lang/java/NodeTypes.def</code> which reads in

<dt><a href="../ptolemy/lang/java"><code>ptolemy/lang/java/ptbyacc</code></a>
<dd> C Source code for a Ptolemy II specific version of
<a href="#ptbyacc"><code>ptbyacc</code></a>.

<dt><a href="../ptolemy/domains/sdf/codegen"><code>ptolemy/domains/sdf/codegen</code></a>
<dd> Classes used to generate Java code with SDF semantics including
SDF code generator and buffer handling.
The SDFTypeIdentifier class identifies TypedAtomicActor and SDF ports.
</dl>

<h2><a name="ptbyacc"><code>ptbyacc</code></a></h2>
<code>ptbyacc</code> is a parser generator written in C that
read in
<a href="../ptolemy/lang/java/jparser.y"><code>ptolemy/lang/java/jparser.y</code></a>,
and generates
<a href="../ptolemy/lang/java/JavaParserval.java"><code>ptolemy/lang/java/JavaParserval.java</code></a>
and the <code>.tbl</code> files in
<code>ptolemy/lang/java</code>

<p> The original <code>byacc</code> source can be found at
<a href="http://www.lincom-asg.com/~rjamison/byacc" target="_top">http://www.lincom-asg.com/~rjamison/byacc</a>.  The top of JavaParser.java contains
a list of the modifications we have made.

<p> Usually it is only necessary to build or run <code>ptbyacc</code>
if there are large scale modifications to the Java parser.  Often, one
can just modify JavaParser.java directly.

<p> When JavaParser runs, it needs to load tables that contain
the parse data.  JavaParser first looks for <code>.bin</code> files
the directory where the JavaParser class is located.  If the <code>.bin</code>
files cannot be found, then the <code>.tbl</code> files are loaded
and <code>.bin</code> files are generated.
To regenerate the <code>.bin</code> files, run
<code>make update_tables</code> in
<code>$PTII/ptolemy/lang/java</code>.
<br><bold>FIXME: make the read method static so that this is true</bold>

<h2><a name="soot">Soot</a></h2>
Another approach we are trying is to use Soot, which is a 
Java optimization framework that we hope will have a better AST.

<menu>
<li> <a href="http://www.sable.mcgill.ca/soot/" target="_top"><CODE>http://www.sable.mcgill.ca/soot/</CODE></a> 
</menu>

<p>Soot operates on class files by applying a series of transformations
that usually do compiler things like common subexpression elimination
or loop unrolling.  We can add transformations that do things like
flattening a model into one class for shallow code generation, or
further processing the AST for deep code generation.

<p>The advantage of Soot over Jeff Tsay's work is that by using soot, we
do not have to parse java files, and the name resolution of objects is
done.  In Jeff's code, we spent a lot of time trying to figure out the
fully dot qualified name of an object who's base name was 'String'.

<p>Jeff Tsay's work was a proof of concept demonstration on what
could be done.  We hope that by using Soot, we can generate a stable system
for use in a production environment.

<h3><a name="disassemblers">Disassemblers</a></h3>
Soot works with byte codes.  A Java decompiler or disassembler 
can help with debugging
<dl>
<dt> <CODE>jode</CODE>
<dd> <a href="http://jode.sourceforge.net/download.php" target="_top">http://jode.sourceforge.net/download.php</a> - Written in Java, but full GPL, so we can't distribute it.

<dt> <CODE>javap</CODE>
<dd> <a href="http://java.sun.com/j2se/1.3/docs/tooldocs/solaris/javap.html" target="_top"><CODE>http://java.sun.com/j2se/1.3/docs/tooldocs/solaris/javap.html</CODE></a> - Shipped with Sun's JDK.

<dt> <code>Source Again</code>
<dd> <a href="http://www.ahpah.com/sourceagain/" target="_top"><code>http://www.ahpah.com/sourceagain/</code></a> - Commercial product

<dt> <code>WingDis</code>
<dd> <a href="http://www.wingsoft.com/wingdis.html" target="_top"><code>http://www.wingsoft.com/wingdis.html</code></a> - Commercial product

<dt> <CODE>jad</CODE>
<dd> <a href="http://www.geocities.com/SiliconValley/Bridge/8617/jad.html" target="_top"><CODE>http://www.geocities.com/SiliconValley/Bridge/8617/jad.html</CODE></a> - Jad home page - used to have binaries only, but now broken.
<br><a href="http://www.geocities.com/zz_xu/jad.html#download" target="_top"><code>http://www.geocities.com/zz_xu/jad.html#download</code></a> - Mirror site from 1999 - Jad 1.5.7
<br><a href="http://www.jproof.com/faq/MoreInfo.html" target="_top">http://www.jproof.com/faq/MoreInfo.html</a> - Jad 1.5.7

<a href="http://www.meurrens.org/ip-Links/Java/codeEngineering/jad15.html" target="_top">Mirror, though downloads do not work</a>


</dl>

Other possibilities:
<menu>
<li> <a href="http://bcel.sourceforge.net/" target="_top"><CODE>http://bcel.sourceforge.net/</CODE></a>
</menu>

<h2>Java To C converters</h2>
<dl>
<dl>
<dt> Java Coffee Break Decompiler links
<dd> <a href="http://www.javacoffeebreak.com/directory/index(32).html" target="_top"><CODE>http://www.javacoffeebreak.com/directory/index(32).html</CODE></a>
</dl>

<dt> GCJ - The GNU Compiler for Java
<dd> <a href="http://gcc.gnu.org/java/" target="_top"><CODE>http://gcc.gnu.org/java/</CODE></a>: JDK1.2 compliant
<BLOCKQUOTE>
<menu>
<li> Java source code directly to native machine code, 
<li> Java source code to Java bytecode (class files), 
<li>  and Java bytecode to native machine code. 
</menu>
</BLOCKQUOTE>


<dt> Jolt: Converting bytecode to C
<dd> <a href="http://www.meurrens.org/ip-Links/Java/codeEngineering/blackDown/jolt.html" target="_top"><CODE>http://www.meurrens.org/ip-Links/Java/codeEngineering/blackDown/jolt.html</CODE></a>: initial hack


<dt> Harissa
<dd> <a href="http://www.irisa.fr/compose/harissa/harissa.html" target="_top"><CODE>http://www.irisa.fr/compose/harissa/harissa.html</CODE></a>: 1999: JDK1.0.2?


<dt> Toba: A Java-to-C Translater
<dd> <a href="http://www.cs.arizona.edu/sumatra/toba/" target="_top"><CODE>http://www.cs.arizona.edu/sumatra/toba/</CODE></a>: Does not support JDK1.2

<dt> JCC
<dd> <a href="http://www.geocities.com/CapeCanaveral/Hangar/4040/jcc.html" target="_top"><CODE>http://www.geocities.com/CapeCanaveral/Hangar/4040/jcc.html</CODE></a>: 1997, probably does not support JDK1.2


</dl>

<h2>Misc</h2>
<menu>
<li> <a href="http://found.cs.nyu.edu/meyer/jasmin/">Jasmin</a> 
a Java Assembler Interface (1997)
<li> <a
href="http://www.geocrawler.com/archives/3/338/1996/8/0/1876595/">Jasmin
emacs mode</a>
</menu>
</body>
</html>

