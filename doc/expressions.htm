<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="GENERATOR" content="Quadralay WebWorks Publisher Standard Edition 6.0.6">
<meta name="TEMPLATEBASE" content="Portable HTML Standard Edition">
<meta name="LASTUPDATED" content="08/04/02 14:43:44">
<title>3 Expressions</title>
</head>

<body link="#3366CC" vlink="#9999CC" text="#000000" alink="#0000CC" bgcolor="#FFFFFF"
>

<div align="center">
<h1>
  <a name="158262"> </a><font color="#003366"  >3  Expressions</font>
</h1><hr>
</div>

<a name="162678"> </a><font  >Authors:		Edward A. Lee<br></font>


<a name="169035"> </a><font  >		Xiaojun Liu<br></font>


<a name="175508"> </a><font  >		Neil Smyth<br></font>


<a name="175425"> </a><font  >		Yuhong Xiong<br></font>


<h3>
  <a name="168803"> </a><font color="#003366"  >3.1   Introduction</font>
</h3>


<p>
  <a name="175470"> </a><font  >In Ptolemy II, models specify computations by composing actors. Many computations, however, are awkward to specify this way. A common situation is where we wish to evaluate a simple algebraic expression, such as "sin(2<font  face="Symbol">p </font>(<font  ><i>x</i></font>-1))." It is possible to express this computation by composing actors in a block diagram, but it is far more convenient to give it textually.</font>
</p>


<p>
  <a name="175479"> </a><font  >The Ptolemy II expression language provides infrastructure for specifying algebraic expressions textually and for evaluating them. The expression language is used to specify the values of parameters, guards and actions in state machines, and for the calculation performed by the <font  ><i>Expression</i></font> actor. In fact, the expression language is part of the generic infrastructure in Ptolemy II, and it can be used by programmers extending the Ptolemy II system. Such extensions are described in the Data Package chapter. In this chapter, we describe how to use expressions from the perspective of a user rather than a programmer.</font>
</p>


<h3>
  <a name="175566"> </a><font color="#003366"  >3.2   Simple Arithmetic Expressions</font>
</h3>


<h4>
  <a name="175529"> </a><font color="#003366"  >3.2.1   Constants and Literals</font>
</h4>


<p>
  <a name="175531"> </a><font  >The simplest expression is a constant, which can be given either by the symbolic name of the constant, or by a literal. By default, the symbolic names of constants supported are PI, pi, E, e, true, false, i, and j. for example,</font>
</p>

<pre>
<font face="Courier New"></font><a name="175540"> </a>
<font face="Courier New">PI/2.0</font><a name="175541"> </a>
<font face="Courier New"></font><a name="175542"> </a>
</pre>

<p>
  <a name="175543"> </a><font  >is a valid expression that refers to the symbolic name "PI" and the literal "2.0." The constants i and j are complex numbers with value equal to 0.0 + 1.0i.</font>
</p>


<p>
  <a name="175682"> </a><font  >Numerical values without decimal points, such as "10" or "-3" are integers. Numerical values with decimal points, such as "10.0" or "3.14159" or "18." are doubles. Integers followed by the character "l" (el) or "L" are long integers. Integers beginning with a leading "0" are octal numbers. Integers beginning with a leading "0x" are hexadecimal numbers. For example, "012" and "0xA" are both the integer 10. In releases later than Ptolemy II 2.0.1, but not including 2.0.1 itself, integers followed by "ub" or "UB" are unsigned bytes, as in "5ub". Literal string constants are also supported. Anything between quotes, "...", is interpreted as a string constant.</font>
</p>


<p>
  <a name="175770"> </a><font  >A complex is defined by appending an "i" or a "j" to a double for the imaginary part. This gives a purely imaginary complex number which can then leverage the polymorphic operations in the Token classes to create a general complex number. Thus "<font  >2 + 3i</font>" will result in the expected complex number. You can optionally write this "<font  >2 + 3*i</font>".</font>
</p>


<h4>
  <a name="175788"> </a><font color="#003366"  >3.2.2   Summary of Supported Types</font>
</h4>


<p>
  <a name="175790"> </a><font  >The types currently supported in the expression language are <font  ><i>boolean</i></font>, <font  ><i>unsigned byte</i></font>, <font  ><i>complex</i></font>, <font  ><i>fixedpoint</i></font>, <font  ><i>double</i></font>, <font  ><i>int</i></font>, <font  ><i>long</i></font>, <font  ><i>array</i></font>, <font  ><i>matrix</i></font>, <font  ><i>record</i></font>, and <font  ><i>string</i></font>. The composite types, array, matrix, and record, are described below in section <a href="expressions.htm#175590">3.4</a>. Note that there is no float (as yet). Use double or int instead. A long is defined by appending an integer with "l" (lower case L) or "L", as in Java. A fixed point number is defined using the "fix" function, as will be explained below in section <a href="expressions.htm#171756">3.6</a>.</font>
</p>


<h4>
  <a name="175515"> </a><font color="#003366"  >3.2.3   Variables</font>
</h4>


<p>
  <a name="175517"> </a><font  >Expressions can contain references to variables within the <font  ><i>scope</i></font> of the expression. For example,</font>
</p>

<pre>
<font face="Courier New"></font><a name="175696"> </a>
<font face="Courier New">PI*x/2.0</font><a name="175697"> </a>
<font face="Courier New"></font><a name="175704"> </a>
</pre>

<p>
  <a name="175694"> </a><font  >is valid if "x" is a variable in scope. In the context of Ptolemy II models, the variables in scope include all parameters defined at the same level of the hierarchy or higher. So for example, if an actor has a parameter named "x" with value 1.0, then another parameter of the same actor can have an expression with value "<font  >PI*x/2.0</font>", which will evaluate to <font  face="Symbol">p </font>/2.</font>
</p>


<p>
  <a name="175710"> </a><font  >Consider a parameter <font  ><i>P </i></font>in actor <font  ><i>X</i></font> which is in turn contained by composite actor <font  ><i>Y</i></font>. The scope of an expression for <font  ><i>P </i></font>includes all the parameters contained by <font  ><i>X</i></font> and <font  ><i>Y</i></font>, plus those of the container of <font  ><i>Y</i></font>, its container, etc. That is, the scope includes any parameters defined above in the hierarchy.</font>
</p>


<p>
  <a name="175724"> </a><font  >You can add parameters to actors (composite or not) by right clicking on the actor, selecting "Configure" and then clicking on "Add", or by dragging in a parameter from the <font  ><i>utilities</i></font> library. Thus, you can add variables to any scope, a capability that serves the same role as the "let" construct in many programming languages.</font>
</p>


<h4>
  <a name="175554"> </a><font color="#003366"  >3.2.4   Operators</font>
</h4>


<p>
  <a name="175556"> </a><font  >The arithmetic operators are +, <font  face="Symbol">-,</font> *, /, ^, and %. Most of these operators operate on most data types, including matrices. The ^ operator computes "to the power of" where the power can only be an integer. The bitwise operators are &amp;, |, #, and ~. They operate on integers, where &amp; is bitwise and, ~ is bitwise not, and | is bitwise or, and # is bitwise exclusive or (after MATLAB). </font>
</p>


<p>
  <a name="175559"> </a><font  >The relational operators are &lt;, &lt;=, &gt;, &gt;=, <font  >==</font> and !=. They return booleans. Boolean-valued expressions can be used to give conditional values. The syntax for this is </font>
</p>

<pre>
<font face="Courier New">boolean ? value1 : value2</font><a name="175560"> </a>
</pre>

<p>
  <a name="175562"> </a><font  >If the boolean is true, the value of the expression is <font  >value1</font>; otherwise, it is <font  >value2</font>.</font>
</p>


<p>
  <a name="175732"> </a><font  >The logical boolean operators are &amp;&amp;, ||, !, &amp; and |. They operate on booleans and return booleans. The difference between logical &amp;&amp; and logical &amp; is that &amp; evaluates all the operands regardless of whether their value is now irrelevant. Similarly for logical || and |. This approach is borrowed from Java.</font>
</p>


<p>
  <a name="175563"> </a><font  >The &lt;&lt; and &gt;&gt; operators performs arithmetic left and right shifts respectively. The &gt;&gt;&gt; operator performs a logical right shift, which does not preserve the sign.</font>
</p>


<h4>
  <a name="175609"> </a><font color="#003366"  >3.2.5   Comments</font>
</h4>


<p>
  <a name="175611"> </a><font  >In expressions, anything inside<font  ><b> /*...*/</b></font> is ignored, so you can insert comments.</font>
</p>


<h3>
  <a name="175570"> </a><font color="#003366"  >3.3   Uses of Expressions</font>
</h3>


<h4>
  <a name="175574"> </a><font color="#003366"  >3.3.1   Parameters</font>
</h4>


<p>
  <a name="175578"> </a><font  >The values of most parameters of actors can be given as expressions<a href="#175811"><sup>1</sup></a>. The variables in the expression refer to other parameters that are in scope, which are those contained by the same container or some container above in the hierarchy. They can also reference variables in a <font  ><i>scope-extending attribute</i></font>, which includes variables defining units, as explained below in section <a href="expressions.htm#175821">3.7</a>. Adding parameters to actors is straightforward, as explained in the previous chapter.</font>
</p>


<h4>
  <a name="171261"> </a><font color="#003366"  >3.3.2   Expression Actor</font>
</h4>


<p>
  <a name="171267"> </a><font  >The <font  ><i>Expression</i></font> actor is a particularly useful actor found in the <font  ><i>math</i></font> library. By default, it has one output an no inputs, as shown in Figure <img src="img/expressions7.gif" height="455" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="expressions.htm#171267">3.1</a>(a). The first step in using it is to add ports, as shown in (b) and (c), resulting in a new icon as shown in (d). Note: In (c) when you click on Add, you will be prompted for a Name (pick one) and a Class. Leave the Class entry blank and click OK. You then specify an expression using the port names, as shown in (e), resulting in the icon shown in (f).</font>
</p>


<h4>
  <a name="175586"> </a><font color="#003366"  >3.3.3   State Machines</font>
</h4>


<p>
  <a name="176000"> </a><font  >Expressions give the guards for state transitions, as well as the values used in actions that produce outputs and actions that set values of parameters in the refinements of destination states. This mechanism was explained in the previous chapter.</font>
</p>


<h3>
  <a name="175590"> </a><font color="#003366"  >3.4   Composite Data Types</font>
</h3>


<h4>
  <a name="169763"> </a><font color="#003366"  >3.4.1   Arrays</font>
</h4>


<p>
  <a name="167020"> </a><font  >Arrays are specified with curly brackets, e.g., "{1, 2, 3}" is an array of integers, while "<font  >{"x", "y", "z"}</font>" is an array of strings. An array is an ordered list of tokens of any type, with the only constraint being that the elements all have the same type. Thus, for example, "{1, 2.3}" is illegal because the first element is an integer and the second is a double. The elements of the array can be given by expressions, as in the example "{2*pi, 3*pi}." Arrays can be nested; for example, "{{1, 2}, {3, 4, 5}}" is an array of arrays of integers.</font>
</p>


<h4>
  <a name="169767"> </a><font color="#003366"  >3.4.2   Matrices</font>
</h4>


<p>
  <a name="169058"> </a><font  >In Ptolemy II, arrays are ordered sets of tokens. Ptolemy II also supports matrices, which are more specialized than arrays. They contain only primitive types, currently <font  ><i>boolean</i></font>, <font  ><i>complex</i></font>, <font  ><i>double</i></font>, <font  ><i>fixedpoint</i></font>, <font  ><i>int</i></font>, and <font  ><i>long</i></font>. Matrices cannot contain arbitrary tokens, so they cannot, for example, contain matrices. They are intended for data intensive computations.</font>
</p>


<p>
  <a name="175215"> </a><font  >Matrices are specified with square brackets, using commas to separate row elements and semicolons to separate rows. E.g., "[1, 2, 3; 4, 5, 5+1]" gives a two by three integer matrix (2 rows and 3 columns). Note that an array or matrix element can be given by an expression, but all elements must have the same type, and that type must be one of the types for which matrices are defined. A row vector can be given as "[1, 2, 3]" and a column vector as "[1; 2; 3]". Some MATLAB-style array constructors are supported. For example, "[1:2:9]" gives an array of odd numbers from 1 to 9, and is equivalent to "[1, 3, 5, 7, 9]." Similarly, "[1:2:9; 2:2:10]" is equivalent to "[1, 3, 5, 7, 9; 2, 4, 6, 8, 10]." In the syntax "[<font  ><i>p</i></font>:<font  ><i>q</i></font>:<font  ><i>r</i></font>]", <font  ><i>p</i></font> is the first element, <font  ><i>q</i></font> is the step between elements, and <font  ><i>r</i></font> is an upper bound on the last element. That is, the matrix will not contain an element larger than <font  ><i>r</i></font>.</font>
</p>


<p>
  <a name="167025"> </a><font  >Reference to matrices have the form "<font  ><i>name</i></font>(<font  ><i>n</i></font>, <font  ><i>m</i></font>)" where <font  ><i>name</i></font> is the name of a matrix variable in scope, <font  ><i>n</i></font> is the row index, and <font  ><i>m</i></font> is the column index. Index numbers start with zero, as in Java, not 1, as in MATLAB.</font>
</p>


<h4>
  <a name="169771"> </a><font color="#003366"  >3.4.3   Records</font>
</h4>


<p>
  <a name="167028"> </a><font  >A record token is a composite type where each element is named, and each element can have a distinct type. Records are delimited by curly braces, with each element given a name. For example, "<font  >{a=1, b="foo"}</font>" is a record with two elements, named "a" and "b", with values 1 (an integer) and "foo" (a string), respectively. The value of a record element can be an arbitrary expression, and records can be nested (an element of a record token may be a record token).</font>
</p>


<h3>
  <a name="175594"> </a><font color="#003366"  >3.5   Functions and Methods</font>
</h3>


<h4>
  <a name="169775"> </a><font color="#003366"  >3.5.1   Functions</font>
</h4>


<p>
  <a name="169189"> </a><font  >The expression language includes an extensible set of functions, such as sin(), cos(), etc. The functions that are built in include all static methods of the java.lang.Math class and the ptolemy.data.expr.UtilityFunctions class. This can easily be extended by registering another class that includes static methods. The functions currently available are shown in Figures <img src="img/expressions5.gif" height="815" width="600" align="left" border="0" hspace="0" vspace="0">
<a href="expressions.htm#169189">3.2</a> and <img src="img/expressions6.gif" height="455" width="600" align="left" border="0" hspace="0" vspace="0">
<a href="expressions.htm#169189">3.3</a>, with the argument types and return types<a href="#169470"><sup>2</sup></a>.</font>
</p>


<p>
  <a name="167314"> </a><font  >One slightly subtle function is the random() function shown in Figure <a href="expressions.htm#169189">3.2</a>. It takes no arguments, and hence is written "<font  >random()</font>". It returns a random number. However, this function is evaluated only when the expression within which it appears is evaluated. The result of the expression may be used repeatedly without re-evaluating the expression. The random() function is not called again. Thus, for example, if the <font  ><i>value</i></font> parameter of the <font  ><i>Const</i></font> actor is set to "<font  >random()</font>", then its output will be a random constant, i.e., it will not change on each firing.</font>
</p>


<h4>
  <a name="169779"> </a><font color="#003366"  >3.5.2   Methods</font>
</h4>


<p>
  <a name="167316"> </a><font  >Every element and subexpression in an expression represents an instance of the Token class in Ptolemy II (or more likely, a class derived from Token). The expression language supports invocation of any method of a given token, as long as the arguments of the method are of type Token and the return type is Token (or a class derived from Token, or something that the expression parser can easily convert to a token, such as a string, double, int, etc.). The syntax for this is (<font  ><i>token</i></font>).<font  ><i>methodName</i></font>(<font  ><i>args</i></font>), where <font  ><i>methodName</i></font> is the name of the method and <font  ><i>args</i></font> is a comma-separated set of arguments. Each argument can itself be an expression. Note that the parentheses around the <font  ><i>token</i></font> are not required, but might be useful for clarity. As an example, the ArrayToken class has a getElement(int) method, which can be used as follows:</font>
</p>

<pre>
<font face="Courier New"></font><a name="167319"> </a>
<font face="Courier New">{1, 2, 3}.getElement(1)</font><a name="167320"> </a>
<font face="Courier New"></font><a name="167321"> </a>
</pre>

<p>
  <a name="167322"> </a><font  >This returns the integer 2. Another useful function of array token is illustrated by the following example:</font>
</p>

<pre>
<font face="Courier New"></font><a name="167323"> </a>
<font face="Courier New">{1, 2, 3}.length()</font><a name="167325"> </a>
<font face="Courier New"></font><a name="167326"> </a>
</pre>

<p>
  <a name="167327"> </a><font  >which returns the integer 3.</font>
</p>


<p>
  <a name="167329"> </a><font  >The MatrixToken classes have three particularly useful methods, illustrated in the following examples:</font>
</p>

<pre>
<font face="Courier New"></font><a name="167330"> </a>
<font face="Courier New">[1, 2; 3, 4; 5, 6].getRowCount()</font><a name="167332"> </a>
<font face="Courier New"></font><a name="167333"> </a>
</pre>

<p>
  <a name="167334"> </a><font  >which returns 3, and</font>
</p>

<pre>
<font face="Courier New"></font><a name="167335"> </a>
<font face="Courier New">[1, 2; 3, 4; 5, 6].getColumnCount()</font><a name="167337"> </a>
<font face="Courier New"></font><a name="167338"> </a>
</pre>

<p>
  <a name="167339"> </a><font  >which returns 2, and</font>
</p>

<pre>
<font face="Courier New"></font><a name="167340"> </a>
<font face="Courier New">[1, 2; 3, 4; 5, 6].toArray()</font><a name="167342"> </a>
<font face="Courier New"></font><a name="167343"> </a>
</pre>

<p>
  <a name="167344"> </a><font  >which returns {1, 2, 3, 4, 5, 6}. The latter function can be particularly useful for creating arrays using MATLAB-style syntax. For example, to obtain an array with the integers from 1 to 100, you can enter:</font>
</p>

<pre>
<font face="Courier New"></font><a name="167345"> </a>
<font face="Courier New">[1:1:100].toArray()</font><a name="167346"> </a>
<font face="Courier New"></font><a name="167347"> </a>
</pre>

<p>
  <a name="167348"> </a><font  >The get() method of RecordToken accesses a record field, as in the following example:</font>
</p>

<pre>
<font face="Courier New"></font><a name="167349"> </a>
<font face="Courier New">{a=1, b=2}.get("a")</font><a name="167350"> </a>
<font face="Courier New"></font><a name="167351"> </a>
</pre>

<p>
  <a name="167352"> </a><font  >which returns 1.</font>
</p>


<p>
  <a name="169720"> </a><font  >The Token classes from the data package form the primitives of the language. For example the number 10 becomes an IntToken with the value 10 when evaluating an expression. Normally this is invisible to the user. The expression language is object-oriented, of course, so methods can be invoked on these primitives. A sophisticated user, therefore, can make use of the fact that "10" is in fact an object to invoke methods of that object. </font>
</p>


<p>
  <a name="169722"> </a><font  >In particular, the convert() method of the Token class might be useful, albeit a bit subtle in how it is used. For example:</font>
</p>

<pre>
<font face="Courier New"></font><a name="169723"> </a>
<font face="Courier New">double.convert(1)</font><a name="169724"> </a>
<font face="Courier New"></font><a name="169725"> </a>
</pre>

<p>
  <a name="169726"> </a><font  >creates a DoubleToken with value 1.0. The variable <font  ><i>double</i></font> is a built-in constant with type double. The convert() method of DoubleToken converts the argument to a DoubleToken, so the result of this expression is 1.0. A more peculiar way to write this is</font>
</p>

<pre>
<font face="Courier New"></font><a name="169727"> </a>
<font face="Courier New">(1.2).convert(1)</font><a name="169728"> </a>
<font face="Courier New"></font><a name="169729"> </a>
</pre>

<p>
  <a name="169730"> </a><font  >Any double constant will work in place of 1.2. Its value is irrelevant.</font>
</p>


<p>
  <a name="169734"> </a><font  >The convert() method supports only lossless type conversion. Lossy conversion has to be done explicitly via a function call.</font>
</p>


<h3>
  <a name="171756"> </a><font color="#003366"  >3.6   Fixed Point Numbers</font>
</h3>


<p>
  <a name="171760"> </a><font  >Ptolemy II includes a preliminary fixed point data type. We represent a fixed point value in the expression language using the following format: </font>
</p>

<pre>
<font face="Courier New"></font><a name="171766"> </a>
<font face="Courier New">fix(value, totalBits, integerBits)</font><a name="171768"> </a>
<font face="Courier New"></font><a name="171769"> </a>
</pre>

<p>
  <a name="175209"> </a><font  >Thus, a fixed point value of 5.375 that uses 8 bit precision of which 4 bits are used to represent the integer part can be represented as:</font>
</p>

<pre>
<font face="Courier New"></font><a name="175210"> </a>
<font face="Courier New">fix(5.375, 8, 4)</font><a name="171772"> </a>
<font face="Courier New"></font><a name="171773"> </a>
</pre>

<p>
  <a name="171777"> </a><font  >The value can also be a matrix of doubles. The values are rounded, yielding the nearest value representable with the specified precision. If the value to represent is out of range, then it is saturated, meaning that the maximum or minimum fixed point value is returned, depending on the sign of the specified value. For example,</font>
</p>

<pre>
<font face="Courier New"></font><a name="171778"> </a>
<font face="Courier New">fix(5.375, 8, 3)</font><a name="171779"> </a>
<font face="Courier New"></font><a name="171780"> </a>
</pre>

<p>
  <a name="171781"> </a><font  >will yield 3.968758, the maximum value possible with the (8/3) precision.</font>
</p>


<p>
  <a name="171783"> </a><font  >In addition to the fix() function, the expression language offers a quantize() function. The arguments are the same as those of the fix() function, but the return type is a DoubleToken or DoubleMatrixToken instead of a FixToken or FixMatrixToken. This function can therefore be used to quantize double-precision values without ever explicitly working with the fixed-point representation.</font>
</p>


<p>
  <a name="171805"> </a><font  >To make the FixToken accessible within the expression language, the following functions are available: </font>
</p>

<ul>
  <font  ><li><a name="171806"> </a>To create a single FixPoint Token using the expression language:</font>
</ul>
<pre>
<font face="Courier New">fix(5.34, 10, 4)</font><a name="171807"> </a>
    <dl>
      <dt> <a name="175175"> </a><font  >This will create a FixToken. In this case, we try to fit the number 5.34 into a 10 bit representation with 4 bits used in the integer part. This may lead to quantization errors. By default the round quantizer is used. </font>
    </dl>
</pre>
<ul>
  <font  ><li><a name="175176"> </a>To create a Matrix with FixPoint values using the expression language:</font>
</ul>
<pre>
<font face="Courier New">fix([ -.040609, -.001628, .17853 ], 10,  2) </font><a name="175177"> </a>
<font face="Times New Roman">This will create a FixMatrixToken with 1 row and 3 columns, in which each element is a Fix-Point value with precision(10/2). The resulting FixMatrixToken will try to fit each element of the given double matrix into a 10 bit representation with 2 bits used for the integer part. By default the round quantizer is used.</font><a name="175181"> </a>
</pre>
<ul>
  <font  ><li><a name="175178"> </a>To create a single DoubleToken, which is the quantized version of the double value given, using the expression language:</font>
</ul>
<pre>
<font face="Courier New">quantize(5.34, 10, 4)</font><a name="171813"> </a>
    <dl>
      <dt> <a name="171814"> </a><font  >This will create a DoubleToken. The resulting DoubleToken contains the double value obtained by fitting the number 5.34 into a 10 bit representation with 4 bits used in the integer part. This may lead to quantization errors. By default the round quantizer is used. </font>
    </dl>
</pre>
<ul>
  <font  ><li><a name="171815"> </a>To create a Matrix with doubles quantized to a particular precision using the expression language:</font>
</ul>
<pre>
<font face="Courier New">quantize([ -.040609, -.001628, .17853 ], 10,  2) </font><a name="171816"> </a>
    <dl>
      <dt> <a name="171817"> </a><font  >This will create a DoubleMatrixToken with 1 row and 3 columns. The elements of the token are obtained by fitting the given matrix elements into a 10 bit representation with 2 bits used for the integer part. Instead of being a fixed point value, the values are converted back to their double representation and by default the round quantizer is used.</font>
    </dl>
</pre>

<h3>
  <a name="175821"> </a><font color="#003366"  >3.7   Units</font>
</h3>


<p>
  <a name="175825"> </a><font  >Ptolemy II supports units systems, which are built on top of the expression language. Units systems allow parameter values to be expressed with units, such as "1.0 * cm", which is equal to "0.01 * meters". These are expressed this way (with the * for multiplication) because "cm" and "meters" are actually variables that become in scope when a units system icon is dragged in to a model. A few simple units systems are provided (mainly as examples) in the utilities library.</font>
</p>


<p>
  <a name="176062"> </a><font  >A model using one of the simple provided units systems is shown in figure <img src="img/expressionsa.gif" height="330" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="expressions.htm#176062">3.4</a>. This unit system is called BasicUnits; the units it defines can be examined by double clicking on its icon, or by invoking Configure, as shown in figure <img src="img/expressions2.gif" height="382" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="expressions.htm#176062">3.5</a>. In that figure, we see that "meters", "meter", and "m" are defined, and are all synonymous. Moreover, "cm" is defined, and given value "0.01*meters", and "in", "inch" and "inches" are defined, all with value "2.54*cm".</font>
</p>


<p>
  <a name="176135"> </a><font  >In the example in figure <a href="expressions.htm#176062">3.4</a>, a constant with value "1.0 * meter" is fed into a Scale actor with scale factor equal to "2.0/ms". This produces a result with dimensions of length over time. If we feed this result directly into a Display actor, then it is displayed as "2000.0 meters/seconds", as shown in figure <img src="img/expressions4.gif" usemap="#expressions4_gif" height="264" width="600" align="center" border="0" hspace="0" vspace="0">
<map name="expressions4_gif">

<area href="expressions.htm#176062" shape=rect coords="1,238,598,263">
</map>
<a href="expressions.htm#176135">3.6</a>, top display. The canonical units for length are meters, and for time are seconds.</font>
</p>


<p>
  <a name="176145"> </a><font  >In figure <a href="expressions.htm#176062">3.4</a>, we also take the result and feed it to the <font  ><i>InUnitsOf</i></font> actor, which performs divides its input by its argument, and checks to make sure that the result is unitless. This tells us that 2 meters/ms is equal to about 78,740 inches/second.</font>
</p>


<p>
  <a name="176157"> </a><font  >The <font  ><i>InUnitsOf</i></font> actor can be used to ensure that numbers are interpreted correctly in a model, which can be effective in catching certain kinds of critical errors. For example, if in figure <a href="expressions.htm#176062">3.4</a> we had entered "seconds/inch" instead of "inches/second" in the InUnitsOf actor, we would have gotten the exception in figure <img src="img/expressions3.gif" height="184" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="expressions.htm#176157">3.7</a> instead of the execution in figure <a href="expressions.htm#176135">3.6</a>.</font>
</p>


<p>
  <a name="176191"> </a><font  >Units systems are built entirely on the expression language infrastructure in Ptolemy II. The units system icons actually represent instances of <font  ><i>scope-extending attributes</i></font>, which are attributes whose parameters are in scope as if those parameters were directly contained by the container of the scope-extending attribute. That is, scope-extending attributes can define a collection of variables and constants that can be manipulated as a unit. In version 2.0 of Ptolemy II, two fairly extensive units systems are provided, CGSUnitBase and ElectronicUnitBase. Nonetheless, these are intended as examples only, and can no doubt be significantly improved and extended.</font>
</p>


  
<a name="175811"> </a><font  ><a href="#175578"><sup>1</sup></a>
<a name="175811"> </a><font  ><font  >The exceptions are parameters that are strictly string parameters, in which case the value of the parameter is the literal string, not the string interpreted as an expression, as for example the </font><font  ><i>function</i></font><font  > parameter of the </font><font  ><i>TrigFunction</i></font><font  > actor, which can take on only "sin," "cos," "tan", "asin", "acos", and "atan" as values.</font><br></font>

<br></font>


<a name="169470"> </a><font  ><a href="#169189"><sup>2</sup></a>
<a name="169470"> </a><font  >At this time, in release 2.0, the types must match exactly for the expression evaluator to work. Thus, "sin(1)" fails, because the argument to the sin() function is required to be a double.<br></font>

<br></font>

</body>
</html>
