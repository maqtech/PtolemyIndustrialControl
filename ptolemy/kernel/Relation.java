/* Generated By:JavaScope: Do not edit this line. Relation.java */
/* A Relation links ports, and therefore the entities that contain them.

 Copyright (c) 1997-2001 The Regents of the University of California.
 All rights reserved.
 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the above
 copyright notice and the following two paragraphs appear in all copies
 of this software.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.

                                        PT_COPYRIGHT_VERSION_2
                                        COPYRIGHTENDKEY

@ProposedRating Green (eal@eecs.berkeley.edu)
@AcceptedRating Green (johnr@eecs.berkeley.edu)
*/

package ptolemy.kernel;

import ptolemy.kernel.util.CrossRefList;
import ptolemy.kernel.util.IllegalActionException;
import ptolemy.kernel.util.InternalErrorException;
import ptolemy.kernel.util.NamedObj;
import ptolemy.kernel.util.Workspace;

import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List; import COM.sun.suntest.javascope.database.js$;import COM.sun.suntest.javascope.database.CoverageUnit; 

//////////////////////////////////////////////////////////////////////////
//// Relation
/**
A Relation links ports, and therefore the entities that contain them.
To link a port to a relation, use the link() method
in the Port class.  To remove a link, use the unlink() method in the
Port class.
<p>
Derived classes may wish to disallow links under certain circumstances,
for example if the proposed port is not an instance of an appropriate
subclass of Port, or if the relation cannot support any more links.
Such derived classes should override the protected method _checkPort()
to throw an exception.

@author Edward A. Lee, Neil Smyth
@version $Id$
@see Port
@see Entity
*/
public class Relation extends NamedObj { static private int js$t0 = js$.setDatabase("/home/eecs/cxh/jsdatabase");static private String[] js$p={"ptolemy","kernel",};static private CoverageUnit js$c=js$.c(js$p,"Relation","/export/maury/maury2/cxh/tmp/ptII/ptolemy/kernel/jsoriginal/Relation.java",976122022828L,js$n());  static final int[] js$a = js$c.counters; 

    /** Construct a relation in the default workspace with an empty string
     *  as its name. Increment the version number of the workspace.
     *  The object is added to the workspace directory.
     */
    public Relation() {
	super(); try{  js$.g(Relation.js$a,2); 
         js$.g(Relation.js$a,0);/*$js$*/ getMoMLInfo().elementName = "relation";
        try {
            _portList = new CrossRefList(this);
        } catch (IllegalActionException ex) { js$.g(Relation.js$a,3); 
            // Should not be thrown because "this" cannot be null.
             js$.g(Relation.js$a,1);/*$js$*/ throw new InternalErrorException(
                    "Internal error in Relation constructor!"
                    + ex.getMessage());
        } }finally{js$.flush(Relation.js$c);} 
    }

    /** Construct a relation in the default workspace with the given name.
     *  If the name argument is null, then the name is set to the empty string.
     *  Increment the version number of the workspace.
     *  The object is added to the workspace directory.
     *  @param name Name of this object.
     *  @exception IllegalActionException If the name has a period.
     */
    public Relation(String name) throws IllegalActionException {
	super(name); try{  js$.g(Relation.js$a,6); 
         js$.g(Relation.js$a,4);/*$js$*/ getMoMLInfo().elementName = "relation";
        try {
            _portList = new CrossRefList(this);
        } catch (IllegalActionException ex) { js$.g(Relation.js$a,7); 
            // Should not be thrown because "this" cannot be null.
             js$.g(Relation.js$a,5);/*$js$*/ throw new InternalErrorException(
                    "Internal error in Relation constructor!"
                    + ex.getMessage());
        } }finally{js$.flush(Relation.js$c);} 
    }

    /** Construct a relation in the given workspace with an empty string
     *  as a name.
     *  If the workspace argument is null, use the default workspace.
     *  The object is added to the workspace directory.
     *  Increment the version of the workspace.
     *  @param workspace The workspace for synchronization and version tracking.
     */
    public Relation(Workspace workspace) {
	super(workspace); try{  js$.g(Relation.js$a,10); 
         js$.g(Relation.js$a,8);/*$js$*/ getMoMLInfo().elementName = "relation";
        try {
            _portList = new CrossRefList(this);
        } catch (IllegalActionException ex) { js$.g(Relation.js$a,11); 
            // Should not be thrown because "this" cannot be null.
             js$.g(Relation.js$a,9);/*$js$*/ throw new InternalErrorException(
                    "Internal error in Relation constructor!");
        } }finally{js$.flush(Relation.js$c);} 
    }

    /** Construct a relation in the given workspace with the given name.
     *  If the workspace argument is null, use the default workspace.
     *  If the name argument is null, then the name is set to the empty string.
     *  The object is added to the workspace directory.
     *  Increment the version of the workspace.
     *  @param workspace Workspace for synchronization and version tracking
     *  @param name Name of this object.
     *  @exception IllegalActionException If the name has a period.
     */
    public Relation(Workspace workspace, String name)
            throws IllegalActionException {
	super(workspace, name); try{  js$.g(Relation.js$a,14); 
         js$.g(Relation.js$a,12);/*$js$*/ getMoMLInfo().elementName = "relation";
        try {
            _portList = new CrossRefList(this);
        } catch (IllegalActionException ex) { js$.g(Relation.js$a,15); 
            // Should not be thrown because "this" cannot be null.
             js$.g(Relation.js$a,13);/*$js$*/ throw new InternalErrorException(
                    "Internal error in Relation constructor!");
        } }finally{js$.flush(Relation.js$c);} 
    }

    ///////////////////////////////////////////////////////////////////
    ////                         public methods                    ////

    /** Clone the object into the specified workspace. The new object is
     *  <i>not</i> added to the directory of that workspace (you must do this
     *  yourself if you want it there).
     *  The result is a new relation with no links and no container.
     *  @param workspace The workspace for the cloned object.
     *  @exception CloneNotSupportedException If one of the attributes cannot
     *   be cloned.
     *  @return A new Relation.
     */
    public Object clone(Workspace workspace)
            throws CloneNotSupportedException {try  { js$.g(Relation.js$a,19); 
         js$.g(Relation.js$a,16);/*$js$*/ Relation newObject = (Relation)super.clone(workspace);
        try {
            newObject._portList = new CrossRefList(newObject);
        } catch (IllegalActionException ex) { js$.g(Relation.js$a,20); 
            // This should not be thrown because newObject is not null.
             js$.g(Relation.js$a,17);/*$js$*/ throw new InternalErrorException(
                    "Internal error in Port clone() method!"
                    + ex.getMessage());
        }
         js$.g(Relation.js$a,18);/*$js$*/ return newObject;
    } finally{js$.flush(Relation.js$c);}} 

    /** List the linked ports.  Note that a port may appear more than
     *  once if more than one link to it has been established.
     *  This method is read-synchronized on the workspace.
     *  @return A list of Port objects.
     */
    public List linkedPortList() {try  { js$.g(Relation.js$a,25); 
         js$.g(Relation.js$a,21);/*$js$*/ try {
            _workspace.getReadAccess();
            // Unfortunately, CrossRefList returns an enumeration only.
            // Use it to construct a list.
            LinkedList result = new LinkedList();
            Enumeration ports = _portList.getContainers();
            while ( ((( ports.hasMoreElements() ) && ++Relation.js$a[26] != 0) || ++Relation.js$a[27] == 0) ) {
                 js$.g(Relation.js$a,22);/*$js$*/ result.add(ports.nextElement());
            }
             js$.g(Relation.js$a,23);/*$js$*/ return result;
        } finally {
             js$.g(Relation.js$a,24);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(Relation.js$c);}} 

    /** List the linked ports except the specified port.
     *  Note that a port may appear more than
     *  once if more than on link to it has been established.
     *  This method is read-synchronized on the workspace.
     *  @param except Port to exclude from the enumeration.
     *  @return A list of Port objects.
     */
    public List linkedPortList(Port except) {try  { js$.g(Relation.js$a,33); 
        // This works by constructing a linked list and then returning it.
         js$.g(Relation.js$a,28);/*$js$*/ try {
            _workspace.getReadAccess();
            LinkedList storedPorts = new LinkedList();
            Enumeration ports = _portList.getContainers();

            while( ((( ports.hasMoreElements() ) && ++Relation.js$a[34] != 0) || ++Relation.js$a[35] == 0) ) {
                 js$.g(Relation.js$a,29);/*$js$*/ Port p = (Port)ports.nextElement();
                if( ((( p != except ) && ++Relation.js$a[36] != 0) || ++Relation.js$a[37] == 0) ) {   js$.g(Relation.js$a,30);/*$js$*/ storedPorts.add(p); } 
            }
             js$.g(Relation.js$a,31);/*$js$*/ return storedPorts;
        } finally {
             js$.g(Relation.js$a,32);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(Relation.js$c);}} 

    /** Enumerate the linked ports.  Note that a port may appear more than
     *  once if more than one link to it has been established.
     *  This method is read-synchronized on the workspace.
     *  @return An Enumeration of Port objects.
     */
    public Enumeration linkedPorts() {try  { js$.g(Relation.js$a,40); 
        // NOTE: There is no reason to deprecate this because it does not
        // depend on Doug Lea's collections, and it is more efficient than
        // the list version.
         js$.g(Relation.js$a,38);/*$js$*/ try {
            _workspace.getReadAccess();
            return _portList.getContainers();
        } finally {
             js$.g(Relation.js$a,39);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(Relation.js$c);}} 

    /** Enumerate the linked ports except the specified port.
     *  Note that a port may appear more than
     *  once if more than on link to it has been established.
     *  This method is read-synchronized on the workspace.
     *  @param except Port to exclude from the enumeration.
     *  @return An Enumeration of Port objects.
     *  @deprecated Use linkedPortList() instead.
     */
    public Enumeration linkedPorts(Port except) {try  { js$.g(Relation.js$a,42); 
         js$.g(Relation.js$a,41);/*$js$*/ return Collections.enumeration(linkedPortList(except));
    } finally{js$.flush(Relation.js$c);}} 

    /** Return the number of links to ports.
     *  This method is read-synchronized on the workspace.
     *  @return The number of links.
     */
    public int numLinks() {try  { js$.g(Relation.js$a,45); 
         js$.g(Relation.js$a,43);/*$js$*/ try {
            _workspace.getReadAccess();
            return _portList.size();
        } finally {
             js$.g(Relation.js$a,44);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(Relation.js$c);}} 

    /** Unlink all ports.
     *  This method is write-synchronized on the workspace and increments
     *  its version number.
     */
    public void unlinkAll() {try  { js$.g(Relation.js$a,50); 
         js$.g(Relation.js$a,46);/*$js$*/ try {
            _workspace.getWriteAccess();
            // NOTE: Do not just use _portList.unlinkAll() because then the
            // containers of the ports are not notified of the change.
            // Also, have to first copy the ports references, then remove
            // them, to avoid a corrupted enumeration exception.
            int size = _portList.size();
            Port portArray[] = new Port[size];
            int i = 0;
            Enumeration ports = _portList.getContainers();
            while( ((( ports.hasMoreElements() ) && ++Relation.js$a[51] != 0) || ++Relation.js$a[52] == 0) ) {
                 js$.g(Relation.js$a,47);/*$js$*/ Port p = (Port)ports.nextElement();
                portArray[i++] = p;
            }
            for (i = 0; (((  i < size ) && ++Relation.js$a[53] != 0) || ++Relation.js$a[54] == 0) ; i++) {
                 js$.g(Relation.js$a,48);/*$js$*/ portArray[i].unlink(this);
            }
        } finally {
             js$.g(Relation.js$a,49);/*$js$*/ _workspace.doneWriting();
        }
    } finally{js$.flush(Relation.js$c);}} 

    ///////////////////////////////////////////////////////////////////
    ////                         protected methods                 ////

    /** Throw an exception if the specified port cannot be linked to this
     *  relation.  In this base class, the exception is not thrown, but
     *  in derived classes, it might be, for example if the relation cannot
     *  support any more links, or the port is not an instance of an
     *  appropriate subclass of Port.
     *  @param port The port to link to.
     *  @exception IllegalActionException Not thrown in this base class.
     */
    protected void _checkPort (Port port) throws IllegalActionException {try  { js$.g(Relation.js$a,55); 
    } finally{js$.flush(Relation.js$c);}} 

    /** Return a description of the object.  The level of detail depends
     *  on the argument, which is an or-ing of the static final constants
     *  defined in the NamedObj class.  Lines are indented according to
     *  to the level argument using the protected method _getIndentPrefix().
     *  Zero, one or two brackets can be specified to surround the returned
     *  description.  If one is specified it is the the leading bracket.
     *  This is used by derived classes that will append to the description.
     *  Those derived classes are responsible for the closing bracket.
     *  An argument other than 0, 1, or 2 is taken to be equivalent to 0.
     *  This method is read-synchronized on the workspace.
     *  @param detail The level of detail.
     *  @param indent The amount of indenting.
     *  @param bracket The number of surrounding brackets (0, 1, or 2).
     *  @return A description of the object.
     */
    protected String _description(int detail, int indent, int bracket) {try  { js$.g(Relation.js$a,66); 
         js$.g(Relation.js$a,56);/*$js$*/ try {
            _workspace.getReadAccess();
            String result =null ;
            if ( ((( bracket == 1 || bracket == 2 ) && ++Relation.js$a[67] != 0) || ++Relation.js$a[68] == 0) ) {
                 js$.g(Relation.js$a,57);/*$js$*/ result = super._description(detail, indent, 1);
            } else {
                 js$.g(Relation.js$a,58);/*$js$*/ result = super._description(detail, indent, 0);
            }
            if ( ((( (detail & LINKS) != 0 ) && ++Relation.js$a[69] != 0) || ++Relation.js$a[70] == 0) ) {
                if ( ((( result.trim().length() > 0 ) && ++Relation.js$a[71] != 0) || ++Relation.js$a[72] == 0) ) {
                     js$.g(Relation.js$a,59);/*$js$*/ result += " ";
                }
                // To avoid infinite loop, turn off the LINKS flag
                // when querying the Ports.
                 js$.g(Relation.js$a,60);/*$js$*/ detail &= ~LINKS;
                result += "links {\n";
                Enumeration linkedPorts = linkedPorts();
                while ( ((( linkedPorts.hasMoreElements() ) && ++Relation.js$a[73] != 0) || ++Relation.js$a[74] == 0) ) {
                     js$.g(Relation.js$a,61);/*$js$*/ Port port = (Port)linkedPorts.nextElement();
                    result += port._description(detail, indent + 1, 2) + "\n";
                }
                 js$.g(Relation.js$a,62);/*$js$*/ result += _getIndentPrefix(indent) + "}";
            }
            if ( ((( bracket == 2 ) && ++Relation.js$a[75] != 0) || ++Relation.js$a[76] == 0) ) {   js$.g(Relation.js$a,63);/*$js$*/ result += "}"; } 
             js$.g(Relation.js$a,64);/*$js$*/ return result;
        } finally {
             js$.g(Relation.js$a,65);/*$js$*/ _workspace.doneReading();
        }
    } finally{js$.flush(Relation.js$c);}} 

    /** Return a reference to the local port list.
     *  NOTE : This method has been made protected only for the purpose
     *  of connecting Ports to Relations (see Port.link(Relation)).
     *  @see Port
     *  @return The link list.
     */
    protected CrossRefList _getPortList() {try  { js$.g(Relation.js$a,78); 
         js$.g(Relation.js$a,77);/*$js$*/ return _portList;
    } finally{js$.flush(Relation.js$c);}} 

    ///////////////////////////////////////////////////////////////////
    ////                         private variables                 ////

    /** @serial The CrossRefList of Ports which are connected
     *  to this Relation.
     */
    private CrossRefList _portList; static private int js$n() {return 79;}  static private int js$t1=js$.flush(Relation.js$c);private int js$t2=js$.flush(Relation.js$c); 
