<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Generator" content="Microsoft Word 97">
   <meta name="Template" content="C:\Program Files\Microsoft Office\Office\html.dot">
   <meta name="GENERATOR" content="Mozilla/4.51 [en] (X11; U; SunOS 5.5.1 sun4u) [Netscape]">
   <title>Compiling NLPs written in Matlab into a Process Network Model</title>
</head>
<body bgcolor="#FAF0E6" link="#0000FF" vlink="#800080">
<!---@version $Id$--><!---@author-->
<center>
<h1>
<font face="Arial,Helvetica">Compiling Nested Loop Programs written in
Matlab</font></h1></center>

<center>
<h1>
<font face="Arial,Helvetica">into a Process Network Model</font></h1></center>

<hr>
<h1>
<font face="Arial,Helvetica">Introduction</font></h1>

<p><br>At Delft University of Technology, in the Circuits and Systems group,
research is carried out to automatically compile Nested-Loop Programs (NLP)
written in Matlab into a process network model. The NLPs written in Matlab
use the imperative model of computation. The compiled process networks
however describe the same NLPs in terms of a concurrency model. These models
seem more suited for system-level design of silicon systems.
<p>Many well-know signal-processing applications can be written as NLPs.
Having a compiler that automatically compiles these NLPs to process network
models provides us with a large collection of applications described in
the a concurrency model. As the process network model, they use Kahn Process
Networks [Kahn, 1974] in which each process is internally structured in
a particular way. Each process consists of a set of functions, a controller
and state. Such process is called a Stream-Based Function process or SBF-process
as described in [Kienhuis, 1999].
<p>In this web page, we combine the compilation work done at Delft University
with the simulation work done at the University of California at Berkeley.
The compiled NLPs can be simulated in the PN-domain [Goel, 1998] of the
Ptolemy II framework [Davis, 1998] developed at the University of California
at Berkeley. The Ptolemy II framework is an advanced heterogeneous modeling
environment based on Java and it allows us to describe a particular application
as a Java Applet that can run on any web browser.
<br>&nbsp;
<p>
<hr WIDTH="100%">
<h2>
<b><i><font face="Arial">Compilation:</font></i></b></h2>
To show how what compiling a NLP into a process network model implies,
we look at the QR algorithm. Such QR algorithm can be found, for example,
in adaptive beam-forming applications. The QR algorithm is described as
a NLP in Matlab. Two inner-loop iterators <font face="Courier New">j</font>
and <font face="Courier New">i</font> form a parameterized triangular-shaped
index space of size <font face="Courier New">N(</font>The programs loop
bounds <font face="Courier New">K</font> and <font face="Courier New">N</font>
are parameters<font face="Courier New">)</font>. This triangular shaped
space describes a single <i>QR-update</i>. The outer-loop iterator <font face="Courier New">k</font>
indicates which iteration of the QR update is currently taking place. Notice
that the QR decomposition program uses matrices <font face="Courier New">R</font>
and <font face="Courier New">X</font> and has a lexicographical sequential
index ordering as dictated by the <font face="Courier New">for</font>-loops.
<pre><tt>%parameter K 100 1000;
%parameter N 8 16;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %%
%%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nested Loop Program in Matlab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %%
%%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Calculate K iterations of a QR-update
for k = 1:1:K,
&nbsp; for j = 1:1:N,
&nbsp;&nbsp;&nbsp; [r(j,j), x(k,j), t ] = Vectorize( r(j,j), x(k,j) );
&nbsp;&nbsp;&nbsp; for i = j+1:1:N,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [r(j,i), x(k,i), t] = Rotate( r(j,i), x(k,i), t );
&nbsp;&nbsp;&nbsp; end
&nbsp; end
end

%% After K iterations, collect the values of the R Matrix
for j = 1:1:N,
&nbsp; for i = j:1:N,
&nbsp;&nbsp;&nbsp; [ Sink(j,i) ] = _WriteMatrix_Rout( r(j,i) );
&nbsp; end
end</tt></pre>
&nbsp;
<p>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>The QR algorithm has a dependence graph representation. Instead of showing
the complete dependence graph of the QR algorithm, we show only one <i>k</i>-plane,
representing a single QR update. The complete DG would consist of <i>K</i>
of these planes. Each and every <i>k</i>-plane depends on its predecessor.
Each node in the DG represents a function from the QR algorithm: a gray
node represents the function <font face="Courier New">Vectorize</font>
and a white node represents the function <font face="Courier New">Rotate</font>.
At the side of the triangle at the top of the figure, data (i.e., the <i>X</i>
data) is arriving from external sources -- say sensors of an <font face="Courier New">N</font>-antenna
array (in this case <font face="Courier New">N</font>=6) -- that propagates
downwards through the plane. The values of 21 <i>r</i> variables (i.e.,
elements of the <font face="Courier New">R</font> matrix in the Matlab
program) produced by the previous plane are updated using the functions
<font face="Courier New">Rotate</font>
and <font face="Courier New">Vectorize</font>. To rotate, each <font face="Courier New">Rotate</font>
function needs to have an angle <font face="Courier New">theta</font> calculated
by the function
<font face="Courier New">Vectorize</font> on the diagonal
of the triangle.
<br>&nbsp;
<br>&nbsp;
<br>
<center>
<p><img SRC="dg.gif" height=300 width=300></center>

<p><br>
<br>
<br>
<br>
<p>The dependence graph representation of the QR algorithm reveals features
like regularity and locality. Unlike the Matlab description, it also reveals
a high level of concurrency. These features -- regularity, locality, and
concurrency -- are typical for many NLP algorithms. The dependence graph
can be written down as a so-called reduced dataflow graph. The reduced
dataflow graph for our QR algorithm is given below. To obtain a process
network model, we replace each node in the reduced dataflow graph with
a process and each edge with an unbounded FIFO buffers. Each process in
the network description is described in terms of a set of functions, a
controller and state.
<br>&nbsp;
<br>&nbsp;
<br>
<center>
<p><img SRC="QRvr.jpeg" height=300 width=475></center>

<p><br>
<br>
<br>
<p>The steps involved in the compilation from a NLP in Matlab to a process
network are described in Rypkema et al. [1998]. The current status of the
compilation from NLPs to process network models is that proof of concept
is done for a small number of problems. The compiler tool-chain needs to
be generalized such that process network models are generated for a much
large class of NLPs. Also, the output generated by the compilation tool-chain
is currently in C++. As a consequence, to make the example of the QR algorithm
run in the Ptolemy II framework, we manually had to create the Java objects.
<br>&nbsp;
<h2>
<b><i><font face="Arial">Ptolemy II Demo</font></i></b></h2>
We simulate the obtained process network using the Ptolemy II framework.
Each process in the reduced dependence graph is described by means of a
PN-process. In the demo, we process a given array of N antenna signals
using K iterations of the QR-update algorithm. The numbers produced are
the values of the R matrix after K iterations.
<br>&nbsp;
<br>&nbsp;
<br>
<br>
<br>
<center>





<P>
 <!-- All of the controls of the applet should be visible when the
applet is displayed on a XGA screen-->
<center>
<!-- The HTML below is for the Java Plugin.  The first 
     section is for IE, the second is for Netscape
 -->
<OBJECT classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93"
 width=500 height=500
 name="QRcompileApplet"
 codebase="http://java.sun.com/products/plugin/1.2/jinstall-12-win32.cab#Version=1,2,0,0">
<PARAM NAME=CODE VALUE=ptolemy.domains.pn.demo.QR.QRcompileApplet.class>
<PARAM NAME=CODEBASE VALUE=../../../../..>
<PARAM NAME="type" VALUE="application/x-java-applet;version=1.2">
<PARAM NAME="name" VALUE="QRcompileApplet">
<PARAM NAME="background" VALUE="#faf0e6">
<PARAM NAME="defaultStopTime" VALUE="100">
<COMMENT>
<EMBED type="application/x-java-applet;version=1.2"
 code=ptolemy.domains.pn.demo.QR.QRcompileApplet
 codebase=../../../../..
 name="QRcompileApplet"
 width=500 height=500
 background="#faf0e6"
 defaultStopTime="100"
 pluginspage="http://java.sun.com/products/plugin/1.2/plugin-install.html">
<NOEMBED></COMMENT>
<I>If you were able to run applets, you would have a demo here.</I>
</NOEMBED></EMBED>
</OBJECT>
</center>
<P>

<p><br>
<br>
<br>
<p>&nbsp;In the we select K=10 and N=6, we must find the following R matrix
in order to be functionally correct
<dir>
<dir>
<pre><tt># name: Rout
# type: matrix
# rows: 6
# columns: 6
270.843 206.234&nbsp; 60.482 -39.318 -89.100 -38.568
&nbsp; 0.000 144.933 181.192 172.919 104.333&nbsp; 10.488
&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp; 32.964&nbsp; 18.280&nbsp; 10.909&nbsp;&nbsp; 9.170
&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp; 24.739&nbsp;&nbsp; 7.446&nbsp;&nbsp; 7.208
&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp; 20.308&nbsp; 11.206
&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp;&nbsp; 0.000&nbsp;&nbsp; 8.535</tt></pre>
</dir>
</dir>

<h2>

<hr WIDTH="100%"></h2>

<h2>
<b><font face="Arial"><font size=+1>References</font></font></b></h2>
Edwin Rijpkema, Bart Kienhuis and Ed F. Deprettere, ``<a href="ftp://cas.et.tudelft.nl/pub/kienhuis/rypkema:1998.pdf">From
Piecewise Regular Algorithms to Process Networks</a><i>'</i>', In J.P.
Veen (ed.), Proceedings of the ProRISC/IEEE Workshop on Circuits, Systems
and Signal Processing, November 1998.
<p>Gilles Kahn, "<i>The semantics of a simple language for parallel programming</i>".
In proc. of the IFIP Congress 74, North-Holland Publishing Co., 1974
<p>A.C.J. Kienhuis, "<a href="http://cas.et.tudelft.nl/~kienhuis/hse/thesis.html">Design
Space Exploration of Stream-based Dataflow Architectures: Methods and Tools</a>",
Ph.D. Thesis, Delft University of Technology, The Netherlands, January
1999.
<p>J. Davis, R. Galicia, M. Goel, C. Hylands, E.A. Lee, J. Liu, X. Liu,
L. Muliadi, S. Neuendorffer, J. Reekie, N. Smyth, J. Tsay and Y. Xiong,
<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/98/HMAD">``Heterogeneous
Concurrent Modeling and Design in Java''</a> Technical Report UCB/ERL No.
M98/72, University of California, Berkeley, CA 94720, November 23, 1998.
<p>M. Goel, ``<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/98/PNinPtolemyII">Process
Networks in Ptolemy II</a>'' MS Report, ERL Technical Report UCB/ERL No.
M98/69, University of California, Berkeley, CA 94720, December 16, 1998.
<br>&nbsp;
<br>&nbsp;
<p>
<hr>
<center>
<p>UNIVERSITY OF CALIFORNIA
<p>Department of Electrical Engineering and Computer Sciences</center>

</body>
</html>
