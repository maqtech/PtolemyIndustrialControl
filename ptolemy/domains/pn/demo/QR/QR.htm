<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Process Network Demo</TITLE>
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Office\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#faf0e6">

<P>
<!---@version $Id$-->
<!---@author-->
</P>
<H1>Process Network Demo</H1>
<P><!-- All of the controls of the applet should be visible when the
applet is displayed on a XGA screen-->
<body bgcolor="#FAF0E6" link="#0000FF" vlink="#800080">
<!-- 
     The HTML below is for the Java Plugin.  The first  
     section is for IE, the second is for Netscape
 -->
<OBJECT classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" 
 width=600 height=600 name="QR" 
 codebase="http://java.sun.com/products/plugin/1.2.2/jinstall-1_2_2-win.cab#Version=1,2,2,0">
<PARAM NAME=CODE VALUE=ptolemy.domains.pn.demo.QR.QR.class>
<PARAM NAME=CODEBASE VALUE=../../../../..>
<PARAM NAME=ARCHIVE VALUE=" ptolemy/ptsupport.jar, ptolemy/domains/pn/pn.jar, ptolemy/domains/pn/demo/QR/QR.jar">
<PARAM NAME="type" VALUE="application/x-java-applet;version=1.2.2">
<PARAM NAME="name" VALUE="QR">
<PARAM NAME="background" VALUE="#faf0e6">
<PARAM NAME="defaultStopTime" VALUE="100">
<COMMENT>
<EMBED type="application/x-java-applet;version=1.2.2" 
  code=ptolemy.domains.pn.demo.QR.QR
  codebase=../../../../.. 
  archive="ptolemy/ptsupport.jar, 
           ptolemy/domains/pn/pn.jar, 
           ptolemy/domains/pn/demo/QR/QR.jar" 
  name="QR" 
  width=600 height=600 background="#faf0e6" 
  defaultStopTime="100" 
  pluginspage="http://java.sun.com/products/plugin/1.2.2/plugin-install.html">
<NOEMBED></COMMENT>
<I>If you were able to run applets, you would have a demo here.</I> 
</NOEMBED>
</EMBED>
</OBJECT>

<P>
The above applet shows the result of a Process Network (PN) executing
a QR-algorithm on a stream of data coming from an array of
antennas. Each execution of the QR algorithm on data from the antennas
is called an update. The applet shows in the matrix R in a
<I>MatrixViewer</I>.<I> </I>The matrix is of<I> </I>size NxN, where N
is the number of antenna's involved. The individual entries in the
matrix are shown in the <I>Plotter</I>. The resulting matrix R is
obtained after doing a certain number of QR-algorithm updates on a
stream of data coming from the antenna array of a certain size.
</p>

<P>
In the demo, if we select 10 QR-updates for an array of 6 antenna's,
the following R matrix must be found: </P>

<PRE>
# name: Rout 
# type: matrix 
# rows: 6 
# columns: 6 

270.843 206.234  60.482 -39.318 -89.100 -38.568 
  0.000 144.933 181.192 172.919 104.333  10.488 
  0.000   0.000  32.964  18.280  10.909   9.170 
  0.000   0.000   0.000  24.739   7.446   7.208 
  0.000   0.000   0.000   0.000  20.30   11.206 
  0.000   0.000   0.000   0.000   0.000   8.535
</PRE> 
<P>

The QR algorithm describes a linear algebra problem in which a matrix
A can be written as a product of two matrices Q and R (A=QR), in which
R is an upper triangular matrix and Q an orthogonal matrix. A program
that does this QR transformation is given below in the Matlab
programming language. The algorithm uses the Cordic functions
<I>Vectorize </I>and <I>Rotate </I>to find the QR transform. If we
execute this program in Matlab, we would find the same matrix R.</P>

<PRE>
%% Initialize Matrix r
for j = 1:1:N,
  for i = j:1:N,
    [r(j,i)] = _ReadMatrix_Zeros_64x64();
  end
end
 
%% Initialize Matrix x
for k = 1:1:K,
  for j = 1:1:N,
    [x(k,j)] = _ReadMatrix_U_1000x16();
  end
end

%% do the QR updates
for k = 1:1:K,
  for j = 1:1:N,
    [r(j,j), x(k,j), t ] = Vectorize( r(j,j), x(k,j) );
    for i = j+1:1:N,
       [r(j,i), x(k,i), t] = Rotate( r(j,i), x(k,i), t );
    end
  end
end

%% After the K iterations, collect the values of the R Matrix
for j = 1:1:N,
  for i = j:1:N,
    [ Sink(j,i) ] = Rout( r(j,i) );
  end
end
</PRE>

<P>
However, we can also describe the same QR-algorithm as a <I>Process
Network</I>. In this process network description, the nodes ND_1,
ND_2, ND_3, ND_4, and ND_5 describe processes and the edges between
these nodes describe FIFO buffers that have a certain capacity. The
processes read from these buffers using a blocking-read semantics. In
the applet, we simulate this process network to get the value for R
matrix. The big difference between the Matlab program and the process
network is that the process network executes in parallel whereas the
Matlab description executes sequentially. </P>

<P>
<center>
<IMG SRC="QRprocessnetwork.gif" WIDTH=622 HEIGHT=317>
</center>
</P> 

<P>
In process <A HREF="ND_2.java">ND_2</A>, a large matrix is stored that
contains 500 real data samples taken from 16 antennas. From this
matrix, the process reads a number of samples (the number of
antenna's) and sends these samples to either node <A
HREF="ND_3.java">ND_3</A> or <A HREF="ND_4.java">ND_4</A>. This
process is repeated a number of times, as many times as there will be
a QR-update. In parallel with process ND_2, process ND_3, and process
ND_4 execute by reading data from incoming edges and producing data on
outgoing edges. After the numbers of QR-updates are done, the final
matrix R is sent to process <A HREF="ND_5.java">ND_5</A>, which sends
the matrix <I>R</I> to the Plotter and the StreamToMatrix actor. The
latter one reconstructs from the incoming stream a matrix, which is
sent to the MatrixViewer to be visualized. Process <A
HREF="ND_1.java">ND_1</A> is used to properly initialize the process
network by sending a specific number of zeros to either process ND_3
or process ND_4.
</P>

<P>
Process networks have the characteristic that they execute in a
<I>deterministic order</I>, which means that the computation of the
result is independent of the schedule order of the processes. Thus,
process networks do not imposing any particular schedule order and a
process network can either be evaluated in parallel, as is done in the
Applet, or equally, in a sequential order, similar to the execution in
Matlab. The result we obtain, i.e. the matrix R, is in both cases the
same.</P></BODY>
</HTML>
