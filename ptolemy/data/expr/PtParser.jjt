/* This file implements an expression parser for Ptolemy II using the Jacc
 * parser generator. It can handle all the basic arithmetic operators
 * (*, /, +, -) and, using reflection, all of the funcionality available
 * in the java.lang.Math package.
 * 
 * Jacc by itself simply generates a file ( and support files) that allow an 
 * input to be parsed, it does not return a parse tree. For the purposes of 
 * type checking we require a parse tree, and this is obtained using JJTree, a 
 * preprocesssor for Jacc. 

 * JJtree operates by annotating the grammer file to support the generation
 * of the parse tree. Thus the process is
 *
 *            --------                 ------
 *  X.jjt -> | JJTREE | --> X.jj  --> | JACC | --> X.java + support files
 *            --------                 ------
 *
 * The parser can also be parsed a symbol table of Params on which the 
 * expression to be passed can depend.
 * 
 * The parser assumes any identifiers it does not recognise are strings.
 * Also anything between quotes(") is taken to be one string.
 *
 */

options {
LOOKAHEAD=1;
    //DEBUG_PARSER = true;
MULTI = true;
STATIC = false;
}

PARSER_BEGIN(PtTreeParser)
package pt.data.parser;

import pt.kernel.*;
import pt.data.*;

import java.io.*;
import java.lang.reflect.*;

public class PtTreeParser {
  
  public PtTreeParser() {
      this(System.in);
  }
  
  public double parseFromInput(){    
    double result = 666;
    System.out.print("\nEnter an Expression to be parsed: ");
    System.out.flush();
    ReInit(System.in);
    try {
	ASTPtSimpleNode n = start();      	
	result = n.value;
	System.out.println("Thank you, result is " + result);
	n.dump("");
    } catch (ParseException x) {
      System.out.println("Exiting, parse failed");
    }
    System.out.flush();
    return result;
  }
 

 public double parse(String stringIn) {
   double result = -999;
   InputStream stream = new ByteArrayInputStream(stringIn.getBytes());
   this.ReInit(stream);
   System.out.print("\nParsing expression: ");
   System.out.println(stringIn.replace('\n', ' ') );
   try {
     ASTPtSimpleNode n = start();
     //n.dump("");
     result = n.value;
     System.out.println("Thank you, result is " + result);
    } catch (ParseException x) {
     System.out.println("Exiting, parse failed");
   }
    System.out.flush();
   return result;
 }  

/*  public double parse(String stringIn, NamedList scope, Param param) {
    double result = -999;
    _scope = scope;
    _param = param;
    result = parse(stringIn);
    _scope = null;
    _param = null;
    return result;
  }*/
}

PARSER_END(PtTreeParser)

SKIP :
{
 	" "
  |	"\r"
  |	"\t"
}



TOKEN :
{
	< EOL: "\n" >
}

TOKEN : /* OPERATORS */
{
	< PLUS: "+" >
  |	< MINUS: "-" >
  |	< MULTIPLY: "*" >
  |	< DIVIDE: "/" >
  |	< EXP: "**" >
 }

TOKEN : /* numeric constants */
{
	< CONSTANT: <FLOAT>
	    | <FLOAT> ( ["e","E"] ([ "-","+"])? <INTEGER> )?
    	>
  | 	< #FLOAT: <INTEGER> 
	    | <INTEGER> ( "." <INTEGER> )?
	    | "." <INTEGER>
    	>
  | 	< #INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >
}

TOKEN : /* Function names */
{
	< ID: ( <LETTER> )+ ( <DIGIT> | <LETTER> )* >
  | 	< #LETTER: ["a"-"z", "A"-"Z"] > 		
} 

TOKEN : /* literal strings */
{
        < STRING: <QUOTE> ( "\\\"" | ~["\""])* <QUOTE> >
  |     < #QUOTE: "\"" >
}

ASTPtSimpleNode start() #PtSimpleNode :
{ASTPtSimpleNode result;}
{
    result = sum() ( <EOL> | <EOF> )?
	{ jjtThis.value = result.value;
	  return jjtThis;}
}

ASTPtSimpleNode sum() #PtSimpleNode :
{Token x;
ASTPtSimpleNode result, side2;}
{
    result = term() ( 
	( x = <PLUS> | x = <MINUS> ) side2 = term()
	{
	  if ( x.kind == PLUS )
		result.value += side2.value;
	    else
		result.value -= side2.value;
	}
    )*
      { jjtThis.value = result.value;
      return jjtThis; }
}

ASTPtSimpleNode term() #PtSimpleNode :
{Token x;
ASTPtSimpleNode result, side2;}
{
    result = exp() ( 
	( x = <MULTIPLY> | x = <DIVIDE> ) side2 = exp()
	{
	  if ( x.kind == MULTIPLY )
	        result.value *= side2.value;
	    else
		result.value /= side2.value;
	}
    )*
      {jjtThis.value = result.value; 
      return jjtThis; }
}

ASTPtSimpleNode exp() #PtSimpleNode :
{ASTPtSimpleNode result, side2; }
{
    result = unary() ( LOOKAHEAD( <EXP> )
	<EXP> side2 = exp()
	{
	    result.value = (new Double(Math.pow(result.value, side2.value))).doubleValue();
	}
    )*
      { jjtThis.value = result.value;
	return jjtThis; }
}

ASTPtSimpleNode unary() #PtSimpleNode :
{ASTPtSimpleNode result; }
{
    <MINUS> result = element()
      { jjtThis.value = (-result.value);
      return jjtThis;}
    |
    result = element()
      { jjtThis.value = result.value;
	return jjtThis;}
}

ASTPtSimpleNode element() #PtSimpleNode :
{ASTPtSimpleNode result;}
{
     <CONSTANT>
	{   try {
	    	jjtThis.value = Double.valueOf(token.image).doubleValue();
		return jjtThis;
	    } catch (NumberFormatException ee) {
	        System.out.println("Error converting token " + token.image + "to a number");
	        jjtThis.value = 0;
		return jjtThis;
	    }
	}

  | "("  result = sum() ")"
    { jjtThis.value = result.value;
      return jjtThis; }

  |   LOOKAHEAD( <ID> "(" )
      result = function()
    { jjtThis.value = result.value;
      return jjtThis; } 

  |   <ID>
    { 
      /*if (_scope != null) {
	ptToken x = (ptToken)_scope.get(token.image);
	if (ptToken != null) {
	  //jjtThis.ptToken = x.clone();
	  //x.getPublisher().addObserver(_param);
	  jjtThis.value = 999;
	  return jjtThis;
	// }
      } */
      if (token.image.equalsIgnoreCase("PI")) {
	//jjtThis.ptToken = new ptDoubleToken(Math.PI);
	jjtThis.value = Math.PI;
	return jjtThis;
      }
      else if (token.image.equalsIgnoreCase("E")) {
	//	jjtThis.ptToken = new ptDoubleToken(Math.E);
	jjtThis.value = Math.E;
	return jjtThis;
      }
      else {
	//jjtThis.ptToken = new ptStringToken(token.image);
	jjtThis.value = 999;
	return jjtThis;
      }

    }

  |   <STRING>
    {
      //jjtThis.stringValue = token.image; /*new ptStringToken(token.image);*/
      int len = token.image.length();
      //char slash = '\';
      // Now cut the " from each end of the string
      String tidied = token.image.substring(1, (len -1));
      System.out.println("encountered a string \"" + tidied + "\"");
      jjtThis.value = 999;
      return jjtThis;
    }
}

ASTPtSimpleNode function() #PtSimpleNode :
{ String funcname;
  int args = 0;
  java.util.Stack funcArgStack = new java.util.Stack();
  ASTPtSimpleNode aa, bb; 
	//FIXME: want ot add matlab & tcl calling ability here later
}
{    <ID> {funcname = token.image;} 
    "(" [ aa = sum() {args++; funcArgStack.push(new Double(aa.value));} ( 
    "," bb = sum() {args++; funcArgStack.push(new Double(bb.value));})* ] 
    ")"
    {
      Class[] argTypes = new Class[args];
      Double[] argValues = new Double[args];
      try {
	int i;
	for (i=args-1; i>=0; i--) {
	  argValues[i] = (Double)funcArgStack.pop();	
	  argTypes[i] = argValues[i].TYPE;
	}
	// Note: Java makes a dintinction between the class objects
	// for double & Double...
	Class tmp = Class.forName("java.lang.Math");
	Method m = tmp.getMethod(funcname, argTypes);
	Double result = (Double)m.invoke(tmp, argValues);
	jjtThis.value = result.doubleValue();
      } catch (Exception ex) {
	int i;
	StringBuffer sb = new StringBuffer();
	for (i=0; i<args; i++) {
	  if (i==0) {
	    sb.append(argValues[i].doubleValue());
	  } else {
	    sb.append(", " + argValues[i].doubleValue());
	  }
	}  
	System.out.print("Function "+funcname+"(");
	System.out.println(sb + ") cannot be executed with given arguments");
      }	
      return jjtThis;
    }
}

