/* Input file to JJTree and JavaCC to generate Ptolemy II Parser */

options {
LOOKAHEAD=1;
//DEBUG_PARSER = true;
//DEBUG_TOKEN_MANAGER = true;
MULTI = true;
STATIC = false;
}

PARSER_BEGIN(PtParser)
/* 
 Copyright (c) 1998 The Regents of the University of California.
 All rights reserved.
 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the above
 copyright notice and the following two paragraphs appear in all copies
 of this software.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.
 
                                        PT_COPYRIGHT_VERSION_2
                                        COPYRIGHTENDKEY

@ProposedRating Yellow (nsmyth@eecs.berkeley.edu)

Created : May 1998

*/

/** //////////////////////////////////////////////////////////////////////
 *  //// PTParser.jjt
 *  
 * This file implements an expression parser for Ptolemy II using the 
 * JavaCC parser generator. It can handle all the basic arithmetic operators
 * (*, /, +, -,, %), relational operators (<, <=, >, >=, == !=), logical 
 * operators(&&, ||, !), bitwise operators (&, |, ^, ~)  and, using 
 * reflection, all of the funcionality available in the java.lang.Math 
 * package. By editing the ASTFunctionNode file it is also relatively 
 * easy to allow refernces to functions in other math packages as well 
 * as passing strings to Matlab and Tcl to be evaluated.
 *  
 * Functional if is supported via the following sytnax:
 *         (boolean) ? (value1) : (value2)
 * Extensibility is supported by allowing method calls on the Tokens,
 * the syntax is 
 *         (value1).method(comma seperated arguments)
 * 
 * JavaCC by itself simply generates a file ( and support files) that allow an 
 * input to be parsed, it does not return a parse tree. For the purposes of 
 * type checking we require a parse tree, and this is obtained using JJTree, a 
 * preprocesssor for Jacc. 

 * JJtree operates by annotating the grammer file to support the generation
 * of the parse tree. Thus the process is
 *
 *            --------                 ------
 *  X.jjt -> | JJTREE | --> X.jj  --> | JACC | --> X.java + support files
 *            --------                 ------
 *
 * The parser can also be parsed a symbol table of parameters on which the 
 * expression to be passed can depend.
 * 
 * Anything between quotes(") is taken to be one string.
 *
 * The expressions recognized follow as close as possible the syntax of Java.
 * In particular the operator precedences implemented here follow exactly 
 * those in Java. Any type conversions that are performed are lossless. If 
 * the user wants lossy conversions, explicit casts will be neccessary.
 * 
 * For a more thorough description of what the Parser is designed to do, 
 * please consult the Ptolemy II design document (or contact nsmyth@eecs)
 *
 * 
 * @author Neil Smyth
 * @version $Id$
 
 * @see pt.data.expr.ASTPtFunctionNode
 * @see pt.data.expr.ASTPtLeafNode
 * @see pt.data.expr.ASTPtLogicalNode
 * @see pt.data.expr.ASTPtMiscNode
 * @see pt.data.expr.ASTPtProductNodeI
 * @see pt.data.expr.ASTPtRelationalNode
 * @see pt.data.expr.ASTPtRootNode
 * @see pt.data.expr.ASTPtSumNode
 * @see pt.data.expr.ASTPtUnaryNode
 * @see pt.data.Token 
*/



package pt.data.expr;

import pt.kernel.*;
import pt.kernel.util.*;
import pt.data.*;

import java.io.*;

public class PtParser {
    /** Stores the parameters to which the input expression can reference
     */
    private NamedList _scope;

    /** The Parameter (or other Observer) originating the call to the parser. 
     *  Each time another parameter is referenced in the input expression, 
     *  this Parameter is registered as an observer of that parameter. 
     *  If null, then no dependency is registered.
     */
    private java.util.Observer _observer;

    boolean debug = false;
    
    public PtParser(java.util.Observer obs) {
        this(new ByteArrayInputStream("a hack!!".getBytes()));
        _observer = obs;
    }

    public PtParser() {
        this(new ByteArrayInputStream("a hack!!".getBytes()));
    }

    /** Generates a parse tree from the given String. The root node is 
     *  returned. To evaluate the parse tree, the method evaluateParseTree()
     *  should be called on the rootNode
     *  @param stringIn The expression to be parsed
     *  @exception IllegalArgumentException Thrown if the parse failed.
     *  @return The root node of the parse tree.
     */
    public ASTPtRootNode  generateParseTree(String stringIn) throws IllegalArgumentException {
        InputStream stream = new ByteArrayInputStream(stringIn.getBytes());
        this.ReInit(stream);
        //debug = true;
        String str = stringIn.replace('\n', ' ');
        if (debug) { 
            System.out.print("\nParsing expression: ");
            System.out.println(str);
        }
        try {
            // First parse the expression to obtain the parse tree
            ASTPtRootNode rootNode = start();
            if (debug) rootNode.displayParseTree(" ");
            return rootNode;
        } catch (ParseException x) {
            str = "parse of " + stringIn + " failed: " + x.getMessage();
            throw new IllegalArgumentException(str);
        }
    }  

    /** Generates a parse tree from the given String. The root node is 
     *  returned. To evaluate the parse tree, the method evaluateParseTree()
     *  should be called on the rootNode
     *  @param stringIn The expression to be parsed.
     *  @param scope Parameters to which the expression can refer.
     *  @exception IllegalArgumentException Thrown if the parse failed.
     *  @return The root node of the parse tree.
     */
    public ASTPtRootNode generateParseTree(String stringIn, NamedList scope) throws IllegalArgumentException {
        _scope = scope;
        ASTPtRootNode rootNode;
        try {
            rootNode = generateParseTree(stringIn);
        } catch (IllegalArgumentException ex) {
            throw ex;
        } finally {
            // need to make sure Parser state is reset
            _scope = null;
        } 
        return rootNode;
    }
}

PARSER_END(PtParser)


/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


/* Now come to proper tokens */

SKIP :
{
 	" "
  |	"\r"
  |	"\t"
}

TOKEN :
{
	< EOL: "\n" >
}

TOKEN : /* Arithmetic operators */
{
	< PLUS: "+" >
  |	< MINUS: "-" >
  |	< MULTIPLY: "*" >
  |	< DIVIDE: "/" >
  |     < MODULO: "%" >
}

TOKEN : /* Relational operators */
{
	< GT: ">" >
  |	< LT: "<" >
  |	< GTE: ">=" >
  |	< LTE: "<=" >
  |     < NOTEQUALS: "!=" >
  |     < EQUALS: "==" >
}

TOKEN : /* Boolean & bitwise operators */
{
	< COND_AND: "&&" >
  |	< COND_OR: "||" >
  |     < BOOL_NOT: "!" >
  |     < BITWISE_NOT: "~" >                          
  |	< AND: "&" >
  |     < OR: "|" >
  |     < XOR: "^" >  

}

TOKEN : /* Numeric literals */
{
  < INTEGER:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < DOUBLE:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}

TOKEN : /*Boolean literals */
{
    <BOOLEAN : ( "TRUE" | "true" | "True" | "FALSE" | "false" | "False") >
}

TOKEN : /* Function names */
{
	< ID: ( <LETTER> )+ (["0"-"9", "$", "@", "#", "[", "]" ] | <LETTER> )* >
  | 	< #LETTER: ["a"-"z", "A"-"Z", "_"] > 		
} 

TOKEN : /* literal strings */
{
        < STRING: <QUOTE> ( "\\\"" | ~["\""])* <QUOTE> >
  |     < #QUOTE: "\"" >
}

ASTPtRootNode start() #PtRootNode :
{}
{
    funcIf() ( <EOL> | <EOF> )?
	{ return jjtThis; }
}

void funcIf() #void :
{}
{
   (
           logicalOr() ( "?" logicalOr() ":" logicalOr() )?
   ) #PtMiscNode(>1)
}

void logicalOr() #void :
{Token x;}
{
   (
           logicalAnd() ( 
                   x = <COND_OR> logicalAnd()
                   {  jjtThis._tokenList.insertLast(x); }
           )*
   ) #PtLogicalNode(>1)
}

void logicalAnd() #void :
{Token x;}
{
   (
           bitwiseOr() ( 
                   x = <COND_AND> bitwiseOr()
                   {  jjtThis._tokenList.insertLast(x); }
           )*
   ) #PtLogicalNode(>1)
}

void bitwiseOr() #void :
{Token x;}
{
   (
           bitwiseXor() ( 
                   x = <OR> bitwiseXor()
                   {  jjtThis._tokenList.insertLast(x); }
           )*
   ) #PtBitwiseOpNode(>1)
}

void bitwiseXor() #void :
{Token x;}
{
   (
           bitwiseAnd() ( 
                   x = <XOR> bitwiseAnd()
                   {  jjtThis._tokenList.insertLast(x); }
           )*
   ) #PtBitwiseOpNode(>1)
}

void bitwiseAnd() #void :
{Token x;}
{
   (
           logicalEquals() ( 
                   x = <AND> logicalEquals()
                   {  jjtThis._tokenList.insertLast(x); }
           )*
   ) #PtBitwiseOpNode(>1)
}

void logicalEquals() #void :
{Token x;}
{
   (
           relational() ( 
                   ( x = <EQUALS> | x = <NOTEQUALS> ) relational()
                   {
                       jjtThis._tokenList.insertLast(x);
                   }
           )?
   ) #PtRelationalNode(>1)

}

void relational() #void :
{Token x;}
{
   (
           sum() ( 
                   ( x = <GT> | x = <GTE> | x = <LT> | x = <LTE> ) sum()
                   {
                       jjtThis._tokenList.insertLast(x);
                   }
           )?
   ) #PtRelationalNode(>1)
}

void sum() #void :
{Token x;}
{
   (
           term() ( 
                   ( x = <PLUS> | x = <MINUS> ) term()
                   {
                       jjtThis._tokenList.insertLast(x);
                   }
           )*
   ) #PtSumNode(>1)
}

void term() #void :
{Token x;}
{
   (
           unary() ( 
                   ( x = <MULTIPLY> | x = <DIVIDE> | x = <MODULO> ) unary()
                   {
                       jjtThis._tokenList.insertLast(x);
                   }
           )*
   ) #PtProductNode(>1)
}


void unary() #void :
{}
{
   (
           <MINUS> element()
           { jjtThis.isMinus = true;}
   ) #PtUnaryNode

 |  
   (
           <BOOL_NOT> element()
           { jjtThis.isNot = true;} 
   ) #PtUnaryNode
 |  
   (
           <BITWISE_NOT> element()
           { jjtThis.isBitwiseNot = true;} 
   ) #PtUnaryNode

 |  element()
}

void element() #void :
{
int len;
String tidied, x;
}
{
   ( 
     <DOUBLE>
	{   try 
            {
                x = token.image.toLowerCase();
                len = x.length();
                if ( x.endsWith("f") ) {                   
                } else if ( x.endsWith("d") || x.endsWith("f") ) {   
                    // all floating point numbers are double
                    Double value = new Double(x.substring(0, len-1 ));
                    jjtThis._ptToken = new DoubleToken(value.doubleValue());
                } else {
                   Double value = new Double(x);
                   jjtThis._ptToken = new DoubleToken(value.doubleValue()); 
                }
            } catch (NumberFormatException ee) {
                String str = "Unable to convert token " + token.image;
                throw new ParseException(str + "to an float or double");
            }
        }
   ) #PtLeafNode

  |  
   (
     <INTEGER>
	{   try 
            {
                x = token.image.toLowerCase();
                len = x.length();
                if ( x.endsWith("l") ) {                   
                    Long value = new Long(x.substring(0, len-1 ));
                    jjtThis._ptToken = new LongToken(value.longValue());
                } else {
                   Integer value = new Integer(x);
                   jjtThis._ptToken = new IntToken(value.intValue()); 
                }
            } catch (NumberFormatException ee) {
                String str = "Unable to convert token " + token.image;
                throw new ParseException(str + "to an integer or long");
	    }
	}
   ) #PtLeafNode

  | 
   (
      <STRING>
      {
         // Now cut the " from each end of the string
        len = token.image.length();
        tidied = token.image.substring(1, (len -1));
        jjtThis._ptToken = new StringToken(tidied);
      }
   ) #PtLeafNode

  |  
   (
     <BOOLEAN>
      { 
          if (token.image.equalsIgnoreCase("TRUE")) {
              jjtThis._ptToken = new BooleanToken(true);
          } else if (token.image.equalsIgnoreCase("FALSE")) {
              jjtThis._ptToken = new BooleanToken(false);   
          }
      }
   ) #PtLeafNode   


  | 
    (
        "(" funcIf() ( 
            LOOKAHEAD( ")" "." )  (
                    // we're in a method call on the previous token 
                  ")" "." <ID> {jjtThis.methodName = token.image; }
                  "(" [ funcIf() ( "," funcIf()  )* ]  ")" )
          |            
            ")"
         )
     ) #PtMiscNode(>1)
 
  |   LOOKAHEAD( <ID> "(" )
      function()
    
  | 
   (
     <ID>
     { 
        if (_scope != null) {
            pt.data.expr.Parameter xx =
		 (pt.data.expr.Parameter)_scope.get(token.image);
            if (xx != null) {
                // the param is stored in the node so that the tree does not 
                // have to be reparsed
                jjtThis._param   = xx; 
                //register the calling parameter as an Observer of this ID
                if (_observer != null) {
                    xx.getToken().getPublisher().addObserver(_observer);
                }
            } else { 
                String str = " Parameter " + token.image + " not visible in ";
                throw new ParseException(str + "current scope");
            }
        } else if (token.image.equalsIgnoreCase("PI")) {
            jjtThis._ptToken = new pt.data.DoubleToken(Math.PI);
        } else if (token.image.equalsIgnoreCase("E")) {
            jjtThis._ptToken = new pt.data.DoubleToken(Math.E);
        } else {
            String str = " Parameter" + token.image + " not visible in ";
            throw new ParseException(str + "current scope");
        }
    }
   ) #PtLeafNode
}


void function() #PtFunctionNode :
{}
{    <ID> {jjtThis.funcName = token.image;} 
    "(" [  funcIf() ( ","  funcIf()  )* ]  ")"
}


