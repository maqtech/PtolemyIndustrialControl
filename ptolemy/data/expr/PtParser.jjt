/* This file implements an expression parser for Ptolemy II using the Jacc
 * parser generator. It can handle all the basic arithmetic operators
 * (*, /, +, -) and, using reflection, all of the funcionality available
 * in the java.lang.Math package.
 * 
 * Jacc by itself simply generates a file ( and support files) that allow an 
 * input to be parsed, it does not return a parse tree. For the purposes of 
 * type checking we require a parse tree, and this is obtained using JJTree, a 
 * preprocesssor for Jacc. 

 * JJtree operates by annotating the grammer file to support the generation
 * of the parse tree. Thus the process is
 *
 *            --------                 ------
 *  X.jjt -> | JJTREE | --> X.jj  --> | JACC | --> X.java + support files
 *            --------                 ------
 *
 * The parser can also be parsed a symbol table of Params on which the 
 * expression to be passed can depend.
 * 
 * The parser assumes any identifiers it does not recognise are strings.
 * Also anything between quotes(") is taken to be one string.
 *
 */

options {
LOOKAHEAD=1;
//DEBUG_PARSER = true;
MULTI = true;
STATIC = false;
}

PARSER_BEGIN(PtParser)
package pt.data.parser;

import pt.kernel.*;
import pt.data.*;

import java.io.*;
import java.lang.reflect.*;

public class PtParser {
    pt.data.Token _ptToken;
    NamedList _scope;
    pt.data.Param _param;
    
  public PtParser() {
      this(System.in);
  }
  
  public pt.data.Token parseFromInput(){   
      System.out.print("\nEnter an Expression to be parsed: ");
      System.out.flush();
      ReInit(System.in);
      try {
	ASTPtSimpleNode n = start();      	
	_ptToken = n.resolve();
        n.dump(" ");
        System.out.println("Thank you, result is " + _ptToken.toString());
      } catch (Exception x) {
          System.out.println("Exiting, parse failed");
      }
      System.out.flush();
    return _ptToken;
  }
 

 public pt.data.Token parse(String stringIn) {
     InputStream stream = new ByteArrayInputStream(stringIn.getBytes());
     this.ReInit(stream);
     System.out.print("\nParsing expression: ");
     System.out.println(stringIn.replace('\n', ' ') );
     try {
     ASTPtSimpleNode n = start();  
     _ptToken = n.resolve();
     n.dump(" ");
     System.out.println("Thank you, result is " + _ptToken.toString());
    } catch (Exception x) {
     System.out.println("Exiting, parse failed");
   }
     return _ptToken;
 }  

    public pt.data.Token parse(String stringIn, NamedList scope, pt.data.Param param) {
        _scope = scope;
        _param = param;
        _ptToken = parse(stringIn);
        _scope = null;
        _param = null;
        return _ptToken;
    }
}

PARSER_END(PtParser)

SKIP :
{
 	" "
  |	"\r"
  |	"\t"
}



TOKEN :
{
	< EOL: "\n" >
}

TOKEN : /* OPERATORS */
{
	< PLUS: "+" >
  |	< MINUS: "-" >
  |	< MULTIPLY: "*" >
  |	< DIVIDE: "/" >
  |	< EXP: "**" >
 }

TOKEN : /* numeric constants */
{
	< CONSTANT: <FLOAT>
	    | <FLOAT> ( ["e","E"] ([ "-","+"])? <INTEGER> )?
    	>
  | 	< #FLOAT: <INTEGER> 
	    | <INTEGER> ( "." <INTEGER> )?
	    | "." <INTEGER>
    	>
  | 	< #INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >
}

TOKEN : /* Function names */
{
	< ID: ( <LETTER> )+ ( <DIGIT> | <LETTER> )* >
  | 	< #LETTER: ["a"-"z", "A"-"Z"] > 		
} 

TOKEN : /* literal strings */
{
        < STRING: <QUOTE> ( "\\\"" | ~["\""])* <QUOTE> >
  |     < #QUOTE: "\"" >
}

ASTPtSimpleNode start() #PtSimpleNode :
{}
{
    sum() ( <EOL> | <EOF> )?
	{ return jjtThis; }
}

void sum() #PtSumNode :
{Token x;}
{
    term() ( 
	( x = <PLUS> | x = <MINUS> ) term()
	{
	  jjtThis._tokenList.insertLast(x);
	}
    )*
}

void term() #PtProductNode :
{Token x;}
{
    exp() ( 
	( x = <MULTIPLY> | x = <DIVIDE> ) exp()
	{
            jjtThis._tokenList.insertLast(x);
	}
    )*
}

void exp() #PtExpNode :
{}
{
    unary() ( LOOKAHEAD( <EXP> ) <EXP>  exp() )*
}

void unary() #PtUnaryNode :
{}
{
    <MINUS> element()
      { jjtThis.isMinus = true;}
    |
    element()
}

void element() #PtSimpleNode :
{ASTPtSimpleNode result;}
{
     <CONSTANT>
	{   try 
            {
                Double value = new Double(token.image);
                jjtThis._ptToken = new DoubleToken(value.doubleValue());
               
	    } catch (NumberFormatException ee) {
	        System.out.println("Error converting token " + token.image + "to a number");
	        throw new ParseException();
	    }
	}

  | "(" sum() ")"
   
  |   LOOKAHEAD( <ID> "(" )
      function()
    
  |   <ID>
    { 
        if (_scope != null) {
            pt.data.Token x = (pt.data.Token)_scope.get(token.image);
            if (x != null) {
                jjtThis._ptToken = (pt.data.Token)x.clone();
                x.getPublisher().addObserver(_param);
            }
        } 
        else if (token.image.equalsIgnoreCase("PI")) {
            jjtThis._ptToken = new pt.data.DoubleToken(Math.PI);
        }
        else if (token.image.equalsIgnoreCase("E")) {
            jjtThis._ptToken = new pt.data.DoubleToken(Math.E);
        }
        else {
            jjtThis._ptToken = new pt.data.StringToken(token.image);
        }
    }

  |   <STRING>
    {
         // Now cut the " from each end of the string
        int len = token.image.length();
        String tidied = token.image.substring(1, (len -1));
        jjtThis._ptToken = new pt.data.StringToken(tidied);
        System.out.println("encountered a string \"" + tidied + "\"");    
    }
}

void function() #PtFunctionNode :
{   
  java.util.Stack funcArgStack = new java.util.Stack();
  ASTPtSimpleNode aa, bb; 
}
{    <ID> {jjtThis.funcName = token.image;} 
    "(" [  sum() ( ","  sum()  )* ]  ")"
}

