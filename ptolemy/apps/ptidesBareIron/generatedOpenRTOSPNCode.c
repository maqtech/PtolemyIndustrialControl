/* Generated by Ptolemy II (http://ptolemy.eecs.berkeley.edu)
Copyright (c) 2005-2008 The Regents of the University of California.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.
IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
*/
#ifndef PT_NO_FREERTOS_H
#include "FreeRTOS.h"
#endif
#ifndef PT_NO_TASK_H
#include "task.h"
#endif
#ifndef PT_NO_QUEUE_H
#include "queue.h"
#endif
#ifndef PT_NO_LCD_MESSAGE_H
#include "lcd_message.h"
#endif
#ifndef PT_NO_SEMPHR_H
#include "semphr.h"
#endif
#ifndef PT_NO_STDLIB_H
#include <stdlib.h>
#endif
#ifndef PT_NO_STDARG_H
#include <stdarg.h>
#endif
#ifndef PT_NO_STDIO_H
#include <stdio.h>
#endif
#ifndef PT_NO_STRING_H
#include <string.h>
#endif
/* Generate type resolution code for .ControlRobot */
// Constants.
#define MISSING 0
#define boolean unsigned char
/* Infinity is a valid Ptolemy identifier. */
#define Infinity HUGE_VAL
#ifdef linux
/* Linux tends to have NAN. */
#define NaN (__builtin_nanf (""))
#else /*linux*/
#define NaN nanf(0)
#endif /*linux*/
#define false 0
#define true 1
#define TYPE_Token -1
#define TYPE_Boolean 0
#define FUNC_isCloseTo 0
#define FUNC_delete 1
#define FUNC_convert 2
typedef struct token Token;
typedef boolean BooleanToken;
// Token structure containing the specified types.
struct token {         // Base type for tokens.
    char type;         // TYPE field has to be the first field.
    union typeMembers {
        // type member declarations [i.e. Type1Token Type1;]
        BooleanToken Boolean;
    } payload;
};
Token emptyToken; /* Used by *_delete() and others. */
Token Boolean_equals (Token thisToken, ...);
Token Boolean_isCloseTo (Token thisToken, ...);
Token Boolean_convert (Token thisToken, ...);
/* We share one method between all scalar types so as to reduce code size. */
Token scalarDelete(Token token, ...) {
    /* We need to return something here because all the methods are declared
    * as returning a Token so we can use them in a table of functions.
    */
    return emptyToken;
}
Token Boolean_new(boolean b);
#define StringtoInt atoi
#define StringtoDouble atof
#define StringtoLong atol
#define DoubletoInt floor
#define InttoDouble (double)
#define InttoLong (long)
char* InttoString (int i) {
    char* string = (char*) malloc(sizeof(char) * 12);
    sprintf((char*) string, "%d", i);
    return string;
}
char* LongtoString (long long l) {
    char* string = (char*) malloc(sizeof(char) * 22);
    sprintf(string, "%lld", l);
    return string;
}
char* DoubletoString (double d) {
    int index;
    char* string = (char*) malloc(sizeof(char) * 20);
    sprintf(string, "%.14g", d);
    // Make sure that there is a decimal point.
    if (strrchr(string, '.') == NULL) {
        index = strlen(string);
        if (index == 20) {
            string = (char*) realloc(string, sizeof(char) * 22);
        }
        string[index] = '.';
        string[index + 1] = '0';
        string[index + 2] = '\0';
    }
    return string;
}
char* BooleantoString (boolean b) {
    char *results;
    if (b) {
        // AVR does not have strdup
        results = (char*) malloc(sizeof(char) * 5);
        strcpy(results, "true");
    } else {
        results = (char*) malloc(sizeof(char) * 6);
        strcpy(results, "false");
    }
    return results;
}
char* UnsignedBytetoString (unsigned char b) {
    char* string = (char*) malloc(sizeof(char) * 3);
    sprintf(string, "%d", (int) b);
    return string;
}
#define NUM_TYPE 1
#define NUM_FUNC 3
Token (*functionTable[NUM_TYPE][NUM_FUNC])(Token, ...)= {
{Boolean_equals, scalarDelete, Boolean_convert}
};
// make a new integer token from the given value.
Token Boolean_new(boolean b) {
    Token result;
    result.type = TYPE_Boolean;
    result.payload.Boolean = b;
    return result;
}
Token Boolean_equals(Token thisToken, ...) {
    va_list argp;
    Token otherToken;
    va_start(argp, thisToken);
    otherToken = va_arg(argp, Token);
    va_end(argp);
    return Boolean_new(
    ( thisToken.payload.Boolean && otherToken.payload.Boolean ) ||
    ( !thisToken.payload.Boolean && !otherToken.payload.Boolean ));
}
/* Instead of Boolean_delete(), we call scalarDelete(). */
Token Boolean_convert(Token token, ...) {
    switch (token.type) {
        // FIXME: not finished
        default:
        fprintf(stderr, "Boolean_convert(): Conversion from an unsupported type. (%d)", token.type);
        break;
    }
    token.type = TYPE_Boolean;
    return token;
}
/* Generate shared code for ControlRobot */
/* Standard includes. */
#include <stdio.h>
/* Hardware library includes. */
#include "hw_memmap.h"
#include "hw_types.h"
#include "hw_sysctl.h"
#include "sysctl.h"
#include "gpio.h"
#include "grlib.h"
#include "uart.h"
#include "rit128x96x4.h"
#include "osram128x64x4.h"
#include "formike128x128x16.h"
#include "bitmap.h"
/* Finished generating shared code for ControlRobot */
/* UploadSong's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input;
/* UploadSong's output variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_output;
/* EmbeddedActor's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_EmbeddedActor_input;
/* PlaySong's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_input;
/* PlaySong's output variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_output;
/* EmbeddedActor's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_EmbeddedActor_input;
/* InitialToken's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_input;
/* Buttons's output variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_Movement_Buttons_up;
static boolean ControlRobot_ModalModel_Reactive_Movement_Buttons_down;
static boolean ControlRobot_ModalModel_Reactive_Movement_Buttons_left;
static boolean ControlRobot_ModalModel_Reactive_Movement_Buttons_right;
/* EmbeddedActor's output variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_Movement_Buttons_EmbeddedActor_left;
static boolean ControlRobot_ModalModel_Reactive_Movement_Buttons_EmbeddedActor_right;
/* Turn's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_Movement_Turn_input;
/* EmbeddedActor's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_Movement_Turn_EmbeddedActor_input;
/* Stop's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_Movement_Stop_input;
/* EmbeddedActor's input variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_Movement_Stop_EmbeddedActor_input;
/* WebServ's output variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_WebServ_output;
/* EmbeddedActor's output variable declarations. */
static boolean ControlRobot_ModalModel_Reactive_WebServ_EmbeddedActor_output;
xTaskHandle *task_ControlRobot_ModalModel_TaskFunction;
/* The preinitialization of the director. */
/* The preinitialization of the director. */
/* preinit_Controller */
static int ControlRobot_ModalModel__Controller__currentState;
static unsigned char ControlRobot_ModalModel__Controller__transitionFlag;
#define STATE_ControlRobot_ModalModel__Controller_Init 0
#define STATE_ControlRobot_ModalModel__Controller_Reactive 1
xTaskHandle *task_ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_TaskFunction;
xTaskHandle *task_ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_TaskFunction;
xTaskHandle *task_ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_TaskFunction;
xTaskHandle *task_ControlRobot_ModalModel_Reactive_Movement_Buttons_TaskFunction;
xTaskHandle *task_ControlRobot_ModalModel_Reactive_Movement_Turn_TaskFunction;
xTaskHandle *task_ControlRobot_ModalModel_Reactive_Movement_Stop_TaskFunction;
xTaskHandle *task_ControlRobot_ModalModel_Reactive_LCD_TaskFunction;
xTaskHandle *task_ControlRobot_ModalModel_Reactive_WebServ_TaskFunction;
/* The preinitialization of the director. */
/* The preinitialization of the director. */
/* preinitEmbeddedActor */
/* Status LED and Push Buttons pin definitions */
#define LED             GPIO_PIN_0 /* PF0 */
#define SELECT          GPIO_PIN_1 /* PF1 */
#define UP              GPIO_PIN_0 /* PE0 */
#define DOWN            GPIO_PIN_1 /* PE1 */
#define LEFT            GPIO_PIN_2 /* PE2 */
#define RIGHT           GPIO_PIN_3 /* PE3 */
#define BUTTON         (UP | DOWN | LEFT | RIGHT)
volatile unsigned char buttons; // Button States
/* The preinitialization of the director. */
/* preinitEmbeddedActor */
/* uip includes. */
#include "hw_types.h"
#include "uip.h"
#include "uip_arp.h"
#include "httpd.h"
#include "timer.h"
#include "clock-arch.h"
#include "hw_ethernet.h"
#include "ethernet.h"
#include "hw_memmap.h"
#include "lmi_flash.h"
#include "sysctl.h"
/* Demo includes. */
#include "emac.h"
#include "partest.h"
#include "lcd_message.h"
struct timer {
    clock_time_t start;
    clock_time_t interval;
};
/*-----------------------------------------------------------*/
/* IP address configuration. */
#define uipIP_ADDR0		192
#define uipIP_ADDR1		168
#define uipIP_ADDR2		0
#define uipIP_ADDR3		2
/* How long to wait before attempting to connect the MAC again. */
#define uipINIT_WAIT    100
/* Shortcut to the header within the Rx buffer. */
#define xHeader ((struct uip_eth_hdr *) &uip_buf[ 0 ])
/* Standard constant. */
#define uipTOTAL_FRAME_HEADER_SIZE	54
/*-----------------------------------------------------------*/
/*
* Send the uIP buffer to the MAC.
*/
static void prvENET_Send(void);
/*
* Setup the MAC address in the MAC itself, and in the uIP stack.
*/
static void prvSetMACAddress( void );
/*
* Port functions required by the uIP stack.
*/
void clock_init( void );
clock_time_t clock_time( void );
/*-----------------------------------------------------------*/
/* The semaphore used by the ISR to wake the uIP task. */
extern xSemaphoreHandle xEMACSemaphore;
/*-----------------------------------------------------------*/
void clock_init(void)
{
    /* This is done when the scheduler starts. */
}
/*-----------------------------------------------------------*/
/* Define clock functions here to avoid header file name clash between uIP
and the Luminary Micro driver library. */
clock_time_t clock_time( void )
{
    return xTaskGetTickCount();
}
extern void timer_set(struct timer *t, clock_time_t interval);
extern int timer_expired(struct timer *t);
extern void timer_reset(struct timer *t);
static void prvENET_Send(void)
{
    vInitialiseSend();
    vIncrementTxLength( uip_len );
    vSendBufferToMAC();
}
/*-----------------------------------------------------------*/
static void prvSetMACAddress( void )
{
    unsigned portLONG ulUser0, ulUser1;
    unsigned char pucMACArray[8];
    struct uip_eth_addr xAddr;
    /* Get the device MAC address from flash */
    FlashUserGet(&ulUser0, &ulUser1);
    /* Convert the MAC address from flash into sequence of bytes. */
    pucMACArray[0] = ((ulUser0 >>  0) & 0xff);
    pucMACArray[1] = ((ulUser0 >>  8) & 0xff);
    pucMACArray[2] = ((ulUser0 >> 16) & 0xff);
    pucMACArray[3] = ((ulUser1 >>  0) & 0xff);
    pucMACArray[4] = ((ulUser1 >>  8) & 0xff);
    pucMACArray[5] = ((ulUser1 >> 16) & 0xff);
    /* Program the MAC address. */
    EthernetMACAddrSet(ETH_BASE, pucMACArray);
    xAddr.addr[ 0 ] = pucMACArray[0];
    xAddr.addr[ 1 ] = pucMACArray[1];
    xAddr.addr[ 2 ] = pucMACArray[2];
    xAddr.addr[ 3 ] = pucMACArray[3];
    xAddr.addr[ 4 ] = pucMACArray[4];
    xAddr.addr[ 5 ] = pucMACArray[5];
    uip_setethaddr( xAddr );
}
/*-----------------------------------------------------------*/
void vApplicationProcessFormInput( portCHAR *pcInputString, portBASE_TYPE xInputLength )
{
    char *c, *pcText;
    static portCHAR cMessageForDisplay[ 32 ];
    extern xQueueHandle xOLEDQueue;
    xOLEDMessage xOLEDMessage;
    /* Process the form input sent by the IO page of the served HTML. */
    c = strstr( pcInputString, "?" );
    if( c )
    {
        /* Turn LED's on or off in accordance with the check box status. */
        if( strstr( c, "LED0=1" ) != NULL )
        {
            vParTestSetLED( 0, 1 );
        }
        else
        {
            vParTestSetLED( 0, 0 );
        }
        
        /* Find the start of the text to be displayed on the LCD. */
        pcText = strstr( c, "LCD=" );
        pcText += strlen( "LCD=" );
        /* Terminate the file name for further processing within uIP. */
        *c = 0x00;
        /* Terminate the LCD string. */
        c = strstr( pcText, " " );
        if( c != NULL )
        {
            *c = 0x00;
        }
        /* Add required spaces. */
        while( ( c = strstr( pcText, "+" ) ) != NULL )
        {
            *c = ' ';
        }
        /* Write the message to the LCD. */
        strcpy( cMessageForDisplay, pcText );
        xOLEDMessage.pcMessage = ( signed portCHAR * ) cMessageForDisplay;
        xQueueSend( xOLEDQueue, &xOLEDMessage, portMAX_DELAY );
    }
}
/* OpenRtosPNDirector's queue declarations. */
static xQueueHandle ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input_0_queue;
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
static xQueueHandle ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_input_0_queue;
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
static xQueueHandle ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_input_0_queue;
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
static xQueueHandle ControlRobot_ModalModel_Reactive_Movement_Turn_input_0_queue;
/* OpenRtosPNDirector's queue declarations. */
static xQueueHandle ControlRobot_ModalModel_Reactive_Movement_Stop_input_0_queue;
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
/* OpenRtosPNDirector's queue declarations. */
static void ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_TaskFunction(void* arg) {
    /* The initialization of the director. */
    /* initEmbeddedActor */
    char msg[25];
    // starting at the C chord.
    char chord = 38;
char major[] = {1,3,5,6,8,10,12,13};
    char note;
    int ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong__i;
    int ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong__songIndex = 0;
    xOLEDMessage xMessage;
    xMessage.pcMessage = msg;
    while (true) {
        /* The firing of the StaticSchedulingDirector */
        /* Fire EmbeddedActor */
        while( pdTRUE != xQueueReceive(ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input_0_queue, &ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input, portMAX_DELAY) );
        sprintf(msg, "UploadSong");
        xQueueSend( xOLEDQueue, &xMessage, 100);
        UARTCharPut(UART1_BASE, 140);
        UARTCharPut(UART1_BASE, ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong__songIndex++ % 8);
        UARTCharPut(UART1_BASE, 8);
        // acquire mutex;
        for (ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong__i = 0; ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong__i < 8; ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong__i++) {
            note = chord + major[ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong__i];
            
            // Send UART control signal.
            UARTCharPut(UART1_BASE, note);
            UARTCharPut(UART1_BASE, 16);
        }
        chord++;
        if (chord > 60) {
            chord = 38;
        }
        // release mutex
        while( pdTRUE != xQueueSend(ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_input_0_queue, &ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_input, portMAX_DELAY) );
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.PlayMidi.UploadSong.EmbeddedActor.input */
        /*
        ....................End updateOffset....ControlRobot.ModalModel.Reactive.PlayMidi.UploadSong.EmbeddedActor.input */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.PlayMidi.UploadSong.EmbeddedActor.output */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.PlayMidi.UploadSong.EmbeddedActor.output */
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.PlayMidi.UploadSong.input */
        /*
        ....................End updateOffset....ControlRobot.ModalModel.Reactive.PlayMidi.UploadSong.input */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.PlayMidi.UploadSong.output */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.PlayMidi.UploadSong.output */
        /* The postfire of the director. */
    }
    /* The wrapup of the director. */
    while(true);
}
static void ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_TaskFunction(void* arg) {
    /* The initialization of the director. */
    /* initEmbeddedActor */
    int ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong__songIndex = 0;
    char msg[10];
    xOLEDMessage xMessage;
    xMessage.pcMessage = msg;
    while (true) {
        /* The firing of the StaticSchedulingDirector */
        /* Fire EmbeddedActor */
        while( pdTRUE != xQueueReceive(ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_input_0_queue, &ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_input, portMAX_DELAY) );
        sprintf(msg, "PlaySong");
        xQueueSend( xOLEDQueue, &xMessage, 100);
        vTaskDelay( (portTickType) 200);
        // acquire mutex;
        // Send UART control signal.
        UARTCharPut(UART1_BASE, 141);
        UARTCharPut(UART1_BASE, ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong__songIndex++ % 8);
        // release mutex
        while( pdTRUE != xQueueSend(ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_input_0_queue, &ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_input, portMAX_DELAY) );
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.PlayMidi.PlaySong.EmbeddedActor.input */
        /*
        ....................End updateOffset....ControlRobot.ModalModel.Reactive.PlayMidi.PlaySong.EmbeddedActor.input */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.PlayMidi.PlaySong.EmbeddedActor.output */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.PlayMidi.PlaySong.EmbeddedActor.output */
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.PlayMidi.PlaySong.input */
        /*
        ....................End updateOffset....ControlRobot.ModalModel.Reactive.PlayMidi.PlaySong.input */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.PlayMidi.PlaySong.output */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.PlayMidi.PlaySong.output */
        /* The postfire of the director. */
    }
    /* The wrapup of the director. */
    while(true);
}
static void ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_TaskFunction(void* arg) {
    /* initialize InitialToken */
    ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input = true;
    while( pdTRUE != xQueueSend(ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input_0_queue, &ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input, portMAX_DELAY) );
    while (true) {
        /* Fire InitialToken */
        while( pdTRUE != xQueueReceive(ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_input_0_queue, &ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_input, portMAX_DELAY) );
        ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input = ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_input;
        while( pdTRUE != xQueueSend(ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input_0_queue, &ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input, portMAX_DELAY) );
    }
    while(true);
}
static void ControlRobot_ModalModel_Reactive_Movement_Buttons_TaskFunction(void* arg) {
    /* The initialization of the director. */
    /* initEmbeddedActor */
    char msg[10];
    xOLEDMessage xMessage;
    xMessage.pcMessage = msg;
    while (true) {
        /* The firing of the StaticSchedulingDirector */
        /* Fire EmbeddedActor */
        // Read UART control signal.
        buttons = GPIOPinRead(GPIO_PORTE_BASE, BUTTON) ^ 0xF;
        //if (buttons) {
            //    sprintf(msg, "B %d", buttons);
            //    xQueueSend( xOLEDQueue, &xMessage, 100);
        //}
        if (buttons & 0x1) {
            ControlRobot_ModalModel_Reactive_Movement_Turn_input = 1;
            while( pdTRUE != xQueueSend(ControlRobot_ModalModel_Reactive_Movement_Turn_input_0_queue, &ControlRobot_ModalModel_Reactive_Movement_Turn_input, portMAX_DELAY) );
        }
        if (buttons & 0x2) {
            ControlRobot_ModalModel_Reactive_Movement_Stop_input = 1;
            while( pdTRUE != xQueueSend(ControlRobot_ModalModel_Reactive_Movement_Stop_input_0_queue, &ControlRobot_ModalModel_Reactive_Movement_Stop_input, portMAX_DELAY) );
        }
        if (buttons & 0x4) {
            ControlRobot_ModalModel_Reactive_Movement_Buttons_left = 1;
            
        }
        ControlRobot_ModalModel_Reactive_Movement_Buttons_right = (buttons & 0x8) > 0? 1 : 0;
        //if (buttons & 0x8) {
            //    ControlRobot_ModalModel_Reactive_Movement_Buttons_right = 1;
            //
        //}
        vTaskDelay(100);
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.EmbeddedActor.up */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.EmbeddedActor.up */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.EmbeddedActor.down */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.EmbeddedActor.down */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.EmbeddedActor.left */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.EmbeddedActor.left */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.EmbeddedActor.right */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.EmbeddedActor.right */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.up */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.up */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.down */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.Movement.Buttons.down */
        /* The postfire of the director. */
    }
    /* The wrapup of the director. */
    while(true);
}
static void ControlRobot_ModalModel_Reactive_Movement_Turn_TaskFunction(void* arg) {
    /* The initialization of the director. */
    /* initEmbeddedActor */
    char msg[25];
    xOLEDMessage xMessage;
    xMessage.pcMessage = msg;
    while (true) {
        /* The firing of the StaticSchedulingDirector */
        /* Fire EmbeddedActor */
        while( pdTRUE != xQueueReceive(ControlRobot_ModalModel_Reactive_Movement_Turn_input_0_queue, &ControlRobot_ModalModel_Reactive_Movement_Turn_input, portMAX_DELAY) );
        sprintf(msg, "Drive", ControlRobot_ModalModel_Reactive_Movement_Turn_input);
        xQueueSend( xOLEDQueue, &xMessage, 100);
        //    acquire mutex;
        // Send UART control signal.
        // Drive straight.
        UARTCharPut(UART1_BASE, 137);
        UARTCharPut(UART1_BASE, 8);
        UARTCharPut(UART1_BASE, 0);
        UARTCharPut(UART1_BASE, 0);
        UARTCharPut(UART1_BASE, 0);
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.Movement.Turn.EmbeddedActor.input */
        /*
        ....................End updateOffset....ControlRobot.ModalModel.Reactive.Movement.Turn.EmbeddedActor.input */
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.Movement.Turn.input */
        /*
        ....................End updateOffset....ControlRobot.ModalModel.Reactive.Movement.Turn.input */
        /* The postfire of the director. */
    }
    /* The wrapup of the director. */
    while(true);
}
static void ControlRobot_ModalModel_Reactive_Movement_Stop_TaskFunction(void* arg) {
    /* The initialization of the director. */
    /* initEmbeddedActor */
    char msg[25];
    xOLEDMessage xMessage;
    xMessage.pcMessage = msg;
    while (true) {
        /* The firing of the StaticSchedulingDirector */
        /* Fire EmbeddedActor */
        while( pdTRUE != xQueueReceive(ControlRobot_ModalModel_Reactive_Movement_Stop_input_0_queue, &ControlRobot_ModalModel_Reactive_Movement_Stop_input, portMAX_DELAY) );
        sprintf(msg, "Drive", ControlRobot_ModalModel_Reactive_Movement_Stop_input);
        xQueueSend( xOLEDQueue, &xMessage, 100);
        //    acquire mutex;
        // Send UART control signal.
        // Drive straight.
        UARTCharPut(UART1_BASE, 137);
        UARTCharPut(UART1_BASE, 255);
        UARTCharPut(UART1_BASE, 255);
        UARTCharPut(UART1_BASE, 255);
        UARTCharPut(UART1_BASE, 255);
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.Movement.Stop.EmbeddedActor.input */
        /*
        ....................End updateOffset....ControlRobot.ModalModel.Reactive.Movement.Stop.EmbeddedActor.input */
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.Movement.Stop.input */
        /*
        ....................End updateOffset....ControlRobot.ModalModel.Reactive.Movement.Stop.input */
        /* The postfire of the director. */
    }
    /* The wrapup of the director. */
    while(true);
}
static void ControlRobot_ModalModel_Reactive_LCD_TaskFunction(void* arg) {
    /* The initialization of the director. */
    /* initEmbeddedActor */
    xOLEDMessage xMessage;
    unsigned portLONG ulY, ulMaxY;
    static portCHAR cMessage[ mainMAX_MSG_LEN ];
    extern volatile unsigned portLONG ulMaxJitter;
    unsigned portBASE_TYPE uxUnusedStackOnEntry;
    const unsigned portCHAR *pucImage;
    /* Functions to access the OLED.  The one used depends on the dev kit
    being used. */
    void ( *vOLEDInit )( unsigned portLONG ) = NULL;
    void ( *vOLEDStringDraw )( const portCHAR *, unsigned portLONG, unsigned portLONG, unsigned portCHAR ) = NULL;
    void ( *vOLEDImageDraw )( const unsigned portCHAR *, unsigned portLONG, unsigned portLONG, unsigned portLONG, unsigned portLONG ) = NULL;
    void ( *vOLEDClear )( void ) = NULL;
    /* Just for demo purposes. */
    uxUnusedStackOnEntry = uxTaskGetStackHighWaterMark( NULL );
    /* Map the OLED access functions to the driver functions that are appropriate
    for the evaluation kit being used. */
    switch( HWREG( SYSCTL_DID1 ) & SYSCTL_DID1_PRTNO_MASK )
    {
        case SYSCTL_DID1_PRTNO_6965 :
        case SYSCTL_DID1_PRTNO_2965 : vOLEDInit = OSRAM128x64x4Init;
        vOLEDStringDraw = OSRAM128x64x4StringDraw;
        vOLEDImageDraw = OSRAM128x64x4ImageDraw;
        vOLEDClear = OSRAM128x64x4Clear;
        ulMaxY = mainMAX_ROWS_64;
        pucImage = pucBasicBitmap;
        break;
        case SYSCTL_DID1_PRTNO_1968 :
        case SYSCTL_DID1_PRTNO_8962 : vOLEDInit = RIT128x96x4Init;
        vOLEDStringDraw = RIT128x96x4StringDraw;
        vOLEDImageDraw = RIT128x96x4ImageDraw;
        vOLEDClear = RIT128x96x4Clear;
        ulMaxY = mainMAX_ROWS_96;
        pucImage = pucBasicBitmap;
        break;
        default : vOLEDInit = vFormike128x128x16Init;
        vOLEDStringDraw = vFormike128x128x16StringDraw;
        vOLEDImageDraw = vFormike128x128x16ImageDraw;
        vOLEDClear = vFormike128x128x16Clear;
        ulMaxY = mainMAX_ROWS_128;
        pucImage = pucGrLibBitmap;
        break;
    }
    ulY = ulMaxY;
    /* Initialise the OLED and display a startup message. */
    vOLEDInit( ulSSI_FREQUENCY );
    vOLEDStringDraw( "Running OpenRTOS", 0, 0, mainFULL_SCALE );
    vOLEDImageDraw( pucImage, 0, mainCHARACTER_HEIGHT + 1, bmpBITMAP_WIDTH, bmpBITMAP_HEIGHT );
    while (true) {
        /* The firing of the StaticSchedulingDirector */
        /* Fire EmbeddedActor */
        /* Wait for a message to arrive that requires displaying. */
        xQueueReceive( xOLEDQueue, &xMessage, portMAX_DELAY );
        
        /* Write the message on the next available row. */
        ulY += mainCHARACTER_HEIGHT;
        if( ulY >= ulMaxY )
        {
            ulY = mainCHARACTER_HEIGHT;
            vOLEDClear();
            vOLEDStringDraw( "Live Demo", 0, 0, mainFULL_SCALE );
        }
        /* Display the message along with the maximum jitter time from the
        high priority time test. */
        sprintf( cMessage, "%s [%uns]", xMessage.pcMessage, ulMaxJitter * mainNS_PER_CLOCK );
        vOLEDStringDraw( cMessage, 0, ulY, mainFULL_SCALE );
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.LCD.EmbeddedActor.input */
        /* The postfire of the director. */
    }
    /* The wrapup of the director. */
    while(true);
}
static void ControlRobot_ModalModel_Reactive_WebServ_TaskFunction(void* arg) {
    /* The initialization of the director. */
    /* initEmbeddedActor */
    portBASE_TYPE i;
    uip_ipaddr_t xIPAddr;
    struct timer periodic_timer, arp_timer;
    extern void ( vEMAC_ISR )( void );
    char msg[25];
    xOLEDMessage xMessage;
    xMessage.pcMessage = msg;
    /* Enable/Reset the Ethernet Controller */
    SysCtlPeripheralEnable( SYSCTL_PERIPH_ETH );
    SysCtlPeripheralReset( SYSCTL_PERIPH_ETH );
    /* Create the semaphore used by the ISR to wake this task. */
    vSemaphoreCreateBinary( xEMACSemaphore );
    /* Initialise the uIP stack. */
    timer_set( &periodic_timer, configTICK_RATE_HZ / 2 );
    timer_set( &arp_timer, configTICK_RATE_HZ * 10 );
    uip_init();
    uip_ipaddr( xIPAddr, uipIP_ADDR0, uipIP_ADDR1, uipIP_ADDR2, uipIP_ADDR3 );
    uip_sethostaddr( xIPAddr );
    httpd_init();
    while( vInitEMAC() != pdPASS ) {
        vTaskDelay( uipINIT_WAIT );
    }
    prvSetMACAddress();
    while (true) {
        /* The firing of the StaticSchedulingDirector */
        /* Fire EmbeddedActor */
        /* Is there received data ready to be processed? */
        uip_len = uiGetEMACRxData( uip_buf );
        if( uip_len > 0 ) {
            /* Standard uIP loop taken from the uIP manual. */
            if( xHeader->type == htons( UIP_ETHTYPE_IP ) )
            {
                uip_arp_ipin();
                uip_input();
                /* If the above function invocation resulted in data that
                should be sent out on the network, the global variable
                uip_len is set to a value > 0. */
                if( uip_len > 0 )
                {
                    uip_arp_out();
                    prvENET_Send();
                }
            }
            else if( xHeader->type == htons( UIP_ETHTYPE_ARP ) )
            {
                uip_arp_arpin();
                /* If the above function invocation resulted in data that
                should be sent out on the network, the global variable
                uip_len is set to a value > 0. */
                if( uip_len > 0 )
                {
                    prvENET_Send();
                }
            }
        } else {
            if( timer_expired( &periodic_timer ) )
            {
                timer_reset( &periodic_timer );
                for( i = 0; i < UIP_CONNS; i++ )
                {
                    uip_periodic( i );
                    /* If the above function invocation resulted in data that
                    should be sent out on the network, the global variable
                    uip_len is set to a value > 0. */
                    if( uip_len > 0 )
                    {
                        uip_arp_out();
                        prvENET_Send();
                    }
                }
                /* Call the ARP timer function every 10 seconds. */
                if( timer_expired( &arp_timer ) )
                {
                    timer_reset( &arp_timer );
                    uip_arp_timer();
                }
            }
            else
            {
                /* We did not receive a packet, and there was no periodic
                processing to perform.  Block for a fixed period.  If a packet
                is received during this period we will be woken by the ISR
                giving us the Semaphore. */
                xSemaphoreTake( xEMACSemaphore, configTICK_RATE_HZ / 2 );
            }
        }
        sprintf(msg, "Webserver");
        xQueueSend( xOLEDQueue, &xMessage, 100);
        /*
        ....................Begin updateOffset....ControlRobot.ModalModel.Reactive.WebServ.EmbeddedActor.trigger */
        /*
        ....................Begin updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.WebServ.EmbeddedActor.output */
        /*
        ....................End updateConnectedPortsOffset....ControlRobot.ModalModel.Reactive.WebServ.EmbeddedActor.output */
        /* The postfire of the director. */
    }
    /* The wrapup of the director. */
    while(true);
}
static int ControlRobot_ModalModel__currentConfiguration;
static void ControlRobot_ModalModel_TaskFunction(void* arg) {
    /* The initialization of the director. */
    ControlRobot_ModalModel__Controller__currentState = STATE_ControlRobot_ModalModel__Controller_Init;
    /* The initialization of the director. */
    /* The initialization of the director. */
    /* initEmbeddedActor */
    //char msg[15];
    //xOLEDMessage xMessage;
    //xMessage.pcMessage = msg;
    /* Initialization code of the PNDirector. */
    prvSetupHardware();
    ControlRobot_ModalModel_Reactive_Movement_Stop_input_0_queue = xQueueCreate(1, sizeof( boolean ));
    ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_input_0_queue = xQueueCreate(1, sizeof( boolean ));
    ControlRobot_ModalModel_Reactive_Movement_Turn_input_0_queue = xQueueCreate(1, sizeof( boolean ));
    ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_input_0_queue = xQueueCreate(1, sizeof( boolean ));
    ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_input_0_queue = xQueueCreate(1, sizeof( boolean ));
    ControlRobot_ModalModel__currentConfiguration = 0;
    switch (ControlRobot_ModalModel__Controller__currentState) {
        case 0:
        /* Fire Composite Init */
        /* Fire Composite Actor: Init */
        /* The firing of the StaticSchedulingDirector */
        /* Fire Composite Init */
        /* Fire Composite Actor: Init */
        /* The firing of the StaticSchedulingDirector */
        /* Fire EmbeddedActor */
        //acquire mutex;
        // Send UART control signals.
        // Start.
        UARTCharPut(UART1_BASE, 128);
        vTaskDelay( (portTickType) 500);
        // Full Mode.
        UARTCharPut(UART1_BASE, 132);
        
        // Turn on LEDs.
        UARTCharPut(UART1_BASE, 139);
        UARTCharPut(UART1_BASE, 10);
        UARTCharPut(UART1_BASE, 127);
        UARTCharPut(UART1_BASE, 255);
        vTaskDelay( (portTickType) 200);
        // Drive straight.
        UARTCharPut(UART1_BASE, 137);
        UARTCharPut(UART1_BASE, 8);
        UARTCharPut(UART1_BASE, 0);
        UARTCharPut(UART1_BASE, 0);
        UARTCharPut(UART1_BASE, 0);
        // Request Streaming data.
        UARTCharPut(UART1_BASE, 148);
        UARTCharPut(UART1_BASE, 2);
        UARTCharPut(UART1_BASE, 18);	// Buttons (bit 0 for Play, bit 2 for Advance)
        UARTCharPut(UART1_BASE, 37);	// Song Playing
        //sprintf(msg, "Activate Robot...");
        //xQueueSend( xOLEDQueue, &xMessage, 100);
        break;
        case 1:
        /* Fire Composite Reactive */
        /* Fire Composite Actor: Reactive */
        /* Create a task for each actor. */
        xTaskCreate(ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_TaskFunction, "UploadSong", 100, NULL, 0, task_ControlRobot_ModalModel_Reactive_PlayMidi_UploadSong_TaskFunction);
        xTaskCreate(ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_TaskFunction, "PlaySong", 100, NULL, 0, task_ControlRobot_ModalModel_Reactive_PlayMidi_PlaySong_TaskFunction);
        xTaskCreate(ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_TaskFunction, "InitialToken", 80, NULL, 0, task_ControlRobot_ModalModel_Reactive_PlayMidi_InitialToken_TaskFunction);
        xTaskCreate(ControlRobot_ModalModel_Reactive_Movement_Buttons_TaskFunction, "Buttons", 150, NULL, 0, task_ControlRobot_ModalModel_Reactive_Movement_Buttons_TaskFunction);
        xTaskCreate(ControlRobot_ModalModel_Reactive_Movement_Turn_TaskFunction, "Turn", 100, NULL, 0, task_ControlRobot_ModalModel_Reactive_Movement_Turn_TaskFunction);
        xTaskCreate(ControlRobot_ModalModel_Reactive_Movement_Stop_TaskFunction, "Stop", 100, NULL, 0, task_ControlRobot_ModalModel_Reactive_Movement_Stop_TaskFunction);
        xTaskCreate(ControlRobot_ModalModel_Reactive_LCD_TaskFunction, "LCD", 125, NULL, 0, task_ControlRobot_ModalModel_Reactive_LCD_TaskFunction);
        xTaskCreate(ControlRobot_ModalModel_Reactive_WebServ_TaskFunction, "WebServ", mainBASIC_WEB_STACK_SIZE + 25, NULL, 0, task_ControlRobot_ModalModel_Reactive_WebServ_TaskFunction);
        vTaskStartScheduler();
        break;
    }
    /* MultirateFSMDirector: Nonpreemptive Transition. */
    ControlRobot_ModalModel__Controller__transitionFlag = 1;
    switch (ControlRobot_ModalModel__Controller__currentState) {
        case STATE_ControlRobot_ModalModel__Controller_Init:
        {
            ControlRobot_ModalModel__Controller__currentState = STATE_ControlRobot_ModalModel__Controller_Reactive;
            ControlRobot_ModalModel__currentConfiguration = 1;
        }
        break;
        case STATE_ControlRobot_ModalModel__Controller_Reactive:
        ControlRobot_ModalModel__Controller__transitionFlag = 0;
        ControlRobot_ModalModel__currentConfiguration = 1;
        break;
    }
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The postfire of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    while(true);
}
void initialize(void) {
    /* Initialization code of the PNDirector. */
    prvSetupHardware();
}
void wrapup(void) {
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
    /* The wrapup of the director. */
}
int main(int argc, char *argv[]) {
    //FIXME: CCodeGenerator hack
    init();
    initialize();
    /* Create a task for each actor. */
    xTaskCreate(ControlRobot_ModalModel_TaskFunction, "ModalModel", 150, NULL, 0, task_ControlRobot_ModalModel_TaskFunction);
    vTaskStartScheduler();
    exit(0);
}
