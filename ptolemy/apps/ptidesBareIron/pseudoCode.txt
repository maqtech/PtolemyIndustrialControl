Hi Shanna,
The following is the detailed pseudo code I came up with. There are many delicate issues as to when interrupts should be disabled, and there might still be many concurrency issues which would prove problematic for this version of pseudo code. But I thought at any rate this is a good start. Let me know if you have any questions.

Jia

main(){
    // Post initial events.
    initializeAllActors();

    // Process the initial events.
    processEvents();
}

initializeAllActor() {
    for (each source actor s) {
        // The buffer size at the output of this
        // actor is initially 0.
        s.bufferSize = 0;
        // This actor is of type SOURCE actor
        s.type = SOURCE;
        // Fire the source actor one to ensure the
        // buffer size is never 0. During the
        // execution of the model, the buffer size
        // should never become 0.
        s.fire();
        // After the firing of the source actor
        // the buffer size at the output of this
        // actor has increased.
        s.bufferSize += NumEventsAdded;
    }
}

sensorInterrupt(thisSensor){
    disableInterrupt();
    // Sensor may post more events.
    thisSensor.fire();
    enableInterrupt();
    // Decide if we want to keep processing
    // within the ISR
    startProcessing();
    // If processEvents() is currently trying
    // to fill the output buffer of source
    // actors, go back to the start of
    // while(TRUE) in processEvents().
    stopSourceProcess = TRUE;
}

timedInterrupt(){
    // Decide if we want to keep processing
    // within the ISR
    startProcessing();
    // When timed interrupts occur, the event
    // at the top of the event queue is now
    // safe to process. Since processEvents()
    // runs without terminating, this interrupt
    // will merely wakeup processEvents().
    // If the processEvents is trying to fill
    // the buffer at the output of source
    // actor, then go back to the start of
    // while(TRUE) loop.
    stopSourceProcess = TRUE;
}

processEvents(){
    while (TRUE) {
        disableInterrupt();
        // If event queue is not empty.
        if (queueEmpty() == FALSE) {
            event = peek();
            processTime = safeToProcess(event);
            if (currentRealTime >= processTime) {
                dequeue();
                enableInterrupt();
                // Execute the event. During
                // this process more events may
                // be posted to the queue.
                execute(event);
                // Check which actor produced the
                // event that we have processed
                actor a = event.actorFrom();
                // If the event just executed is
                // produced by a source actor
                if (a.type == SOURCE) {
                    // Decrement the buffer size
                    // by one.
                    a.bufferSize--;
                    // Make sure sourceBuffer is
                    // non-empty. If it is, fire
                    // the source actor once to
                    // produce some events.
                    if (a.bufferSize == 0) {
                        a.fire();
                        a.bufferSize +=
                            NumEventsAdded;
                    }
                }
            }
            else {
                // There are no events safe to
                // process, so setup sources
                // to process.
                stopSourceProcess = FALSE;
                // Set timed interrupt to run
                // the event at the top of the
                // event queue when physical time
                // has passed for it to be
                // safe to process
                setTimedInterrupt(processTime);
                enableInterrupt();
            }
        } else {
            // There are no events safe to
            // process, so setup sources
            // to process.
            stopSourceProcess = FALSE;
            enableInterrupt();
        }
        // If there is no event to process and we
        // have not reached the buffer limit, fire
        // the source actor.
        for (each source actors a) {
            if (stopSourceProcess == FALSE &&
              a.bufferSize < a.MAX_BUFFER_LIMIT) {
                a.fire();
                a.bufferSize += NumEventsAdded;
            }
        }
    }
}

startProcessing() {
    // If EDF is to be combined with PTIDES,
    // then event queue should be sorted by deadlines
    // and processEvent() would ensure the event of
    // smallest time stamp is processed.
}

safeToProcess(Event event) {
    // Figures out if events are safe to process by
    // making sure current actor could be fired AND
    // when in physical time could the event be processed.
}