<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<title>Static Call Graph - [.\rvmdk\enet_ptpd.axf]</title></head>
<body><HR>
<H1>Static Call Graph for image .\rvmdk\enet_ptpd.axf</H1><HR>
<BR><P>#&#060CALLGRAPH&#062# ARM Linker, RVCT3.1 [Build 934]: Last Updated: Fri Nov 07 13:42:20 2008
<BR><P>
<H3>Maximum Stack Usage =        440 bytes + Unknown(Functions without stacksize, Cycles, Untraceable Function Pointers)</H3><H3>
Call chain for Maximum Stack Depth:</H3>
main &rArr; ptpd_init &rArr; protocol_first &rArr; doState &rArr; handle &rArr; handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
<P>
<H3>
Functions with no stack information
</H3><UL>
 <LI><a href="#[1008a48]">Reset_Handler</a>
 <LI><a href="#[10c1c58]">CPUcpsid</a>
 <LI><a href="#[10c1c10]">CPUcpsie</a>
 <LI><a href="#[10c1bc8]">CPUwfi</a>
 <LI><a href="#[1008c88]">NmiSR</a>
 <LI><a href="#[1008c40]">FaultISR</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
</UL>
</UL>
<P>
<H3>
Mutually Recursive functions
</H3> <LI><a href="#[10faf00]">SSIDataPut</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[10faf00]">SSIDataPut</a><BR>
 <LI><a href="#[10faf90]">SSIDataGet</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[10faf90]">SSIDataGet</a><BR>
 <LI><a href="#[b56928]">DiagExit</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[b56928]">DiagExit</a><BR>
 <LI><a href="#[b5eb68]">netif_set_netmask</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[b5eb68]">netif_set_netmask</a><BR>
 <LI><a href="#[b5ebf8]">netif_set_gw</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[b5ebf8]">netif_set_gw</a><BR>
 <LI><a href="#[10f4b68]">SysCtlDelay</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[10f4b68]">SysCtlDelay</a><BR>
 <LI><a href="#[1008c88]">NmiSR</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[1008c88]">NmiSR</a><BR>
 <LI><a href="#[1008c40]">FaultISR</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[1008c40]">FaultISR</a><BR>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[1008bf8]">IntDefaultHandler</a><BR>
</UL>
<P>
<H3>
Function Pointers
</H3><UL>
 <LI><a href="#[1008a48]">Reset_Handler</a>
 <LI><a href="#[1008c88]">NmiSR</a>
 <LI><a href="#[1008c40]">FaultISR</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[b56c88]">SysTickIntHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[b5a550]">EthernetIntHandler</a>
 <LI><a href="#[1008bf8]">IntDefaultHandler</a>
 <LI><a href="#[b5a160]">ip_input</a>
 <LI><a href="#[b5a238]">ethernetif_init</a>
 <LI><a href="#[b56b20]">main</a>
</UL>
<P>
<H3>
Global Symbols
</H3>
<P><STRONG><a name="[1008a48]"></a>Reset_Handler</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, startup_rvmdk.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[10c1478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[10c1478]"></a>__main</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, entry.o($$startup$$))
<BR><BR>[Calls]<UL><LI><a href="#[10c0010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__init
</UL>
<BR>[Called By]<UL><LI><a href="#[1008a48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Reset_Handler
</UL>

<P><STRONG><a name="[10f4b68]"></a>SysCtlDelay</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, sysctl.o(.emb_text))
<BR><BR>[Calls]<UL><LI><a href="#[10f4b68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[10f43d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlClockSet
<LI><a href="#[10f4b68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlDelay
</UL>

<P><STRONG><a name="[10c0058]"></a>__call_main</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, init.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[10c0010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__init
</UL>

<P><STRONG><a name="[b62aa8]"></a>crc_algorithm</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, arith.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = crc_algorithm
</UL>
<BR>[Called By]<UL><LI><a href="#[fc28a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lookupSubdomainAddress
</UL>

<P><STRONG><a name="[b62a60]"></a>sum</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, arith.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc6b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleManagement
</UL>

<P><STRONG><a name="[b62a18]"></a>fromInternalTime</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, arith.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc6600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackManagementResponse
<LI><a href="#[fc6888]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueSync
<LI><a href="#[fc6960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayReq
<LI><a href="#[fc69f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueFollowup
<LI><a href="#[fc6ac8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayResp
</UL>

<P><STRONG><a name="[b629d0]"></a>toInternalTime</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, arith.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = toInternalTime
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnloadManagement
<LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc6a38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleFollowUp
<LI><a href="#[fc6b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayResp
</UL>

<P><STRONG><a name="[b62988]"></a>normalizeTime</STRONG> (Thumb, 62 bytes, Stack size 12 bytes, arith.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = normalizeTime
</UL>
<BR>[Called By]<UL><LI><a href="#[b628f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;subTime
<LI><a href="#[b62940]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addTime
</UL>

<P><STRONG><a name="[b62940]"></a>addTime</STRONG> (Thumb, 22 bytes, Stack size 4 bytes, arith.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = addTime &rArr; normalizeTime
</UL>
<BR>[Calls]<UL><LI><a href="#[b62988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;normalizeTime
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6060]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateDelay
<LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc6a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayReq
</UL>

<P><STRONG><a name="[b628f8]"></a>subTime</STRONG> (Thumb, 22 bytes, Stack size 4 bytes, arith.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = subTime &rArr; normalizeTime
</UL>
<BR>[Calls]<UL><LI><a href="#[b62988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;normalizeTime
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6018]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateOffset
<LI><a href="#[fc6060]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateDelay
<LI><a href="#[fc60a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateClock
<LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[b61878]"></a>initData</STRONG> (Thumb, 134 bytes, Stack size 24 bytes, bmc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = initData
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
</UL>

<P><STRONG><a name="[b61830]"></a>m1</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, bmc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = m1
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b61680]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmc
<LI><a href="#[b616c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcStateDecision
<LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
<LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
</UL>

<P><STRONG><a name="[b617e8]"></a>s1</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, bmc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = s1
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b616c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcStateDecision
<LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
</UL>

<P><STRONG><a name="[b617a0]"></a>copyD0</STRONG> (Thumb, 108 bytes, Stack size 24 bytes, bmc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = copyD0
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b616c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcStateDecision
</UL>

<P><STRONG><a name="[b61758]"></a>getIdentifierOrder</STRONG> (Thumb, 98 bytes, Stack size 8 bytes, bmc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = getIdentifierOrder &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[b61710]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcDataSetComparison
</UL>

<P><STRONG><a name="[b61710]"></a>bmcDataSetComparison</STRONG> (Thumb, 450 bytes, Stack size 48 bytes, bmc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = bmcDataSetComparison &rArr; getIdentifierOrder &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[b61758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getIdentifierOrder
<LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[b61680]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmc
<LI><a href="#[b616c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcStateDecision
</UL>

<P><STRONG><a name="[b616c8]"></a>bmcStateDecision</STRONG> (Thumb, 116 bytes, Stack size 32 bytes, bmc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 100<LI>Call Chain = bmcStateDecision &rArr; bmcDataSetComparison &rArr; getIdentifierOrder &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[b61710]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcDataSetComparison
<LI><a href="#[b617a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;copyD0
<LI><a href="#[b617e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;s1
<LI><a href="#[b61830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;m1
</UL>
<BR>[Called By]<UL><LI><a href="#[b61680]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmc
</UL>

<P><STRONG><a name="[b61680]"></a>bmc</STRONG> (Thumb, 120 bytes, Stack size 32 bytes, bmc.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = bmc &rArr; bmcStateDecision &rArr; bmcDataSetComparison &rArr; getIdentifierOrder &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[b616c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcStateDecision
<LI><a href="#[b61710]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcDataSetComparison
<LI><a href="#[b61830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;m1
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
</UL>

<P><STRONG><a name="[b5f0c0]"></a>dhcp_renew</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = dhcp_renew &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5fe88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option
<LI><a href="#[b5fed0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_byte
<LI><a href="#[b5ff18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_delete_request
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[b60278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_short
<LI><a href="#[b60308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_trailer
</UL>
<BR>[Called By]<UL><LI><a href="#[b5f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_coarse_tmr
<LI><a href="#[b5fdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_timeout
</UL>

<P><STRONG><a name="[b5f078]"></a>dhcp_coarse_tmr</STRONG> (Thumb, 88 bytes, Stack size 8 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = dhcp_coarse_tmr &rArr; dhcp_rebind &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
</UL>

<P><STRONG><a name="[b5f030]"></a>dhcp_release</STRONG> (Thumb, 190 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 252 + Unknown Stack Size
<LI>Call Chain = dhcp_release &rArr; netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5eb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_netmask
<LI><a href="#[b5ebb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
<LI><a href="#[b5ebf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_gw
<LI><a href="#[b5ec40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_down
<LI><a href="#[b5fe88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option
<LI><a href="#[b5fed0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_byte
<LI><a href="#[b5ff18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_delete_request
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[b60308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_trailer
</UL>
<BR>[Called By]<UL><LI><a href="#[b5fdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_timeout
</UL>

<P><STRONG><a name="[b5efe8]"></a>dhcp_fine_tmr</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 284 + Unknown Stack Size
<LI>Call Chain = dhcp_fine_tmr &rArr; dhcp_timeout &rArr; dhcp_bind &rArr; netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5fdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_timeout
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
</UL>

<P><STRONG><a name="[b5efa0]"></a>dhcp_stop</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = dhcp_stop &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[b60080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_free_reply
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[b5ef58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_start
</UL>

<P><STRONG><a name="[b5ef58]"></a>dhcp_start</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = dhcp_start &rArr; dhcp_discover &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new
<LI><a href="#[b5ecd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[b5efa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_stop
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[10c0db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[b5ef10]"></a>dhcp_inform</STRONG> (Thumb, 172 bytes, Stack size 16 bytes, dhcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[b5e898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
<LI><a href="#[b5e928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5ecd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[b5fe88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option
<LI><a href="#[b5fed0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_byte
<LI><a href="#[b5ff18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_delete_request
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[b60278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_short
<LI><a href="#[b60308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_trailer
<LI><a href="#[10c0db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>

<P><STRONG><a name="[b5eec8]"></a>dhcp_arp_reply</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = dhcp_arp_reply &rArr; dhcp_decline &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
</UL>
<BR>[Called By]<UL><LI><a href="#[b53bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_arp_input
</UL>

<P><STRONG><a name="[b5a550]"></a>EthernetIntHandler</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, enet_lwip.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 152 + Unknown Stack Size
<LI>Call Chain = EthernetIntHandler &rArr; ethernetif_enqueue &rArr; low_level_input &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5a280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_enqueue
<LI><a href="#[1098f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntStatus
<LI><a href="#[1099000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntDisable
<LI><a href="#[1099048]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntClear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_rvmdk.o(RESET)
</UL>
<P><STRONG><a name="[b5a508]"></a>lwip_init</STRONG> (Thumb, 132 bytes, Stack size 32 bytes, enet_lwip.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 308 + Unknown Stack Size
<LI>Call Chain = lwip_init &rArr; netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b59e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_init
<LI><a href="#[b59ed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_init
<LI><a href="#[b59f68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;stats_init
<LI><a href="#[b59fb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_init
<LI><a href="#[b59ff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_default
<LI><a href="#[b5a040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_init
<LI><a href="#[b5a088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_add
<LI><a href="#[b5a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_init
<LI><a href="#[b5a118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_init
<LI><a href="#[b5a1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_init
<LI><a href="#[b5a358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_init
<LI><a href="#[b5a3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4StringDraw
<LI><a href="#[b5eb20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_up
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[b5ef58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_start
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b5a4c0]"></a>lwip_tick</STRONG> (Thumb, 416 bytes, Stack size 40 bytes, enet_lwip.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 324 + Unknown Stack Size
<LI>Call Chain = lwip_tick &rArr; dhcp_fine_tmr &rArr; dhcp_timeout &rArr; dhcp_bind &rArr; netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[b59f20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_fasttmr
<LI><a href="#[b5a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_dequeue
<LI><a href="#[b5a310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_tmr
<LI><a href="#[b5a3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4StringDraw
<LI><a href="#[b5c170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_display_address
<LI><a href="#[b5eb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_netmask
<LI><a href="#[b5ebb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
<LI><a href="#[b5ebf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_gw
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[b5efa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_stop
<LI><a href="#[b5efe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_fine_tmr
<LI><a href="#[b5f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_coarse_tmr
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b56c88]"></a>SysTickIntHandler</STRONG> (Thumb, 144 bytes, Stack size 24 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = SysTickIntHandler
</UL>
<BR>[Calls]<UL><LI><a href="#[b55d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerTick
<LI><a href="#[108e9a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinWrite
<LI><a href="#[10cdc28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickPeriodSet
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_rvmdk.o(RESET)
</UL>
<P><STRONG><a name="[b56c40]"></a>ptpd_systick_init</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = ptpd_systick_init &rArr; SysCtlClockGet
</UL>
<BR>[Calls]<UL><LI><a href="#[10cdc70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickPeriodGet
<LI><a href="#[10cdd48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickIntEnable
<LI><a href="#[10cddd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickEnable
<LI><a href="#[10f4418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b56bf8]"></a>ptpd_init</STRONG> (Thumb, 220 bytes, Stack size 16 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368 + Unknown Stack Size
<LI>Call Chain = ptpd_init &rArr; protocol_first &rArr; doState &rArr; handle &rArr; handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol_first
<LI><a href="#[1098e98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetMACAddrGet
<LI><a href="#[1099168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetConfigSet
<LI><a href="#[10991b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetConfigGet
<LI><a href="#[10c0db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b56bb0]"></a>ptpd_tick</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = ptpd_tick &rArr; protocol_loop &rArr; doState &rArr; handle &rArr; handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55e30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol_loop
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b56b68]"></a>adjust_rx_timestamp</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, enet_ptpd.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b56a00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRxTime
</UL>

<P><STRONG><a name="[b56b20]"></a>main</STRONG> (Thumb, 916 bytes, Stack size 72 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 440 + Unknown Stack Size
<LI>Call Chain = main &rArr; ptpd_init &rArr; protocol_first &rArr; doState &rArr; handle &rArr; handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55d10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ulocaltime
<LI><a href="#[b55ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;httpd_init
<LI><a href="#[b55f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_init
<LI><a href="#[b55f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTStdioInit
<LI><a href="#[b563d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RandomSeed
<LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
<LI><a href="#[b56928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DiagExit
<LI><a href="#[b56bb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_tick
<LI><a href="#[b56bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_init
<LI><a href="#[b56c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_systick_init
<LI><a href="#[b59e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usprintf
<LI><a href="#[b5a3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4StringDraw
<LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
<LI><a href="#[108e9a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinWrite
<LI><a href="#[108e9f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeUART
<LI><a href="#[108ebe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeGPIOOutput
<LI><a href="#[108ec30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeGPIOInput
<LI><a href="#[108ed08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinRead
<LI><a href="#[108ee70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPadConfigSet
<LI><a href="#[108ef90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIODirModeSet
<LI><a href="#[10940a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FlashUserGet
<LI><a href="#[1098e50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetMACAddrSet
<LI><a href="#[1098fb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntEnable
<LI><a href="#[10c91c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerPrescaleSet
<LI><a href="#[10c9378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerLoadSet
<LI><a href="#[10c95b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerEnable
<LI><a href="#[10c9720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerControlEvent
<LI><a href="#[10c9768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerConfigure
<LI><a href="#[10f3d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlPeripheralReset
<LI><a href="#[10f3de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlPeripheralEnable
<LI><a href="#[10f43d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlClockSet
<LI><a href="#[10fe408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntPrioritySet
<LI><a href="#[10fe528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntMasterEnable
</UL>
<BR>[Address Reference Count : 1]<UL><LI> init.o(.text)
</UL>
<P><STRONG><a name="[b56ad8]"></a>displayStats</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, enet_ptpd.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc60a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateClock
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>

<P><STRONG><a name="[b56a90]"></a>getTime</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = getTime
</UL>
<BR>[Calls]<UL><LI><a href="#[10cdbe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickValueGet
<LI><a href="#[10cdc70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickPeriodGet
</UL>
<BR>[Called By]<UL><LI><a href="#[b56a00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRxTime
<LI><a href="#[fc60a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateClock
<LI><a href="#[fc6600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackManagementResponse
<LI><a href="#[fc6888]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueSync
<LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
<LI><a href="#[fc6960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayReq
</UL>

<P><STRONG><a name="[b56a48]"></a>setTime</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = setTime &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[fc60a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateClock
<LI><a href="#[fc6528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnloadManagement
</UL>

<P><STRONG><a name="[b56a00]"></a>getRxTime</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = getRxTime &rArr; getTime
</UL>
<BR>[Calls]<UL><LI><a href="#[b56a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getTime
<LI><a href="#[b56b68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adjust_rx_timestamp
<LI><a href="#[10c90a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerValueGet
</UL>
<BR>[Called By]<UL><LI><a href="#[f81000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_input
</UL>

<P><STRONG><a name="[b569b8]"></a>getRand</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = getRand &rArr; RandomSeed
</UL>
<BR>[Calls]<UL><LI><a href="#[b563d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RandomSeed
<LI><a href="#[b56418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RandomNumber
<LI><a href="#[b56460]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RandomAddEntropy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>

<P><STRONG><a name="[b56970]"></a>adjFreq</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, enet_ptpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = adjFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[fc60a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateClock
<LI><a href="#[fc67b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initClock
</UL>

<P><STRONG><a name="[b5a358]"></a>etharp_init</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, etharp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = etharp_init
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_init
<LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[b5a310]"></a>etharp_tmr</STRONG> (Thumb, 90 bytes, Stack size 32 bytes, etharp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = etharp_tmr &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[f80f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;arp_timer
</UL>

<P><STRONG><a name="[b53c58]"></a>etharp_find_addr</STRONG> (Thumb, 70 bytes, Stack size 20 bytes, etharp.o(.text), UNUSED)

<P><STRONG><a name="[b53c10]"></a>etharp_ip_input</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, etharp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = etharp_ip_input &rArr; update_arp_entry &rArr; find_entry &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b54948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_arp_entry
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_dequeue
<LI><a href="#[f80f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_input
</UL>

<P><STRONG><a name="[b53bc8]"></a>etharp_arp_input</STRONG> (Thumb, 262 bytes, Stack size 40 bytes, etharp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = etharp_arp_input &rArr; dhcp_arp_reply &rArr; dhcp_decline &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b54948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_arp_entry
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5eec8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_arp_reply
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_dequeue
<LI><a href="#[f80f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_input
</UL>

<P><STRONG><a name="[f90a58]"></a>etharp_request</STRONG> (Thumb, 210 bytes, Stack size 24 bytes, etharp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104 + Unknown Stack Size
<LI>Call Chain = etharp_request &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
</UL>

<P><STRONG><a name="[b5ee38]"></a>etharp_query</STRONG> (Thumb, 228 bytes, Stack size 40 bytes, etharp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = etharp_query &rArr; pbuf_take &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b54990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;find_entry
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f907d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take
<LI><a href="#[f90818]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[f90980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_addr_isbroadcast
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
<LI><a href="#[f90a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_request
</UL>
<BR>[Called By]<UL><LI><a href="#[b60350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_check
<LI><a href="#[f90a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_output
</UL>

<P><STRONG><a name="[f90a10]"></a>etharp_output</STRONG> (Thumb, 224 bytes, Stack size 32 bytes, etharp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f90980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_addr_isbroadcast
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Called By]<UL><LI><a href="#[f80fb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_output
</UL>

<P><STRONG><a name="[b55ec0]"></a>httpd_init</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, httpd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 252 + Unknown Stack Size
<LI>Call Chain = httpd_init &rArr; tcp_new &rArr; tcp_alloc &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8e018]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_new
<LI><a href="#[f8e060]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen
<LI><a href="#[f8e138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_bind
<LI><a href="#[f8e1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_accept
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[f8bf48]"></a>icmp_input</STRONG> (Thumb, 280 bytes, Stack size 40 bytes, icmp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 92 + Unknown Stack Size
<LI>Call Chain = icmp_input &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f8bde0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output_if
<LI><a href="#[f8be70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pbuf
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f90980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_addr_isbroadcast
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
</UL>

<P><STRONG><a name="[f8bf00]"></a>icmp_dest_unreach</STRONG> (Thumb, 130 bytes, Stack size 32 bytes, icmp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124 + Unknown Stack Size
<LI>Call Chain = icmp_dest_unreach &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[f8be28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output
<LI><a href="#[f8beb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
<LI><a href="#[f87d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
</UL>

<P><STRONG><a name="[f909c8]"></a>htons</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, inet.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b53bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_arp_input
<LI><a href="#[b54948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_arp_entry
<LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
<LI><a href="#[b5a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_dequeue
<LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
<LI><a href="#[f80f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_input
<LI><a href="#[f8bde0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output_if
<LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f90a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_output
<LI><a href="#[f90a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_request
<LI><a href="#[1000c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[1004588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
</UL>

<P><STRONG><a name="[f8aaf8]"></a>inet_chksum_pseudo</STRONG> (Thumb, 138 bytes, Stack size 28 bytes, inet.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = inet_chksum_pseudo &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8b248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_standard_chksum
</UL>
<BR>[Called By]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[f87d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[1000c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[1004588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
</UL>

<P><STRONG><a name="[f8beb8]"></a>inet_chksum</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, inet.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8b248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_standard_chksum
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
<LI><a href="#[f8bde0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output_if
<LI><a href="#[f8bf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
</UL>

<P><STRONG><a name="[f8be70]"></a>inet_chksum_pbuf</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, inet.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = inet_chksum_pbuf &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8b248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_standard_chksum
</UL>
<BR>[Called By]<UL><LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
</UL>

<P><STRONG><a name="[b5edf0]"></a>htonl</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, inet.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
<LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
<LI><a href="#[b600c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_handle_ack
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[1000c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[1002d70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[1004588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[10046f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
</UL>

<P><STRONG><a name="[f8aab0]"></a>inet_aton</STRONG> (Thumb, 252 bytes, Stack size 36 bytes, inet.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = inet_aton
</UL>
<BR>[Called By]<UL><LI><a href="#[f8aa68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_addr
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[f8aa68]"></a>inet_addr</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, inet.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f8aab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_aton
</UL>

<P><STRONG><a name="[f8aa20]"></a>inet_ntoa</STRONG> (Thumb, 86 bytes, Stack size 28 bytes, inet.o(.text), UNUSED)

<P><STRONG><a name="[f908f0]"></a>ntohs</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, inet.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b53bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_arp_input
<LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
<LI><a href="#[f87d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f87de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_input
<LI><a href="#[f8bde0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output_if
<LI><a href="#[f8bf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f90a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_request
<LI><a href="#[1002e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_parseopt
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[1004588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
</UL>

<P><STRONG><a name="[b5ead8]"></a>ntohl</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, inet.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b54948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_arp_entry
<LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
<LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
<LI><a href="#[f87d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f90a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_output
<LI><a href="#[1000c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[1001f18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit
<LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[1004540]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit_rto
</UL>

<P><STRONG><a name="[b5a1a8]"></a>ip_init</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, ip.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[f87ec0]"></a>ip_route</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, ip.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = ip_route
</UL>
<BR>[Called By]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[f8be28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output
<LI><a href="#[1000c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[100a838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_sendto
</UL>

<P><STRONG><a name="[b5a160]"></a>ip_input</STRONG> (Thumb, 434 bytes, Stack size 32 bytes, ip.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 348 + Unknown Stack Size
<LI>Call Chain = ip_input &rArr; tcp_input &rArr; tcp_listen_input &rArr; tcp_alloc &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f87d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f87de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_input
<LI><a href="#[f87e30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_is_up
<LI><a href="#[f8beb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[f8bf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f90980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_addr_isbroadcast
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Address Reference Count : 1]<UL><LI> enet_lwip.o(.text)
</UL>
<P><STRONG><a name="[f8bde0]"></a>ip_output_if</STRONG> (Thumb, 210 bytes, Stack size 40 bytes, ip.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8beb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Called By]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[f8be28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output
<LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[100a838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_sendto
</UL>

<P><STRONG><a name="[f8be28]"></a>ip_output</STRONG> (Thumb, 62 bytes, Stack size 40 bytes, ip.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 92<LI>Call Chain = ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f87ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_route
<LI><a href="#[f8bde0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output_if
</UL>
<BR>[Called By]<UL><LI><a href="#[f8bf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[1000c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[1004588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
</UL>

<P><STRONG><a name="[f90980]"></a>ip_addr_isbroadcast</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, ip_addr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b54948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_arp_entry
<LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
<LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
<LI><a href="#[f87d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[f90a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_output
</UL>

<P><STRONG><a name="[b55f08]"></a>fs_init</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, lmi_fs.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[f84920]"></a>fs_tick</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, lmi_fs.o(.text), UNUSED)

<P><STRONG><a name="[f8e2e8]"></a>fs_open</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, lmi_fs.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ecd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[10c0430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncmp
<LI><a href="#[10c0870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strchr
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_recv
</UL>

<P><STRONG><a name="[f8e330]"></a>fs_close</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, lmi_fs.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;send_data
<LI><a href="#[f8f338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close_conn
<LI><a href="#[f8f380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;conn_err
</UL>

<P><STRONG><a name="[f8e2a0]"></a>fs_read</STRONG> (Thumb, 188 bytes, Stack size 56 bytes, lmi_fs.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b55d10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ulocaltime
<LI><a href="#[b59e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usprintf
<LI><a href="#[10c0430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncmp
<LI><a href="#[10c0708]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[10c0b50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strstr
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;send_data
</UL>

<P><STRONG><a name="[f81090]"></a>low_level_init</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, luminaryif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = low_level_init &rArr; SysCtlClockGet
</UL>
<BR>[Calls]<UL><LI><a href="#[1098f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntStatus
<LI><a href="#[1098fb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntEnable
<LI><a href="#[1099000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntDisable
<LI><a href="#[1099048]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntClear
<LI><a href="#[1099090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetInitExpClk
<LI><a href="#[10990d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetEnable
<LI><a href="#[1099168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetConfigSet
<LI><a href="#[10f4418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlClockGet
<LI><a href="#[10fe5b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_init
</UL>

<P><STRONG><a name="[f81048]"></a>low_level_output</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, luminaryif.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1098c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetSpaceAvail
</UL>

<P><STRONG><a name="[f81000]"></a>low_level_input</STRONG> (Thumb, 226 bytes, Stack size 32 bytes, luminaryif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 112 + Unknown Stack Size
<LI>Call Chain = low_level_input &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b56a00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRxTime
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_enqueue
<LI><a href="#[f80f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_input
</UL>

<P><STRONG><a name="[f80fb8]"></a>ethernetif_output</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, luminaryif.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f90a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_output
</UL>

<P><STRONG><a name="[f80f70]"></a>ethernetif_input</STRONG> (Thumb, 112 bytes, Stack size 16 bytes, luminaryif.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b53bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_arp_input
<LI><a href="#[b53c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_ip_input
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[f81000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_input
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
<LI><a href="#[1098d78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetPacketAvail
</UL>

<P><STRONG><a name="[b55da0]"></a>sys_arch_unprotect</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, luminaryif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[10fe528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntMasterEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[b56a48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setTime
<LI><a href="#[b5a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_dequeue
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[f82830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enqueue_frame
<LI><a href="#[f90818]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[fc8350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_pool_alloc
<LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
</UL>

<P><STRONG><a name="[b55de8]"></a>sys_arch_protect</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, luminaryif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = sys_arch_protect &rArr; IntMasterDisable
</UL>
<BR>[Calls]<UL><LI><a href="#[10fe570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntMasterDisable
</UL>
<BR>[Called By]<UL><LI><a href="#[b56a48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setTime
<LI><a href="#[b5a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_dequeue
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[f82830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enqueue_frame
<LI><a href="#[f90818]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[fc8350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_pool_alloc
<LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
</UL>

<P><STRONG><a name="[b5a280]"></a>ethernetif_enqueue</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, luminaryif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = ethernetif_enqueue &rArr; low_level_input &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[f81000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_input
<LI><a href="#[f82830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enqueue_frame
<LI><a href="#[1098d78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetPacketAvail
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntHandler
</UL>

<P><STRONG><a name="[b5a2c8]"></a>ethernetif_dequeue</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, luminaryif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = ethernetif_dequeue &rArr; etharp_arp_input &rArr; dhcp_arp_reply &rArr; dhcp_decline &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b53bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_arp_input
<LI><a href="#[b53c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_ip_input
<LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
</UL>

<P><STRONG><a name="[f80f28]"></a>arp_timer</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, luminaryif.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5a310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_tmr
</UL>

<P><STRONG><a name="[b5a238]"></a>ethernetif_init</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, luminaryif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = ethernetif_init &rArr; mem_malloc
</UL>
<BR>[Calls]<UL><LI><a href="#[b5a358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_init
<LI><a href="#[b5ecd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
<LI><a href="#[1098e98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetMACAddrGet
</UL>
<BR>[Address Reference Count : 1]<UL><LI> enet_lwip.o(.text)
</UL>
<P><STRONG><a name="[b5a118]"></a>mem_init</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, mem.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mem_init
</UL>
<BR>[Calls]<UL><LI><a href="#[10c0e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[b5ed18]"></a>mem_free</STRONG> (Thumb, 66 bytes, Stack size 4 bytes, mem.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = mem_free &rArr; plug_holes
</UL>
<BR>[Calls]<UL><LI><a href="#[fcde38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;plug_holes
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5ef58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_start
<LI><a href="#[b5efa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_stop
<LI><a href="#[b5fdf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_unfold_reply
<LI><a href="#[b60080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_free_reply
<LI><a href="#[f8e2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_open
<LI><a href="#[f8e330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_close
<LI><a href="#[f8f338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close_conn
<LI><a href="#[f8f380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;conn_err
</UL>

<P><STRONG><a name="[fcd658]"></a>mem_realloc</STRONG> (Thumb, 128 bytes, Stack size 20 bytes, mem.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = mem_realloc &rArr; plug_holes
</UL>
<BR>[Calls]<UL><LI><a href="#[fcde38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;plug_holes
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
</UL>

<P><STRONG><a name="[b5ecd0]"></a>mem_malloc</STRONG> (Thumb, 180 bytes, Stack size 24 bytes, mem.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = mem_malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_init
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5ef58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_start
<LI><a href="#[b5fdf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_unfold_reply
<LI><a href="#[f8e2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_open
<LI><a href="#[f8f1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_accept
</UL>

<P><STRONG><a name="[b5a0d0]"></a>memp_init</STRONG> (Thumb, 100 bytes, Stack size 20 bytes, memp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = memp_init
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[fcb050]"></a>memp_malloc</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, memp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = memp_malloc &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[b5e928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[f8e060]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[1004660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
<LI><a href="#[10046a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_copy
<LI><a href="#[100a760]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_new
</UL>

<P><STRONG><a name="[fcb008]"></a>memp_free</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, memp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[b5e898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8e060]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen
<LI><a href="#[f8e0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
<LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[10048a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
<LI><a href="#[100a7a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_remove
</UL>

<P><STRONG><a name="[b5ebf8]"></a>netif_set_gw</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, netif.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[b5ebf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_gw
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[b5ebf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_gw
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
<LI><a href="#[fc9260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>

<P><STRONG><a name="[b5eb68]"></a>netif_set_netmask</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, netif.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[b5eb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_netmask
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[b5eb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_netmask
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
<LI><a href="#[fc9260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>

<P><STRONG><a name="[b5ebb0]"></a>netif_set_ipaddr</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, netif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
<LI><a href="#[fc9260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>

<P><STRONG><a name="[fc9260]"></a>netif_set_addr</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, netif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 252 + Unknown Stack Size
<LI>Call Chain = netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5eb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_netmask
<LI><a href="#[b5ebb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
<LI><a href="#[b5ebf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_gw
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_add
</UL>

<P><STRONG><a name="[b5a088]"></a>netif_add</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, netif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 276 + Unknown Stack Size
<LI>Call Chain = netif_add &rArr; netif_set_addr &rArr; netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[fc9260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[fc9218]"></a>netif_remove</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, netif.o(.text), UNUSED)

<P><STRONG><a name="[fc91d0]"></a>netif_find</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, netif.o(.text), UNUSED)

<P><STRONG><a name="[b59ff8]"></a>netif_set_default</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, netif.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[b5eb20]"></a>netif_set_up</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, netif.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
</UL>

<P><STRONG><a name="[f87e30]"></a>netif_is_up</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, netif.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
</UL>

<P><STRONG><a name="[b5ec40]"></a>netif_set_down</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, netif.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
</UL>

<P><STRONG><a name="[b5a040]"></a>netif_init</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, netif.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[b59fb0]"></a>pbuf_init</STRONG> (Thumb, 68 bytes, Stack size 12 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = pbuf_init
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[b5ea48]"></a>pbuf_free</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48 + Unknown Stack Size
<LI>Call Chain = pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
<LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b53bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_arp_input
<LI><a href="#[b54948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_arp_entry
<LI><a href="#[b54990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;find_entry
<LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
<LI><a href="#[b5a280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_enqueue
<LI><a href="#[b5a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_dequeue
<LI><a href="#[b5a310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_tmr
<LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[b5efa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_stop
<LI><a href="#[b5ff18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_delete_request
<LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
<LI><a href="#[f80f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_input
<LI><a href="#[f87d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8bf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f8f218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_recv
<LI><a href="#[f907d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take
<LI><a href="#[f90a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_request
<LI><a href="#[fc61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netShutdown
<LI><a href="#[fc62e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netRecvGeneral
<LI><a href="#[fc6330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netRecvEvent
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
<LI><a href="#[fc7930]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_dechain
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[1004588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[10048a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
<LI><a href="#[1005740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv_null
<LI><a href="#[100a838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_sendto
</UL>

<P><STRONG><a name="[b5ea90]"></a>pbuf_alloc</STRONG> (Thumb, 292 bytes, Stack size 32 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ecd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[fc8350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_pool_alloc
<LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[f81000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_input
<LI><a href="#[f8bf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f907d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take
<LI><a href="#[f90a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_request
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[1004588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[100a838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_sendto
</UL>

<P><STRONG><a name="[b5ea00]"></a>pbuf_realloc</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = pbuf_realloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[fcd658]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_realloc
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
<LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
<LI><a href="#[fc6210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendGeneral
<LI><a href="#[fc6258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendEvent
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
</UL>

<P><STRONG><a name="[f90860]"></a>pbuf_header</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = pbuf_header
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_dequeue
<LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[f80f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_input
<LI><a href="#[f87d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_input
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8bde0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output_if
<LI><a href="#[f8bf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_input
<LI><a href="#[f90a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_output
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[100a838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_sendto
</UL>

<P><STRONG><a name="[fc7a50]"></a>pbuf_clen</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, pbuf.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
</UL>

<P><STRONG><a name="[f90818]"></a>pbuf_ref</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = pbuf_ref &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
<LI><a href="#[fc7978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_queue
<LI><a href="#[fc79c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_chain
<LI><a href="#[10046a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_copy
</UL>

<P><STRONG><a name="[fc7a08]"></a>pbuf_cat</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = pbuf_cat
</UL>
<BR>[Called By]<UL><LI><a href="#[fc79c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_chain
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
</UL>

<P><STRONG><a name="[fc79c0]"></a>pbuf_chain</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = pbuf_chain &rArr; pbuf_ref &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[f90818]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[fc7a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_cat
</UL>
<BR>[Called By]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[100a838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_sendto
</UL>

<P><STRONG><a name="[fc7978]"></a>pbuf_queue</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, pbuf.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f90818]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
</UL>

<P><STRONG><a name="[f908a8]"></a>pbuf_dequeue</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, pbuf.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b54948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_arp_entry
</UL>

<P><STRONG><a name="[f907d0]"></a>pbuf_take</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 104 + Unknown Stack Size
<LI>Call Chain = pbuf_take &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
</UL>

<P><STRONG><a name="[fc7930]"></a>pbuf_dechain</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, pbuf.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>

<P><STRONG><a name="[fc6c30]"></a>toState</STRONG> (Thumb, 320 bytes, Stack size 32 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = toState &rArr; getRand &rArr; RandomSeed
</UL>
<BR>[Calls]<UL><LI><a href="#[b569b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRand
<LI><a href="#[b56ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;displayStats
<LI><a href="#[fc60f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerStop
<LI><a href="#[fc6138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerStart
<LI><a href="#[fc67b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initClock
</UL>
<BR>[Called By]<UL><LI><a href="#[b55e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol_first
<LI><a href="#[fc67f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol
<LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
<LI><a href="#[fc6888]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueSync
<LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
<LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc6960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayReq
<LI><a href="#[fc69f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueFollowup
<LI><a href="#[fc6a38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleFollowUp
<LI><a href="#[fc6a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayReq
<LI><a href="#[fc6ac8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayResp
<LI><a href="#[fc6b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayResp
<LI><a href="#[fc6b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleManagement
<LI><a href="#[fc6ba0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueManagement
<LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
</UL>

<P><STRONG><a name="[fc6be8]"></a>doInit</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = doInit &rArr; netInit &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b61830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;m1
<LI><a href="#[b61878]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initData
<LI><a href="#[fc61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netShutdown
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
<LI><a href="#[fc6648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackHeader
<LI><a href="#[fc6768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initTimer
<LI><a href="#[fc67b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initClock
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[b55e30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol_loop
<LI><a href="#[b55e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol_first
<LI><a href="#[fc67f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol
</UL>

<P><STRONG><a name="[fc6ba0]"></a>issueManagement</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = issueManagement &rArr; netSendGeneral &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[fc6210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendGeneral
<LI><a href="#[fc6600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackManagementResponse
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleManagement
</UL>

<P><STRONG><a name="[fc6b58]"></a>handleManagement</STRONG> (Thumb, 166 bytes, Stack size 24 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = handleManagement &rArr; issueManagement &rArr; netSendGeneral &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b62a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sum
<LI><a href="#[fc6408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackManagement
<LI><a href="#[fc6528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnloadManagement
<LI><a href="#[fc6ba0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueManagement
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
<LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc6b10]"></a>handleDelayResp</STRONG> (Thumb, 202 bytes, Stack size 24 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = handleDelayResp &rArr; toState &rArr; getRand &rArr; RandomSeed
</UL>
<BR>[Calls]<UL><LI><a href="#[b629d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toInternalTime
<LI><a href="#[fc6060]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateDelay
<LI><a href="#[fc64e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackDelayResp
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
<LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc6ac8]"></a>issueDelayResp</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = issueDelayResp &rArr; netSendGeneral &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b62a18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fromInternalTime
<LI><a href="#[fc6210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendGeneral
<LI><a href="#[fc66d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackDelayResp
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayReq
</UL>

<P><STRONG><a name="[fc6a80]"></a>handleDelayReq</STRONG> (Thumb, 146 bytes, Stack size 24 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = handleDelayReq &rArr; issueDelayResp &rArr; netSendGeneral &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b62940]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addTime
<LI><a href="#[fc6060]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateDelay
<LI><a href="#[fc6ac8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayResp
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc6a38]"></a>handleFollowUp</STRONG> (Thumb, 166 bytes, Stack size 32 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96 + Unknown Stack Size
<LI>Call Chain = handleFollowUp &rArr; toState &rArr; getRand &rArr; RandomSeed
</UL>
<BR>[Calls]<UL><LI><a href="#[b629d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toInternalTime
<LI><a href="#[fc6018]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateOffset
<LI><a href="#[fc60a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateClock
<LI><a href="#[fc6498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackFollowUp
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
<LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc69f0]"></a>issueFollowup</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = issueFollowup &rArr; netSendGeneral &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b62a18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fromInternalTime
<LI><a href="#[fc6210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendGeneral
<LI><a href="#[fc6690]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackFollowUp
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
</UL>

<P><STRONG><a name="[fc69a8]"></a>addForeign</STRONG> (Thumb, 256 bytes, Stack size 48 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = addForeign &rArr; msgUnpackSync
</UL>
<BR>[Calls]<UL><LI><a href="#[fc63c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackSync
<LI><a href="#[fc6450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackHeader
<LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
</UL>

<P><STRONG><a name="[fc6960]"></a>issueDelayReq</STRONG> (Thumb, 86 bytes, Stack size 32 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b56a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getTime
<LI><a href="#[b62a18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fromInternalTime
<LI><a href="#[fc6258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendEvent
<LI><a href="#[fc6720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackDelayReq
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
</UL>

<P><STRONG><a name="[fc6918]"></a>handleSync</STRONG> (Thumb, 408 bytes, Stack size 56 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 256 + Unknown Stack Size
<LI>Call Chain = handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b569b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRand
<LI><a href="#[b617e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;s1
<LI><a href="#[b62940]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addTime
<LI><a href="#[b629d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toInternalTime
<LI><a href="#[fc6018]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateOffset
<LI><a href="#[fc60a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateClock
<LI><a href="#[fc6138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerStart
<LI><a href="#[fc6960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayReq
<LI><a href="#[fc69a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addForeign
<LI><a href="#[fc69f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueFollowup
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
<LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc68d0]"></a>handle</STRONG> (Thumb, 316 bytes, Stack size 56 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 312 + Unknown Stack Size
<LI>Call Chain = handle &rArr; handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b56a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getTime
<LI><a href="#[b628f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;subTime
<LI><a href="#[fc62a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSelect
<LI><a href="#[fc62e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netRecvGeneral
<LI><a href="#[fc6330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netRecvEvent
<LI><a href="#[fc6450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackHeader
<LI><a href="#[fc6570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPeek
<LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc6a38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleFollowUp
<LI><a href="#[fc6a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayReq
<LI><a href="#[fc6b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayResp
<LI><a href="#[fc6b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleManagement
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
<LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
</UL>

<P><STRONG><a name="[fc6888]"></a>issueSync</STRONG> (Thumb, 80 bytes, Stack size 32 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = issueSync &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b56a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getTime
<LI><a href="#[b62a18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fromInternalTime
<LI><a href="#[fc6258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendEvent
<LI><a href="#[fc65b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackSync
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
</UL>

<P><STRONG><a name="[fc6840]"></a>doState</STRONG> (Thumb, 210 bytes, Stack size 24 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = doState &rArr; handle &rArr; handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b61680]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmc
<LI><a href="#[b61830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;m1
<LI><a href="#[fc6180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerExpired
<LI><a href="#[fc6888]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueSync
<LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[b55e30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol_loop
<LI><a href="#[b55e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol_first
<LI><a href="#[fc67f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;protocol
</UL>

<P><STRONG><a name="[b55e78]"></a>protocol_first</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 352 + Unknown Stack Size
<LI>Call Chain = protocol_first &rArr; doState &rArr; handle &rArr; handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
<LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>
<BR>[Called By]<UL><LI><a href="#[b56bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_init
</UL>

<P><STRONG><a name="[b55e30]"></a>protocol_loop</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = protocol_loop &rArr; doState &rArr; handle &rArr; handleSync &rArr; issueDelayReq &rArr; netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
<LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
</UL>
<BR>[Called By]<UL><LI><a href="#[b56bb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_tick
</UL>

<P><STRONG><a name="[fc67f8]"></a>protocol</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, protocol.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
<LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>

<P><STRONG><a name="[fc6570]"></a>msgPeek</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, ptpd_msg.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc6450]"></a>msgUnpackHeader</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = msgUnpackHeader
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
<LI><a href="#[fc69a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addForeign
</UL>

<P><STRONG><a name="[fc63c0]"></a>msgUnpackSync</STRONG> (Thumb, 266 bytes, Stack size 24 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = msgUnpackSync
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc69a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addForeign
</UL>

<P><STRONG><a name="[fc5058]"></a>msgUnpackDelayReq</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, ptpd_msg.o(.text), UNUSED)

<P><STRONG><a name="[fc6498]"></a>msgUnpackFollowUp</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, ptpd_msg.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc6a38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleFollowUp
</UL>

<P><STRONG><a name="[fc64e0]"></a>msgUnpackDelayResp</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = msgUnpackDelayResp
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayResp
</UL>

<P><STRONG><a name="[fc6408]"></a>msgUnpackManagement</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = msgUnpackManagement
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleManagement
</UL>

<P><STRONG><a name="[fc6528]"></a>msgUnloadManagement</STRONG> (Thumb, 272 bytes, Stack size 40 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = msgUnloadManagement &rArr; setTime &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b56a48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setTime
<LI><a href="#[b629d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toInternalTime
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleManagement
</UL>

<P><STRONG><a name="[fc5010]"></a>msgUnpackManagementPayload</STRONG> (Thumb, 660 bytes, Stack size 32 bytes, ptpd_msg.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>

<P><STRONG><a name="[fc6648]"></a>msgPackHeader</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = msgPackHeader
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
</UL>

<P><STRONG><a name="[fc65b8]"></a>msgPackSync</STRONG> (Thumb, 364 bytes, Stack size 24 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = msgPackSync
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6888]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueSync
</UL>

<P><STRONG><a name="[fc6720]"></a>msgPackDelayReq</STRONG> (Thumb, 362 bytes, Stack size 24 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = msgPackDelayReq
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayReq
</UL>

<P><STRONG><a name="[fc6690]"></a>msgPackFollowUp</STRONG> (Thumb, 84 bytes, Stack size 12 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = msgPackFollowUp
</UL>
<BR>[Called By]<UL><LI><a href="#[fc69f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueFollowup
</UL>

<P><STRONG><a name="[fc66d8]"></a>msgPackDelayResp</STRONG> (Thumb, 112 bytes, Stack size 16 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = msgPackDelayResp
</UL>
<BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6ac8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayResp
</UL>

<P><STRONG><a name="[fc4fc8]"></a>msgPackManagement</STRONG> (Thumb, 116 bytes, Stack size 16 bytes, ptpd_msg.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>

<P><STRONG><a name="[fc6600]"></a>msgPackManagementResponse</STRONG> (Thumb, 1122 bytes, Stack size 56 bytes, ptpd_msg.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = msgPackManagementResponse &rArr; getTime
</UL>
<BR>[Calls]<UL><LI><a href="#[b56a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getTime
<LI><a href="#[b62a18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fromInternalTime
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6ba0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueManagement
</UL>

<P><STRONG><a name="[fc28e8]"></a>netQGet</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = netQGet
</UL>
<BR>[Called By]<UL><LI><a href="#[fc62e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netRecvGeneral
<LI><a href="#[fc6330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netRecvEvent
</UL>

<P><STRONG><a name="[fc28a0]"></a>lookupSubdomainAddress</STRONG> (Thumb, 116 bytes, Stack size 16 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = lookupSubdomainAddress &rArr; crc_algorithm
</UL>
<BR>[Calls]<UL><LI><a href="#[b62aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;crc_algorithm
<LI><a href="#[10c05a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[fc6378]"></a>netInit</STRONG> (Thumb, 276 bytes, Stack size 40 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120 + Unknown Stack Size
<LI>Call Chain = netInit &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
<LI><a href="#[b5e8e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_recv
<LI><a href="#[b5e928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[f8aab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_aton
<LI><a href="#[fc2858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_disconnect
<LI><a href="#[fc28a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lookupSubdomainAddress
<LI><a href="#[fc39c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netQInit
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
</UL>

<P><STRONG><a name="[fc61c8]"></a>netShutdown</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = netShutdown &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_remove
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[fc2858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_disconnect
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
</UL>

<P><STRONG><a name="[fc62a0]"></a>netSelect</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = netSelect
</UL>
<BR>[Calls]<UL><LI><a href="#[fc3938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netQCheck
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc6330]"></a>netRecvEvent</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72 + Unknown Stack Size
<LI>Call Chain = netRecvEvent &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[fc28e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netQGet
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc62e8]"></a>netRecvGeneral</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = netRecvGeneral &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[fc28e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netQGet
</UL>
<BR>[Called By]<UL><LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
</UL>

<P><STRONG><a name="[fc6258]"></a>netSendEvent</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = netSendEvent &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6888]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueSync
<LI><a href="#[fc6960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayReq
</UL>

<P><STRONG><a name="[fc6210]"></a>netSendGeneral</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, ptpd_net.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = netSendGeneral &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
</UL>
<BR>[Called By]<UL><LI><a href="#[fc69f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueFollowup
<LI><a href="#[fc6ac8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueDelayResp
<LI><a href="#[fc6ba0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;issueManagement
</UL>

<P><STRONG><a name="[fc67b0]"></a>initClock</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, ptpd_servo.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = initClock &rArr; adjFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[b56970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adjFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[fc60a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;updateClock
<LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>

<P><STRONG><a name="[fc6060]"></a>updateDelay</STRONG> (Thumb, 170 bytes, Stack size 24 bytes, ptpd_servo.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = updateDelay &rArr; subTime &rArr; normalizeTime
</UL>
<BR>[Calls]<UL><LI><a href="#[b628f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;subTime
<LI><a href="#[b62940]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addTime
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayReq
<LI><a href="#[fc6b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayResp
</UL>

<P><STRONG><a name="[fc6018]"></a>updateOffset</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, ptpd_servo.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = updateOffset &rArr; subTime &rArr; normalizeTime
</UL>
<BR>[Calls]<UL><LI><a href="#[b628f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;subTime
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc6a38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleFollowUp
</UL>

<P><STRONG><a name="[fc60a8]"></a>updateClock</STRONG> (Thumb, 212 bytes, Stack size 24 bytes, ptpd_servo.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = updateClock &rArr; getTime
</UL>
<BR>[Calls]<UL><LI><a href="#[b56970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adjFreq
<LI><a href="#[b56a48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setTime
<LI><a href="#[b56a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getTime
<LI><a href="#[b56ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;displayStats
<LI><a href="#[b628f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;subTime
<LI><a href="#[fc67b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initClock
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc6a38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleFollowUp
</UL>

<P><STRONG><a name="[fc6768]"></a>initTimer</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, ptpd_timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc6be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doInit
</UL>

<P><STRONG><a name="[b55d58]"></a>timerTick</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ptpd_timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b56c88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickIntHandler
</UL>

<P><STRONG><a name="[fc0b50]"></a>timerUpdate</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, ptpd_timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = timerUpdate
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerExpired
</UL>

<P><STRONG><a name="[fc60f0]"></a>timerStop</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ptpd_timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>

<P><STRONG><a name="[fc6138]"></a>timerStart</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, ptpd_timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = timerStart
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc6c30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;toState
</UL>

<P><STRONG><a name="[fc6180]"></a>timerExpired</STRONG> (Thumb, 40 bytes, Stack size 12 bytes, ptpd_timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = timerExpired &rArr; timerUpdate
</UL>
<BR>[Calls]<UL><LI><a href="#[fc0b50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerUpdate
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;doState
</UL>

<P><STRONG><a name="[b56460]"></a>RandomAddEntropy</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, random.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b569b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRand
</UL>

<P><STRONG><a name="[b563d0]"></a>RandomSeed</STRONG> (Thumb, 358 bytes, Stack size 24 bytes, random.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = RandomSeed
</UL>
<BR>[Called By]<UL><LI><a href="#[b569b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRand
<LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b56418]"></a>RandomNumber</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, random.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b569b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRand
</UL>

<P><STRONG><a name="[100a958]"></a>raw_init</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, raw.o(.text), UNUSED)

<P><STRONG><a name="[f87de8]"></a>raw_input</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, raw.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = raw_input
</UL>
<BR>[Calls]<UL><LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
</UL>

<P><STRONG><a name="[100a910]"></a>raw_bind</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, raw.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100a910]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_bind
</UL>
<BR>[Called By]<UL><LI><a href="#[100a910]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_bind
</UL>

<P><STRONG><a name="[100a8c8]"></a>raw_connect</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, raw.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100a8c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_connect
</UL>
<BR>[Called By]<UL><LI><a href="#[100a8c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_connect
</UL>

<P><STRONG><a name="[100a880]"></a>raw_recv</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, raw.o(.text), UNUSED)

<P><STRONG><a name="[100a838]"></a>raw_sendto</STRONG> (Thumb, 138 bytes, Stack size 40 bytes, raw.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[f87ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_route
<LI><a href="#[f8bde0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output_if
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[fc79c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_chain
</UL>
<BR>[Called By]<UL><LI><a href="#[100a7f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_send
</UL>

<P><STRONG><a name="[100a7f0]"></a>raw_send</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, raw.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100a838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_sendto
</UL>

<P><STRONG><a name="[100a7a8]"></a>raw_remove</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, raw.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>

<P><STRONG><a name="[100a760]"></a>raw_new</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, raw.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[10c0db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>

<P><STRONG><a name="[1009358]"></a>RIT128x96x4Clear</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, rit128x96x4.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = RIT128x96x4Clear &rArr; RITWriteData
</UL>
<BR>[Calls]<UL><LI><a href="#[1009988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteData
<LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
</UL>

<P><STRONG><a name="[b5a3a0]"></a>RIT128x96x4StringDraw</STRONG> (Thumb, 214 bytes, Stack size 40 bytes, rit128x96x4.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = RIT128x96x4StringDraw &rArr; RITWriteData
</UL>
<BR>[Calls]<UL><LI><a href="#[1009988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteData
<LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
<LI><a href="#[b5c170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_display_address
</UL>

<P><STRONG><a name="[1009310]"></a>RIT128x96x4ImageDraw</STRONG> (Thumb, 98 bytes, Stack size 24 bytes, rit128x96x4.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1009988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteData
<LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
</UL>

<P><STRONG><a name="[10092c8]"></a>RIT128x96x4Enable</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, rit128x96x4.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = RIT128x96x4Enable &rArr; GPIOPinTypeSSI &rArr; GPIOPadConfigSet
</UL>
<BR>[Calls]<UL><LI><a href="#[108ea80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeSSI
<LI><a href="#[108ee70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPadConfigSet
<LI><a href="#[10f4418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlClockGet
<LI><a href="#[10fae28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIEnable
<LI><a href="#[10fae70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDisable
<LI><a href="#[10faf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataGetNonBlocking
<LI><a href="#[10fafd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIConfigSetExpClk
</UL>
<BR>[Called By]<UL><LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
</UL>

<P><STRONG><a name="[1009280]"></a>RIT128x96x4Disable</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, rit128x96x4.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108e9a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinWrite
<LI><a href="#[108ebe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeGPIOOutput
<LI><a href="#[108ee70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPadConfigSet
<LI><a href="#[10fae70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDisable
<LI><a href="#[10faf48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataGetNonBlocking
</UL>

<P><STRONG><a name="[b564a8]"></a>RIT128x96x4Init</STRONG> (Thumb, 116 bytes, Stack size 16 bytes, rit128x96x4.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = RIT128x96x4Init &rArr; RIT128x96x4Enable &rArr; GPIOPinTypeSSI &rArr; GPIOPadConfigSet
</UL>
<BR>[Calls]<UL><LI><a href="#[10092c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Enable
<LI><a href="#[1009358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Clear
<LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
<LI><a href="#[108e9a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinWrite
<LI><a href="#[108ea80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeSSI
<LI><a href="#[108ebe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeGPIOOutput
<LI><a href="#[108ee70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPadConfigSet
<LI><a href="#[10f3de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlPeripheralEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1009238]"></a>RIT128x96x4DisplayOn</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, rit128x96x4.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
</UL>

<P><STRONG><a name="[10091f0]"></a>RIT128x96x4DisplayOff</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, rit128x96x4.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
</UL>

<P><STRONG><a name="[b59f68]"></a>stats_init</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, stats.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[10c0e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[b59ed8]"></a>tcp_init</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, tcp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[10048a0]"></a>tcp_seg_free</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64 + Unknown Stack Size
<LI>Call Chain = tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[1004858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
</UL>

<P><STRONG><a name="[1004858]"></a>tcp_segs_free</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = tcp_segs_free &rArr; tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[10048a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[1004810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
</UL>

<P><STRONG><a name="[1004810]"></a>tcp_pcb_purge</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96 + Unknown Stack Size
<LI>Call Chain = tcp_pcb_purge &rArr; tcp_segs_free &rArr; tcp_seg_free &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[1004858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[10047c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
</UL>

<P><STRONG><a name="[10047c8]"></a>tcp_pcb_remove</STRONG> (Thumb, 90 bytes, Stack size 16 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172 + Unknown Stack Size
<LI>Call Chain = tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[1004810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
</UL>
<BR>[Called By]<UL><LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8e0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
<LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
</UL>

<P><STRONG><a name="[f8e210]"></a>tcp_abort</STRONG> (Thumb, 142 bytes, Stack size 48 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 220 + Unknown Stack Size
<LI>Call Chain = tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[10047c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
<LI><a href="#[1004858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[b5ebb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
<LI><a href="#[f8f2a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_poll
<LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[1004660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
</UL>

<P><STRONG><a name="[b59e90]"></a>tcp_slowtmr</STRONG> (Thumb, 482 bytes, Stack size 32 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 252 + Unknown Stack Size
<LI>Call Chain = tcp_slowtmr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[1004540]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit_rto
<LI><a href="#[1004588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_keepalive
<LI><a href="#[1004810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
<LI><a href="#[1004858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[1004780]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_tmr
</UL>

<P><STRONG><a name="[b59f20]"></a>tcp_fasttmr</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164 + Unknown Stack Size
<LI>Call Chain = tcp_fasttmr &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
<LI><a href="#[1004780]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_tmr
</UL>

<P><STRONG><a name="[1004780]"></a>tcp_tmr</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[b59f20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_fasttmr
</UL>

<P><STRONG><a name="[f8e0f0]"></a>tcp_close</STRONG> (Thumb, 130 bytes, Stack size 16 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[10044b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_ctrl
<LI><a href="#[10047c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close_conn
<LI><a href="#[1005740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv_null
</UL>

<P><STRONG><a name="[f8e138]"></a>tcp_bind</STRONG> (Thumb, 116 bytes, Stack size 16 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = tcp_bind &rArr; tcp_new_port
</UL>
<BR>[Calls]<UL><LI><a href="#[10057d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_new_port
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b55ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;httpd_init
</UL>

<P><STRONG><a name="[f8e060]"></a>tcp_listen</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = tcp_listen &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
</UL>
<BR>[Called By]<UL><LI><a href="#[b55ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;httpd_init
</UL>

<P><STRONG><a name="[f8def8]"></a>tcp_recved</STRONG> (Thumb, 70 bytes, Stack size 0 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_recv
</UL>

<P><STRONG><a name="[1004738]"></a>tcp_next_iss</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, tcp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1004660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
<LI><a href="#[10046f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
</UL>

<P><STRONG><a name="[10046f0]"></a>tcp_connect</STRONG> (Thumb, 142 bytes, Stack size 32 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[1004738]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_next_iss
<LI><a href="#[10057d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_new_port
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>

<P><STRONG><a name="[f8de68]"></a>tcp_setprio</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8f1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_accept
</UL>

<P><STRONG><a name="[10046a8]"></a>tcp_seg_copy</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = tcp_seg_copy &rArr; memp_malloc &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[f90818]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_ref
<LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[10c1088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
</UL>

<P><STRONG><a name="[1004660]"></a>tcp_alloc</STRONG> (Thumb, 230 bytes, Stack size 24 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 244 + Unknown Stack Size
<LI>Call Chain = tcp_alloc &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[1004738]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_next_iss
<LI><a href="#[10c0db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[f8e018]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_new
<LI><a href="#[1002d70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
</UL>

<P><STRONG><a name="[f8e018]"></a>tcp_new</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 244 + Unknown Stack Size
<LI>Call Chain = tcp_new &rArr; tcp_alloc &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[1004660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
</UL>
<BR>[Called By]<UL><LI><a href="#[b55ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;httpd_init
</UL>

<P><STRONG><a name="[f8e180]"></a>tcp_arg</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8f1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_accept
<LI><a href="#[f8f338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close_conn
</UL>

<P><STRONG><a name="[f8df40]"></a>tcp_recv</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8f1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_accept
<LI><a href="#[f8f338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close_conn
</UL>

<P><STRONG><a name="[f8deb0]"></a>tcp_sent</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8f218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_recv
<LI><a href="#[f8f338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close_conn
</UL>

<P><STRONG><a name="[f8e0a8]"></a>tcp_err</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8f1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_accept
</UL>

<P><STRONG><a name="[f8e1c8]"></a>tcp_accept</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, tcp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b55ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;httpd_init
</UL>

<P><STRONG><a name="[f8df88]"></a>tcp_poll</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8f1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_accept
</UL>

<P><STRONG><a name="[f87da0]"></a>tcp_input</STRONG> (Thumb, 810 bytes, Stack size 40 bytes, tcp_in.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 316 + Unknown Stack Size
<LI>Call Chain = tcp_input &rArr; tcp_listen_input &rArr; tcp_alloc &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f8aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f90980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_addr_isbroadcast
<LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[1002d70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[10047c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
</UL>

<P><STRONG><a name="[10045d0]"></a>tcp_enqueue</STRONG> (Thumb, 652 bytes, Stack size 64 bytes, tcp_out.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = tcp_enqueue &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
<LI><a href="#[fc7a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_cat
<LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
<LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[1004858]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_segs_free
<LI><a href="#[10c10d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[f8de20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[1002d70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[10044b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_send_ctrl
<LI><a href="#[10046f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
</UL>

<P><STRONG><a name="[10044b0]"></a>tcp_send_ctrl</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, tcp_out.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
</UL>
<BR>[Called By]<UL><LI><a href="#[f8e0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
</UL>

<P><STRONG><a name="[f8de20]"></a>tcp_write</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, tcp_out.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;send_data
</UL>

<P><STRONG><a name="[f8dfd0]"></a>tcp_output</STRONG> (Thumb, 480 bytes, Stack size 40 bytes, tcp_out.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156 + Unknown Stack Size
<LI>Call Chain = tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[f8aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
<LI><a href="#[f8be28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
<LI><a href="#[1000c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output_segment
<LI><a href="#[10048a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
<LI><a href="#[b59f20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_fasttmr
<LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recved
<LI><a href="#[f8e0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
<LI><a href="#[f8f2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;send_data
<LI><a href="#[1001f18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit
<LI><a href="#[1002d70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[1004540]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit_rto
<LI><a href="#[10046f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
<LI><a href="#[10047c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_remove
</UL>

<P><STRONG><a name="[10044f8]"></a>tcp_rst</STRONG> (Thumb, 186 bytes, Stack size 48 bytes, tcp_out.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140 + Unknown Stack Size
<LI>Call Chain = tcp_rst &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[f8aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
<LI><a href="#[f8be28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Called By]<UL><LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
<LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[1002d70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
</UL>

<P><STRONG><a name="[1004540]"></a>tcp_rexmit_rto</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, tcp_out.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172 + Unknown Stack Size
<LI>Call Chain = tcp_rexmit_rto &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
</UL>
<BR>[Called By]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
</UL>

<P><STRONG><a name="[1001f18]"></a>tcp_rexmit</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, tcp_out.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164 + Unknown Stack Size
<LI>Call Chain = tcp_rexmit &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
</UL>
<BR>[Called By]<UL><LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
</UL>

<P><STRONG><a name="[1004588]"></a>tcp_keepalive</STRONG> (Thumb, 150 bytes, Stack size 32 bytes, tcp_out.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124 + Unknown Stack Size
<LI>Call Chain = tcp_keepalive &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[f8aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
<LI><a href="#[f8be28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Called By]<UL><LI><a href="#[b59e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_slowtmr
</UL>

<P><STRONG><a name="[b55f50]"></a>UARTStdioInit</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, uartstdio.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = UARTStdioInit &rArr; UARTConfigSetExpClk
</UL>
<BR>[Calls]<UL><LI><a href="#[10c3700]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTEnable
<LI><a href="#[10c37d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTConfigSetExpClk
<LI><a href="#[10f3da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlPeripheralPresent
<LI><a href="#[10f3de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlPeripheralEnable
<LI><a href="#[10f4418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[ffee30]"></a>UARTgets</STRONG> (Thumb, 106 bytes, Stack size 24 bytes, uartstdio.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fff340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTwrite
<LI><a href="#[10c38f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTCharPut
<LI><a href="#[10c3988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTCharGet
</UL>

<P><STRONG><a name="[ffede8]"></a>UARTprintf</STRONG> (Thumb, 380 bytes, Stack size 56 bytes, uartstdio.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fff340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTwrite
</UL>

<P><STRONG><a name="[b59e48]"></a>udp_init</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, udp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5a508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_init
</UL>

<P><STRONG><a name="[f87d58]"></a>udp_input</STRONG> (Thumb, 398 bytes, Stack size 56 bytes, udp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180 + Unknown Stack Size
<LI>Call Chain = udp_input &rArr; icmp_dest_unreach &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f8aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
<LI><a href="#[f8bf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[f90980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_addr_isbroadcast
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_input
</UL>

<P><STRONG><a name="[b5e9b8]"></a>udp_bind</STRONG> (Thumb, 86 bytes, Stack size 20 bytes, udp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = udp_bind
</UL>
<BR>[Called By]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[b5e850]"></a>udp_send</STRONG> (Thumb, 272 bytes, Stack size 48 bytes, udp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[f87ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_route
<LI><a href="#[f8aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
<LI><a href="#[f8bde0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output_if
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
<LI><a href="#[fc79c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_chain
</UL>
<BR>[Called By]<UL><LI><a href="#[b5e808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
</UL>

<P><STRONG><a name="[b5e808]"></a>udp_sendto</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, udp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[fc6210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendGeneral
<LI><a href="#[fc6258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSendEvent
</UL>

<P><STRONG><a name="[b5e970]"></a>udp_connect</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, udp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = udp_connect &rArr; udp_bind
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[fc2858]"></a>udp_disconnect</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, udp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netShutdown
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[b5e8e0]"></a>udp_recv</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, udp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[b5e898]"></a>udp_remove</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, udp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = udp_remove &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[fcb008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5efa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_stop
<LI><a href="#[fc61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netShutdown
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[b5e928]"></a>udp_new</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, udp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = udp_new &rArr; memp_malloc &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[fcb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memp_malloc
<LI><a href="#[10c0db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5ef58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_start
<LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[ffc0c0]"></a>uvsnprintf</STRONG> (Thumb, 532 bytes, Stack size 32 bytes, ustdlib.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = uvsnprintf &rArr; strncpy
</UL>
<BR>[Calls]<UL><LI><a href="#[10c09e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>
<BR>[Called By]<UL><LI><a href="#[b59e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usprintf
<LI><a href="#[ffc078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usnprintf
</UL>

<P><STRONG><a name="[b59e00]"></a>usprintf</STRONG> (Thumb, 22 bytes, Stack size 24 bytes, ustdlib.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = usprintf &rArr; uvsnprintf &rArr; strncpy
</UL>
<BR>[Calls]<UL><LI><a href="#[ffc0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uvsnprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[b5c170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_display_address
<LI><a href="#[f8e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_read
</UL>

<P><STRONG><a name="[ffc078]"></a>usnprintf</STRONG> (Thumb, 14 bytes, Stack size 24 bytes, ustdlib.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ffc0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uvsnprintf
</UL>

<P><STRONG><a name="[b55d10]"></a>ulocaltime</STRONG> (Thumb, 154 bytes, Stack size 8 bytes, ustdlib.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = ulocaltime
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[f8e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_read
</UL>

<P><STRONG><a name="[ffc030]"></a>ustrtoul</STRONG> (Thumb, 156 bytes, Stack size 20 bytes, ustdlib.o(.text), UNUSED)

<P><STRONG><a name="[ffb880]"></a>DiagOpenStdio</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, uvision.o(.text), UNUSED)

<P><STRONG><a name="[ffb838]"></a>DiagOpen</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, uvision.o(.text), UNUSED)

<P><STRONG><a name="[ffb7f0]"></a>DiagClose</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, uvision.o(.text), UNUSED)

<P><STRONG><a name="[ffb7a8]"></a>DiagWrite</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, uvision.o(.text), UNUSED)

<P><STRONG><a name="[ffb760]"></a>DiagRead</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, uvision.o(.text), UNUSED)

<P><STRONG><a name="[ffb718]"></a>DiagFlen</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, uvision.o(.text), UNUSED)

<P><STRONG><a name="[b56928]"></a>DiagExit</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, uvision.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[b56928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DiagExit
</UL>
<BR>[Called By]<UL><LI><a href="#[b56928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DiagExit
<LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[ffb6d0]"></a>DiagCommandString</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, uvision.o(.text), UNUSED)

<P><STRONG><a name="[10c1c58]"></a>CPUcpsid</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, cpu_keil.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10fe570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntMasterDisable
</UL>

<P><STRONG><a name="[10c1c10]"></a>CPUcpsie</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, cpu_keil.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10fe528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntMasterEnable
</UL>

<P><STRONG><a name="[10c1bc8]"></a>CPUwfi</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, cpu_keil.o(.text), UNUSED)

<P><STRONG><a name="[10c10d0]"></a>__aeabi_memcpy</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, memcpya.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b53bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_arp_input
<LI><a href="#[b56bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_init
<LI><a href="#[b617a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;copyD0
<LI><a href="#[b617e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;s1
<LI><a href="#[b61830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;m1
<LI><a href="#[b61878]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initData
<LI><a href="#[f8bf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;icmp_dest_unreach
<LI><a href="#[f8e138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_bind
<LI><a href="#[f8e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_read
<LI><a href="#[f907d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_take
<LI><a href="#[f90a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_request
<LI><a href="#[fc28a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lookupSubdomainAddress
<LI><a href="#[fc4fc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackManagement
<LI><a href="#[fc5010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackManagementPayload
<LI><a href="#[fc63c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackSync
<LI><a href="#[fc6408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackManagement
<LI><a href="#[fc6450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackHeader
<LI><a href="#[fc64e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnpackDelayResp
<LI><a href="#[fc6528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgUnloadManagement
<LI><a href="#[fc65b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackSync
<LI><a href="#[fc6600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackManagementResponse
<LI><a href="#[fc6648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackHeader
<LI><a href="#[fc66d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackDelayResp
<LI><a href="#[fc6720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;msgPackDelayReq
<LI><a href="#[fc69a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addForeign
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[10046f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
</UL>

<P><STRONG><a name="[10c1088]"></a>__aeabi_memcpy4</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, memcpya.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10046a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_copy
</UL>

<P><STRONG><a name="[10c1040]"></a>__aeabi_memcpy8</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, memcpya.o(.text), UNUSED)

<P><STRONG><a name="[10c0ed8]"></a>__aeabi_memset</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, memseta.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10c0d28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset_wrapper
<LI><a href="#[10c0e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>

<P><STRONG><a name="[10c0e90]"></a>__aeabi_memset4</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, memseta.o(.text), UNUSED)

<P><STRONG><a name="[10c0e48]"></a>__aeabi_memset8</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, memseta.o(.text), UNUSED)

<P><STRONG><a name="[10c0e00]"></a>__aeabi_memclr</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, memseta.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[10c0ed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[b59f68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;stats_init
<LI><a href="#[b5a118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_init
</UL>

<P><STRONG><a name="[10c0db8]"></a>__aeabi_memclr4</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, memseta.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b56bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_init
<LI><a href="#[b5e928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_new
<LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5ef58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_start
<LI><a href="#[1004660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
<LI><a href="#[100a760]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;raw_new
</UL>

<P><STRONG><a name="[10c0d70]"></a>__aeabi_memclr8</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, memseta.o(.text), UNUSED)

<P><STRONG><a name="[10c0d28]"></a>_memset_wrapper</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, memseta.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10c0ed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>

<P><STRONG><a name="[10c0b50]"></a>strstr</STRONG> (Thumb, 44 bytes, Stack size 12 bytes, strstr.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_read
</UL>

<P><STRONG><a name="[10c09e0]"></a>strncpy</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, strncpy.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strncpy
</UL>
<BR>[Called By]<UL><LI><a href="#[ffc0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uvsnprintf
</UL>

<P><STRONG><a name="[10c0870]"></a>strchr</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, strchr.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8e2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_open
</UL>

<P><STRONG><a name="[10c0708]"></a>strlen</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, strlen.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_read
</UL>

<P><STRONG><a name="[10c05a0]"></a>memcmp</STRONG> (Thumb, 26 bytes, Stack size 12 bytes, memcmp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[b61710]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bmcDataSetComparison
<LI><a href="#[b61758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getIdentifierOrder
<LI><a href="#[fc28a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lookupSubdomainAddress
<LI><a href="#[fc68d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handle
<LI><a href="#[fc6918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleSync
<LI><a href="#[fc69a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;addForeign
<LI><a href="#[fc6a38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleFollowUp
<LI><a href="#[fc6b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleDelayResp
<LI><a href="#[fc6b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;handleManagement
</UL>

<P><STRONG><a name="[10c0430]"></a>strncmp</STRONG> (Thumb, 30 bytes, Stack size 12 bytes, strncmp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f8e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_read
<LI><a href="#[f8e2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_open
<LI><a href="#[f8f218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_recv
</UL>

<P><STRONG><a name="[10c0010]"></a>__init</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, init.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[10c0058]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__call_main
</UL>
<BR>[Called By]<UL><LI><a href="#[10c1478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[10bffc8]"></a>__scatterload_rt2</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, init.o(.text), UNUSED)

<P><STRONG><a name="[10bf818]"></a>__decompress</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __dczerorl.o(.text), UNUSED)

<P><STRONG><a name="[10bf7d0]"></a>__decompress0</STRONG> (Thumb, 58 bytes, Stack size unknown bytes, __dczerorl.o(.text), UNUSED)

<P><STRONG><a name="[10991b0]"></a>EthernetConfigGet</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ethernet.o(i.EthernetConfigGet))
<BR><BR>[Called By]<UL><LI><a href="#[b56bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_init
</UL>

<P><STRONG><a name="[1099168]"></a>EthernetConfigSet</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, ethernet.o(i.EthernetConfigSet))
<BR><BR>[Called By]<UL><LI><a href="#[b56bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_init
<LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
</UL>

<P><STRONG><a name="[10990d8]"></a>EthernetEnable</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, ethernet.o(i.EthernetEnable))
<BR><BR>[Called By]<UL><LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
</UL>

<P><STRONG><a name="[1099090]"></a>EthernetInitExpClk</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, ethernet.o(i.EthernetInitExpClk))
<BR><BR>[Called By]<UL><LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
</UL>

<P><STRONG><a name="[1099048]"></a>EthernetIntClear</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, ethernet.o(i.EthernetIntClear))
<BR><BR>[Called By]<UL><LI><a href="#[b5a550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntHandler
<LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
</UL>

<P><STRONG><a name="[1099000]"></a>EthernetIntDisable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, ethernet.o(i.EthernetIntDisable))
<BR><BR>[Called By]<UL><LI><a href="#[b5a550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntHandler
<LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
</UL>

<P><STRONG><a name="[1098fb8]"></a>EthernetIntEnable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, ethernet.o(i.EthernetIntEnable))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
</UL>

<P><STRONG><a name="[1098f28]"></a>EthernetIntStatus</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ethernet.o(i.EthernetIntStatus))
<BR><BR>[Called By]<UL><LI><a href="#[b5a550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EthernetIntHandler
<LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
</UL>

<P><STRONG><a name="[1098e98]"></a>EthernetMACAddrGet</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, ethernet.o(i.EthernetMACAddrGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = EthernetMACAddrGet
</UL>
<BR>[Called By]<UL><LI><a href="#[b56bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_init
<LI><a href="#[b5a238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_init
</UL>

<P><STRONG><a name="[1098e50]"></a>EthernetMACAddrSet</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, ethernet.o(i.EthernetMACAddrSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = EthernetMACAddrSet
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1098d78]"></a>EthernetPacketAvail</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ethernet.o(i.EthernetPacketAvail))
<BR><BR>[Called By]<UL><LI><a href="#[b5a280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_enqueue
<LI><a href="#[f80f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_input
</UL>

<P><STRONG><a name="[1098c10]"></a>EthernetSpaceAvail</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ethernet.o(i.EthernetSpaceAvail), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[f81048]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_output
</UL>

<P><STRONG><a name="[10940a0]"></a>FlashUserGet</STRONG> (Thumb, 50 bytes, Stack size 0 bytes, flash.o(i.FlashUserGet))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[108ef90]"></a>GPIODirModeSet</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, gpio.o(i.GPIODirModeSet))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[108e9f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeUART
<LI><a href="#[108ea80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeSSI
<LI><a href="#[108ebe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeGPIOOutput
<LI><a href="#[108ec30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeGPIOInput
</UL>

<P><STRONG><a name="[108ee70]"></a>GPIOPadConfigSet</STRONG> (Thumb, 148 bytes, Stack size 8 bytes, gpio.o(i.GPIOPadConfigSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GPIOPadConfigSet
</UL>
<BR>[Called By]<UL><LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
<LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[1009280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Disable
<LI><a href="#[10092c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Enable
<LI><a href="#[108e9f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeUART
<LI><a href="#[108ea80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeSSI
<LI><a href="#[108ebe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeGPIOOutput
<LI><a href="#[108ec30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinTypeGPIOInput
</UL>

<P><STRONG><a name="[108ed08]"></a>GPIOPinRead</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, gpio.o(i.GPIOPinRead))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[108ec30]"></a>GPIOPinTypeGPIOInput</STRONG> (Thumb, 28 bytes, Stack size 12 bytes, gpio.o(i.GPIOPinTypeGPIOInput))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = GPIOPinTypeGPIOInput &rArr; GPIOPadConfigSet
</UL>
<BR>[Calls]<UL><LI><a href="#[108ee70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPadConfigSet
<LI><a href="#[108ef90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIODirModeSet
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[108ebe8]"></a>GPIOPinTypeGPIOOutput</STRONG> (Thumb, 28 bytes, Stack size 12 bytes, gpio.o(i.GPIOPinTypeGPIOOutput))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = GPIOPinTypeGPIOOutput &rArr; GPIOPadConfigSet
</UL>
<BR>[Calls]<UL><LI><a href="#[108ee70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPadConfigSet
<LI><a href="#[108ef90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIODirModeSet
</UL>
<BR>[Called By]<UL><LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
<LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[1009280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Disable
</UL>

<P><STRONG><a name="[108ea80]"></a>GPIOPinTypeSSI</STRONG> (Thumb, 28 bytes, Stack size 12 bytes, gpio.o(i.GPIOPinTypeSSI))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = GPIOPinTypeSSI &rArr; GPIOPadConfigSet
</UL>
<BR>[Calls]<UL><LI><a href="#[108ee70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPadConfigSet
<LI><a href="#[108ef90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIODirModeSet
</UL>
<BR>[Called By]<UL><LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
<LI><a href="#[10092c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Enable
</UL>

<P><STRONG><a name="[108e9f0]"></a>GPIOPinTypeUART</STRONG> (Thumb, 28 bytes, Stack size 12 bytes, gpio.o(i.GPIOPinTypeUART))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = GPIOPinTypeUART &rArr; GPIOPadConfigSet
</UL>
<BR>[Calls]<UL><LI><a href="#[108ee70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPadConfigSet
<LI><a href="#[108ef90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIODirModeSet
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[108e9a8]"></a>GPIOPinWrite</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, gpio.o(i.GPIOPinWrite))
<BR><BR>[Called By]<UL><LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
<LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[b56c88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickIntHandler
<LI><a href="#[1009280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Disable
<LI><a href="#[1009988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteData
<LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
</UL>

<P><STRONG><a name="[10fe5b8]"></a>IntEnable</STRONG> (Thumb, 96 bytes, Stack size 0 bytes, interrupt.o(i.IntEnable))
<BR><BR>[Called By]<UL><LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
</UL>

<P><STRONG><a name="[10fe570]"></a>IntMasterDisable</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, interrupt.o(i.IntMasterDisable))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = IntMasterDisable
</UL>
<BR>[Calls]<UL><LI><a href="#[10c1c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CPUcpsid
</UL>
<BR>[Called By]<UL><LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>

<P><STRONG><a name="[10fe528]"></a>IntMasterEnable</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, interrupt.o(i.IntMasterEnable))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[10c1c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CPUcpsie
</UL>
<BR>[Called By]<UL><LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10fe408]"></a>IntPrioritySet</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, interrupt.o(i.IntPrioritySet))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IntPrioritySet
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10fafd8]"></a>SSIConfigSetExpClk</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, ssi.o(i.SSIConfigSetExpClk))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = SSIConfigSetExpClk
</UL>
<BR>[Called By]<UL><LI><a href="#[10092c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Enable
</UL>

<P><STRONG><a name="[10faf90]"></a>SSIDataGet</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, ssi.o(i.SSIDataGet))
<BR><BR>[Calls]<UL><LI><a href="#[10faf90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataGet
</UL>
<BR>[Called By]<UL><LI><a href="#[1009988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteData
<LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
<LI><a href="#[10faf90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataGet
</UL>

<P><STRONG><a name="[10faf48]"></a>SSIDataGetNonBlocking</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ssi.o(i.SSIDataGetNonBlocking))
<BR><BR>[Called By]<UL><LI><a href="#[1009280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Disable
<LI><a href="#[10092c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Enable
</UL>

<P><STRONG><a name="[10faf00]"></a>SSIDataPut</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ssi.o(i.SSIDataPut))
<BR><BR>[Calls]<UL><LI><a href="#[10faf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataPut
</UL>
<BR>[Called By]<UL><LI><a href="#[1009988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteData
<LI><a href="#[10099d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RITWriteCommand
<LI><a href="#[10faf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataPut
</UL>

<P><STRONG><a name="[10fae70]"></a>SSIDisable</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ssi.o(i.SSIDisable))
<BR><BR>[Called By]<UL><LI><a href="#[1009280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Disable
<LI><a href="#[10092c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Enable
</UL>

<P><STRONG><a name="[10fae28]"></a>SSIEnable</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ssi.o(i.SSIEnable))
<BR><BR>[Called By]<UL><LI><a href="#[10092c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Enable
</UL>

<P><STRONG><a name="[10f4418]"></a>SysCtlClockGet</STRONG> (Thumb, 256 bytes, Stack size 12 bytes, sysctl.o(i.SysCtlClockGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = SysCtlClockGet
</UL>
<BR>[Called By]<UL><LI><a href="#[b55f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTStdioInit
<LI><a href="#[b56c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_systick_init
<LI><a href="#[f81090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;low_level_init
<LI><a href="#[10092c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Enable
</UL>

<P><STRONG><a name="[10f43d0]"></a>SysCtlClockSet</STRONG> (Thumb, 268 bytes, Stack size 24 bytes, sysctl.o(i.SysCtlClockSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = SysCtlClockSet
</UL>
<BR>[Calls]<UL><LI><a href="#[10f4b68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysCtlDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10f3de8]"></a>SysCtlPeripheralEnable</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, sysctl.o(i.SysCtlPeripheralEnable))
<BR><BR>[Called By]<UL><LI><a href="#[b55f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTStdioInit
<LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
<LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10f3da0]"></a>SysCtlPeripheralPresent</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, sysctl.o(i.SysCtlPeripheralPresent))
<BR><BR>[Called By]<UL><LI><a href="#[b55f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTStdioInit
</UL>

<P><STRONG><a name="[10f3d58]"></a>SysCtlPeripheralReset</STRONG> (Thumb, 44 bytes, Stack size 12 bytes, sysctl.o(i.SysCtlPeripheralReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = SysCtlPeripheralReset
</UL>
<BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10cddd8]"></a>SysTickEnable</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, systick.o(i.SysTickEnable))
<BR><BR>[Called By]<UL><LI><a href="#[b56c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_systick_init
</UL>

<P><STRONG><a name="[10cdd48]"></a>SysTickIntEnable</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, systick.o(i.SysTickIntEnable))
<BR><BR>[Called By]<UL><LI><a href="#[b56c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_systick_init
</UL>

<P><STRONG><a name="[10cdc70]"></a>SysTickPeriodGet</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, systick.o(i.SysTickPeriodGet))
<BR><BR>[Called By]<UL><LI><a href="#[b56a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getTime
<LI><a href="#[b56c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ptpd_systick_init
</UL>

<P><STRONG><a name="[10cdc28]"></a>SysTickPeriodSet</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, systick.o(i.SysTickPeriodSet))
<BR><BR>[Called By]<UL><LI><a href="#[b56c88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTickIntHandler
</UL>

<P><STRONG><a name="[10cdbe0]"></a>SysTickValueGet</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, systick.o(i.SysTickValueGet))
<BR><BR>[Called By]<UL><LI><a href="#[b56a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getTime
</UL>

<P><STRONG><a name="[10c9768]"></a>TimerConfigure</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, timer.o(i.TimerConfigure))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10c9720]"></a>TimerControlEvent</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, timer.o(i.TimerControlEvent))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10c95b8]"></a>TimerEnable</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, timer.o(i.TimerEnable))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10c9378]"></a>TimerLoadSet</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, timer.o(i.TimerLoadSet))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10c91c8]"></a>TimerPrescaleSet</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, timer.o(i.TimerPrescaleSet))
<BR><BR>[Called By]<UL><LI><a href="#[b56b20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10c90a8]"></a>TimerValueGet</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, timer.o(i.TimerValueGet))
<BR><BR>[Called By]<UL><LI><a href="#[b56a00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getRxTime
</UL>

<P><STRONG><a name="[10c3988]"></a>UARTCharGet</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, uart.o(i.UARTCharGet), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10c3988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTCharGet
</UL>
<BR>[Called By]<UL><LI><a href="#[ffee30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTgets
<LI><a href="#[10c3988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTCharGet
</UL>

<P><STRONG><a name="[10c38f8]"></a>UARTCharPut</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, uart.o(i.UARTCharPut), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10c38f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTCharPut
</UL>
<BR>[Called By]<UL><LI><a href="#[ffee30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTgets
<LI><a href="#[fff340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTwrite
<LI><a href="#[10c38f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTCharPut
</UL>

<P><STRONG><a name="[10c37d8]"></a>UARTConfigSetExpClk</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, uart.o(i.UARTConfigSetExpClk))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = UARTConfigSetExpClk
</UL>
<BR>[Calls]<UL><LI><a href="#[10c3700]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[b55f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTStdioInit
</UL>

<P><STRONG><a name="[10c3790]"></a>UARTDisable</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, uart.o(i.UARTDisable), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10c3790]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTDisable
</UL>
<BR>[Called By]<UL><LI><a href="#[10c3790]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTDisable
</UL>

<P><STRONG><a name="[10c3700]"></a>UARTEnable</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, uart.o(i.UARTEnable))
<BR><BR>[Called By]<UL><LI><a href="#[b55f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTStdioInit
<LI><a href="#[10c37d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTConfigSetExpClk
</UL>

<P><STRONG><a name="[10bfaa0]"></a>__scatterload_copy</STRONG> (Thumb, 14 bytes, Stack size unknown bytes, handlers.o(i.__scatterload_copy), UNUSED)

<P><STRONG><a name="[10bfa58]"></a>__scatterload_null</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, handlers.o(i.__scatterload_null), UNUSED)

<P><STRONG><a name="[10bfa10]"></a>__scatterload_zeroinit</STRONG> (Thumb, 14 bytes, Stack size unknown bytes, handlers.o(i.__scatterload_zeroinit), UNUSED)
<P>
<H3>
Local Symbols
</H3>
<P><STRONG><a name="[b60350]"></a>dhcp_check</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 152 + Unknown Stack Size
<LI>Call Chain = dhcp_check &rArr; etharp_query &rArr; pbuf_take &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
</UL>
<BR>[Called By]<UL><LI><a href="#[b5fdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_timeout
<LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
</UL>

<P><STRONG><a name="[b60308]"></a>dhcp_option_trailer</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, dhcp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
</UL>

<P><STRONG><a name="[b602c0]"></a>dhcp_option_long</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dhcp_option_long
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
</UL>

<P><STRONG><a name="[b60278]"></a>dhcp_option_short</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dhcp_option_short
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
</UL>

<P><STRONG><a name="[b60230]"></a>dhcp_create_request</STRONG> (Thumb, 204 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96 + Unknown Stack Size
<LI>Call Chain = dhcp_create_request &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
</UL>

<P><STRONG><a name="[b601e8]"></a>dhcp_select</STRONG> (Thumb, 250 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = dhcp_select &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_send
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[b5fe88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option
<LI><a href="#[b5fed0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_byte
<LI><a href="#[b5ff18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_delete_request
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[b60278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_short
<LI><a href="#[b602c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_long
<LI><a href="#[b60308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_trailer
</UL>
<BR>[Called By]<UL><LI><a href="#[b5fdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_timeout
<LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
</UL>

<P><STRONG><a name="[b601a0]"></a>dhcp_get_option_ptr</STRONG> (Thumb, 128 bytes, Stack size 16 bytes, dhcp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
<LI><a href="#[b600c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_handle_ack
</UL>

<P><STRONG><a name="[b60158]"></a>dhcp_rebind</STRONG> (Thumb, 162 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = dhcp_rebind &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5fe88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option
<LI><a href="#[b5fed0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_byte
<LI><a href="#[b5ff18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_delete_request
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[b60278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_short
<LI><a href="#[b60308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_trailer
</UL>
<BR>[Called By]<UL><LI><a href="#[b5f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_coarse_tmr
<LI><a href="#[b5fdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_timeout
</UL>

<P><STRONG><a name="[b60110]"></a>dhcp_bind</STRONG> (Thumb, 200 bytes, Stack size 24 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 260 + Unknown Stack Size
<LI>Call Chain = dhcp_bind &rArr; netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[b5eb20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_up
<LI><a href="#[b5eb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_netmask
<LI><a href="#[b5ebb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_ipaddr
<LI><a href="#[b5ebf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netif_set_gw
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
</UL>
<BR>[Called By]<UL><LI><a href="#[b5fdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_timeout
<LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
</UL>

<P><STRONG><a name="[b600c8]"></a>dhcp_handle_ack</STRONG> (Thumb, 220 bytes, Stack size 16 bytes, dhcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[b5fe40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_get_option_long
<LI><a href="#[b601a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_get_option_ptr
</UL>
<BR>[Called By]<UL><LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
</UL>

<P><STRONG><a name="[b60080]"></a>dhcp_free_reply</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = dhcp_free_reply &rArr; mem_free &rArr; plug_holes
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b5efa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_stop
<LI><a href="#[b5fdf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_unfold_reply
</UL>

<P><STRONG><a name="[b60038]"></a>dhcp_recv</STRONG> (Thumb, 256 bytes, Stack size 24 bytes, dhcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[b5fdf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_unfold_reply
<LI><a href="#[b5fe40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_get_option_long
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
<LI><a href="#[b600c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_handle_ack
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
<LI><a href="#[b601a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_get_option_ptr
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
<LI><a href="#[b60350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_check
</UL>

<P><STRONG><a name="[b5fff0]"></a>dhcp_discover</STRONG> (Thumb, 224 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = dhcp_discover &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[b5e8e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_recv
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5fe88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option
<LI><a href="#[b5fed0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_byte
<LI><a href="#[b5ff18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_delete_request
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[b60278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_short
<LI><a href="#[b60308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_trailer
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ef58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_start
<LI><a href="#[b5fdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_timeout
</UL>

<P><STRONG><a name="[b5ffa8]"></a>dhcp_decline</STRONG> (Thumb, 156 bytes, Stack size 16 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = dhcp_decline &rArr; udp_sendto &rArr; udp_send &rArr; pbuf_alloc &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5e808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_sendto
<LI><a href="#[b5e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_connect
<LI><a href="#[b5e9b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;udp_bind
<LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[b5fe88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option
<LI><a href="#[b5fed0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_byte
<LI><a href="#[b5ff18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_delete_request
<LI><a href="#[b5ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_set_state
<LI><a href="#[b60230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_create_request
<LI><a href="#[b60278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_short
<LI><a href="#[b602c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_long
<LI><a href="#[b60308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_option_trailer
</UL>
<BR>[Called By]<UL><LI><a href="#[b5eec8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_arp_reply
</UL>

<P><STRONG><a name="[b5ff60]"></a>dhcp_set_state</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, dhcp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
<LI><a href="#[b60350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_check
</UL>

<P><STRONG><a name="[b5ff18]"></a>dhcp_delete_request</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = dhcp_delete_request &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
</UL>

<P><STRONG><a name="[b5fed0]"></a>dhcp_option_byte</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, dhcp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
</UL>

<P><STRONG><a name="[b5fe88]"></a>dhcp_option</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dhcp_option
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_inform
<LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5ffa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_decline
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
</UL>

<P><STRONG><a name="[b5fe40]"></a>dhcp_get_option_long</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, dhcp.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
<LI><a href="#[b600c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_handle_ack
</UL>

<P><STRONG><a name="[b5fdf8]"></a>dhcp_unfold_reply</STRONG> (Thumb, 140 bytes, Stack size 24 bytes, dhcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ecd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[b60080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_free_reply
</UL>
<BR>[Called By]<UL><LI><a href="#[b60038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_recv
</UL>

<P><STRONG><a name="[b5fdb0]"></a>dhcp_timeout</STRONG> (Thumb, 114 bytes, Stack size 8 bytes, dhcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 268 + Unknown Stack Size
<LI>Call Chain = dhcp_timeout &rArr; dhcp_bind &rArr; netif_set_ipaddr &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5f030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_release
<LI><a href="#[b5f0c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_renew
<LI><a href="#[b5fff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_discover
<LI><a href="#[b60110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_bind
<LI><a href="#[b60158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_rebind
<LI><a href="#[b601e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_select
<LI><a href="#[b60350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_check
</UL>
<BR>[Called By]<UL><LI><a href="#[b5efe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dhcp_fine_tmr
</UL>

<P><STRONG><a name="[b5c170]"></a>lwip_display_address</STRONG> (Thumb, 52 bytes, Stack size 48 bytes, enet_lwip.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = lwip_display_address &rArr; usprintf &rArr; uvsnprintf &rArr; strncpy
</UL>
<BR>[Calls]<UL><LI><a href="#[b59e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;usprintf
<LI><a href="#[b5a3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4StringDraw
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lwip_tick
</UL>

<P><STRONG><a name="[b54990]"></a>find_entry</STRONG> (Thumb, 242 bytes, Stack size 48 bytes, etharp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96 + Unknown Stack Size
<LI>Call Chain = find_entry &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
</UL>
<BR>[Called By]<UL><LI><a href="#[b54948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;update_arp_entry
<LI><a href="#[b5ee38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_query
</UL>

<P><STRONG><a name="[b54948]"></a>update_arp_entry</STRONG> (Thumb, 194 bytes, Stack size 32 bytes, etharp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = update_arp_entry &rArr; find_entry &rArr; pbuf_free &rArr; memp_free &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b54990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;find_entry
<LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f908a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_dequeue
<LI><a href="#[f90980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_addr_isbroadcast
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Called By]<UL><LI><a href="#[b53bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_arp_input
<LI><a href="#[b53c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;etharp_ip_input
</UL>

<P><STRONG><a name="[f8f380]"></a>conn_err</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, httpd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[f8e330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_close
</UL>

<P><STRONG><a name="[f8f338]"></a>close_conn</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, httpd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[f8deb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_sent
<LI><a href="#[f8df40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv
<LI><a href="#[f8e0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
<LI><a href="#[f8e180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_arg
<LI><a href="#[f8e330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_close
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_recv
<LI><a href="#[f8f2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;send_data
</UL>

<P><STRONG><a name="[f8f2f0]"></a>send_data</STRONG> (Thumb, 152 bytes, Stack size 16 bytes, httpd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f8de20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_write
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f8e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_read
<LI><a href="#[f8e330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_close
<LI><a href="#[f8f338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close_conn
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_recv
<LI><a href="#[f8f260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_sent
<LI><a href="#[f8f2a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;http_poll
</UL>

<P><STRONG><a name="[f8f2a8]"></a>http_poll</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, httpd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[f8f2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;send_data
</UL>

<P><STRONG><a name="[f8f260]"></a>http_sent</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, httpd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f8f2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;send_data
</UL>

<P><STRONG><a name="[f8f218]"></a>http_recv</STRONG> (Thumb, 184 bytes, Stack size 32 bytes, httpd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[f8deb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_sent
<LI><a href="#[f8def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recved
<LI><a href="#[f8e2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;fs_open
<LI><a href="#[f8f2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;send_data
<LI><a href="#[f8f338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;close_conn
<LI><a href="#[10c0430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncmp
</UL>

<P><STRONG><a name="[f8f1d0]"></a>http_accept</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, httpd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ecd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_malloc
<LI><a href="#[f8de68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_setprio
<LI><a href="#[f8df40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_recv
<LI><a href="#[f8df88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_poll
<LI><a href="#[f8e0a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_err
<LI><a href="#[f8e180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_arg
</UL>

<P><STRONG><a name="[f8b248]"></a>lwip_standard_chksum</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, inet.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = lwip_standard_chksum
</UL>
<BR>[Called By]<UL><LI><a href="#[f8aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
<LI><a href="#[f8be70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pbuf
<LI><a href="#[f8beb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum
</UL>

<P><STRONG><a name="[f82830]"></a>enqueue_frame</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, luminaryif.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = enqueue_frame &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ethernetif_enqueue
</UL>

<P><STRONG><a name="[fcde38]"></a>plug_holes</STRONG> (Thumb, 78 bytes, Stack size 12 bytes, mem.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = plug_holes
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ed18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_free
<LI><a href="#[fcd658]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mem_realloc
</UL>

<P><STRONG><a name="[fc8350]"></a>pbuf_pool_alloc</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, pbuf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = pbuf_pool_alloc &rArr; sys_arch_unprotect &rArr; IntMasterEnable
</UL>
<BR>[Calls]<UL><LI><a href="#[b55da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_unprotect
<LI><a href="#[b55de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sys_arch_protect
</UL>
<BR>[Called By]<UL><LI><a href="#[b5ea90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_alloc
</UL>

<P><STRONG><a name="[fc3a58]"></a>eventRecv</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, ptpd_net.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fc3980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netQPut
</UL>

<P><STRONG><a name="[fc3a10]"></a>generalRecv</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, ptpd_net.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fc3980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netQPut
</UL>

<P><STRONG><a name="[fc39c8]"></a>netQInit</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ptpd_net.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc6378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netInit
</UL>

<P><STRONG><a name="[fc3980]"></a>netQPut</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, ptpd_net.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[fc3a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;generalRecv
<LI><a href="#[fc3a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;eventRecv
</UL>

<P><STRONG><a name="[fc3938]"></a>netQCheck</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ptpd_net.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fc62a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;netSelect
</UL>

<P><STRONG><a name="[10099d0]"></a>RITWriteCommand</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, rit128x96x4.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = RITWriteCommand
</UL>
<BR>[Calls]<UL><LI><a href="#[108e9a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinWrite
<LI><a href="#[10faf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataPut
<LI><a href="#[10faf90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataGet
</UL>
<BR>[Called By]<UL><LI><a href="#[b564a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Init
<LI><a href="#[b5a3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4StringDraw
<LI><a href="#[10091f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4DisplayOff
<LI><a href="#[1009238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4DisplayOn
<LI><a href="#[1009310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4ImageDraw
<LI><a href="#[1009358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Clear
</UL>

<P><STRONG><a name="[1009988]"></a>RITWriteData</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, rit128x96x4.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = RITWriteData
</UL>
<BR>[Calls]<UL><LI><a href="#[108e9a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIOPinWrite
<LI><a href="#[10faf00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataPut
<LI><a href="#[10faf90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SSIDataGet
</UL>
<BR>[Called By]<UL><LI><a href="#[b5a3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4StringDraw
<LI><a href="#[1009310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4ImageDraw
<LI><a href="#[1009358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RIT128x96x4Clear
</UL>

<P><STRONG><a name="[1008c88]"></a>NmiSR</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, startup_rvmdk.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[1008c88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NmiSR
</UL>
<BR>[Called By]<UL><LI><a href="#[1008c88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NmiSR
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_rvmdk.o(RESET)
</UL>
<P><STRONG><a name="[1008c40]"></a>FaultISR</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, startup_rvmdk.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[1008c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FaultISR
</UL>
<BR>[Called By]<UL><LI><a href="#[1008c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FaultISR
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_rvmdk.o(RESET)
</UL>
<P><STRONG><a name="[1008bf8]"></a>IntDefaultHandler</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, startup_rvmdk.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[1008bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntDefaultHandler
</UL>
<BR>[Called By]<UL><LI><a href="#[1008bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IntDefaultHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_rvmdk.o(RESET)
</UL>
<P><STRONG><a name="[10057d0]"></a>tcp_new_port</STRONG> (Thumb, 92 bytes, Stack size 20 bytes, tcp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = tcp_new_port
</UL>
<BR>[Called By]<UL><LI><a href="#[f8e138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_bind
<LI><a href="#[10046f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_connect
</UL>

<P><STRONG><a name="[1005740]"></a>tcp_recv_null</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, tcp.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b5ea48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_free
<LI><a href="#[f8e0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_close
</UL>

<P><STRONG><a name="[1002e48]"></a>tcp_receive</STRONG> (Thumb, 1430 bytes, Stack size 32 bytes, tcp_in.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196 + Unknown Stack Size
<LI>Call Chain = tcp_receive &rArr; tcp_rexmit &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ea00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_realloc
<LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f90860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_header
<LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
<LI><a href="#[fc7a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_cat
<LI><a href="#[fc7a50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pbuf_clen
<LI><a href="#[1001f18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rexmit
<LI><a href="#[10046a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_copy
<LI><a href="#[10048a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
</UL>
<BR>[Called By]<UL><LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
</UL>

<P><STRONG><a name="[1002e00]"></a>tcp_parseopt</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, tcp_in.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = tcp_parseopt
</UL>
<BR>[Calls]<UL><LI><a href="#[f908f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohs
</UL>
<BR>[Called By]<UL><LI><a href="#[1002d70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_listen_input
<LI><a href="#[1002db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_process
</UL>

<P><STRONG><a name="[1002db8]"></a>tcp_process</STRONG> (Thumb, 794 bytes, Stack size 48 bytes, tcp_in.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 268 + Unknown Stack Size
<LI>Call Chain = tcp_process &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[f8e210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_abort
<LI><a href="#[1002e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_parseopt
<LI><a href="#[1002e48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_receive
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[1004810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_pcb_purge
<LI><a href="#[10048a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_seg_free
</UL>
<BR>[Called By]<UL><LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
</UL>

<P><STRONG><a name="[1002d70]"></a>tcp_listen_input</STRONG> (Thumb, 212 bytes, Stack size 32 bytes, tcp_in.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 276 + Unknown Stack Size
<LI>Call Chain = tcp_listen_input &rArr; tcp_alloc &rArr; tcp_abort &rArr; tcp_pcb_remove &rArr; tcp_output &rArr; tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
<LI><a href="#[1002e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_parseopt
<LI><a href="#[10044f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_rst
<LI><a href="#[10045d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_enqueue
<LI><a href="#[1004660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_alloc
</UL>
<BR>[Called By]<UL><LI><a href="#[f87da0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_input
</UL>

<P><STRONG><a name="[1000c10]"></a>tcp_output_segment</STRONG> (Thumb, 174 bytes, Stack size 24 bytes, tcp_out.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = tcp_output_segment &rArr; ip_output &rArr; ip_output_if &rArr; inet_chksum &rArr; lwip_standard_chksum
</UL>
<BR>[Calls]<UL><LI><a href="#[b5ead8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ntohl
<LI><a href="#[b5edf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htonl
<LI><a href="#[f87ec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_route
<LI><a href="#[f8aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;inet_chksum_pseudo
<LI><a href="#[f8be28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ip_output
<LI><a href="#[f909c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;htons
</UL>
<BR>[Called By]<UL><LI><a href="#[f8dfd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;tcp_output
</UL>

<P><STRONG><a name="[fff340]"></a>UARTwrite</STRONG> (Thumb, 50 bytes, Stack size 24 bytes, uartstdio.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10c38f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTCharPut
</UL>
<BR>[Called By]<UL><LI><a href="#[ffede8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTprintf
<LI><a href="#[ffee30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UARTgets
</UL>
<P>
<H3>
Undefined Global Symbols
</H3><HR></body></html>
