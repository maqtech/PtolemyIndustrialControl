/* Analyze an Eclipse AST and try to assign a type to each
(sub-)expression node in it.

Copyright (c) 2005 The Regents of the University of California.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, 
ENHANCEMENTS, OR MODIFICATIONS.

PT_COPYRIGHT_VERSION_2
COPYRIGHTENDKEY

*/

package ptolemy.backtrack.ast;

import java.io.OutputStreamWriter;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BodyDeclaration;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.CharacterLiteral;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ForStatement;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.InstanceofExpression;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.NullLiteral;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.SuperMethodInvocation;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.VariableDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

import ptolemy.backtrack.ast.transform.AssignmentHandler;
import ptolemy.backtrack.ast.transform.ClassHandler;

//////////////////////////////////////////////////////////////////////////
//// TypeAnalyzer
/**
   A type analyzer for Java Abstract Syntax Trees (ASTs) generated by
   <a href="http://eclipse.org/" target="_blank">Eclipse</a>.
   <p>
   This analyzer does a depth-first traversal on the given AST. It tries
   to assign a type to every expression and sub-expression node a type
   according to the Java 1.5 semantics (but it is also backward compatible
   with Java 1.4). This type information can be used later to decide the
   behavior of each method call and field access.
   <p>
   When other classes are referenced in the AST, this analyzer tries to
   load them with the Java reflection mechanism. Once loaded, their names
   are assigned to the corresponding nodes as their types. This analyzer
   uses {@link LocalClassLoader} to simulate loading a class with its
   partial name within another class.
   <p>
   This analyzer assumes that the classes being analyzed (including those
   classes indirectly referred to) have been compiled with the Java
   compiler. It does not check for type errors in the AST, but it mimics
   the typing semantics of the Java compiler.
   
   @author Thomas Feng
   @version $Id$
   @since Ptolemy II 5.1
   @Pt.ProposedRating Red (tfeng)
   @Pt.AcceptedRating Red (tfeng)
*/
public class TypeAnalyzer extends ASTVisitor {

    ///////////////////////////////////////////////////////////////////
    ////                        constructors                       ////

    /** Construct an analyzer with no explicit class path for its
     *  class loader (an instanceof {@link LocalClassLoader}). Such
     *  a class loader cannot resolve classes other than Java
     *  built-in classes.
     */
    public TypeAnalyzer() {
        this(null);
    }

    /** Construct an analyzer with with an array of explicit class
     *  paths for its class loader (an instanceof {@link
     *  LocalClassLoader}).
     */
    public TypeAnalyzer(String[] classPaths) {
        _state.setClassLoader(new LocalClassLoader(classPaths));
    }

    ///////////////////////////////////////////////////////////////////
    ////                       public methods                      ////

    /** End the visit of an anonymous class declaration and close its
     *  scope. The current class is set back to the last visited class.
     *  @param node
     */
    public void endVisit(AnonymousClassDeclaration node) {
        if (_handlers.hasClassHandler()) {
            List handlerList = _handlers.getClassHandlers();
            Iterator handlersIter = handlerList.iterator();
            while (handlersIter.hasNext()) {
                ClassHandler handler = (ClassHandler)handlersIter.next();
                handler.handle(node, _state);
            }
        }
        _state.unsetClassScope();
        _closeScope();
        _state.leaveClass();
    }

    /** Visit an array access node and set its type to be the type with one
     *  less dimension.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(ArrayAccess node) {
        Type arrayType = Type.getType(node.getArray());
        try {
            Type.setType(node, arrayType.removeOneDimension());
        } catch (ClassNotFoundException e) {
            throw new UnknownASTException();
        }
    }

    /** Propagate the type of the array to this node.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(ArrayCreation node) {
        Type.propagateType(node, node.getType());
    }

    /** Visit an array type node and set its type to be the type with one
     *  more dimension than its component type.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(ArrayType node) {
        Type componentType = Type.getType(node.getComponentType());
        Type newType = componentType.addOneDimension();
        Type.setType(node, newType);
    }

    /** Propagate the type of the left-hand side of the assignment
     *  to this node.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(Assignment node) {
        Type.propagateType(node, node.getLeftHandSide());
        if (_handlers.hasAssignmentHandler()) {
            List handlerList = _handlers.getAssignmentHandlers();
            Iterator handlersIter = handlerList.iterator();
            while (handlersIter.hasNext()) {
                AssignmentHandler handler = 
                    (AssignmentHandler)handlersIter.next();
                handler.handle(node, _state);
            }
        }
    }

    /** End the visit of a block node and close the scope opened by the
     *  previous visit function.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(Block node) {
        _closeScope();
    }

    /** Visit a literal node and set its type to be the same type as the
     *  literal.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(BooleanLiteral node) {
        Type.setType(node, Type.BOOLEAN);
    }

   /** Propagate the type of the cast class to this node.
    *
    *  @param node The node to be visited.
    */
   public void endVisit(CastExpression node) {
       Type.propagateType(node, node.getType());
   }

    /** Visit a literal node and set its type to be the same type as the
     *  literal.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(CharacterLiteral node) {
        Type.setType(node, Type.CHAR);
    }

    /** Propagate the type of the instantiated class to this node.
    *
    *  @param node The node to be visited.
    */
   public void endVisit(ClassInstanceCreation node) {
       Type.propagateType(node, node.getName());
   }

   /** Visit a conditional expression node and set its type to be
    *  the type that is compatible with both the then expression and
    *  the else expression.
    *
    *  @param node The node to be visited.
    */
   public void endVisit(ConditionalExpression node) {
       Type type1 = Type.getType(node.getThenExpression());
       Type type2 = Type.getType(node.getElseExpression());

       Type commonType = Type.getCommonType(type1, type2);
       try {
           if (commonType == null &&
                   type1.compatibility(type2, _state.getClassLoader()) >= 0)
               commonType = type2;
       } catch (ClassNotFoundException e) {
       }

       try {
           if (commonType == null &&
                   type2.compatibility(type1, _state.getClassLoader()) >= 0)
               commonType = type1;
       } catch (ClassNotFoundException e) {
       }

       if (commonType == null)
           throw new UnknownASTException();

       Type.setType(node, commonType);
   }

   /** End the visit of an enhanced for statement and close the scope
    *  opened by the previous visit function.
    *
    *  @param node The node to be visited.
    */
   public void endVisit(EnhancedForStatement node) {
       _closeScope();
   }

   /** Visit a field declaration and set its type to be the same as the
    *  declared type.
    *
    *  @param node The node to be visited.
    */
   public void endVisit(FieldDeclaration node) {
       Type.propagateType(node, node.getType());
   }
   
   /** End the visit of a for statement and close the scope opened by
    *  the previous visit function.
    *
    *  @param node The node to be visited.
    */
   public void endVisit(ForStatement node) {
       _closeScope();
   }

   /** End the visit of an importation declaration and record the
    *  imported class or package in the class loader. If a class is
    *  imported, it is loaded immediately and put in a hash table to
    *  enable fast class lookup.
    *
    *  @param node The node to be visited.
    */
   public void endVisit(ImportDeclaration node) {
       String importName = node.getName().toString();
       if (node.isOnDemand())
           _state.getClassLoader().importPackage(importName);
       else {
           _state.getClassLoader().importClass(importName);
           _importClass(importName);
       }
   }

   /** Visit an infix expression and compute the type for it.
   *
   *  @param node The node to be visited.
   */
   public void endVisit(InfixExpression node) {
      InfixExpression.Operator operator = node.getOperator();
      Expression leftHand = node.getLeftOperand();
      Expression rightHand = node.getRightOperand();
      List extendedOps = node.extendedOperands();
      Type type = null;

      if (operator.equals(InfixExpression.Operator.PLUS) ||
          operator.equals(InfixExpression.Operator.MINUS) ||
          operator.equals(InfixExpression.Operator.TIMES) ||
          operator.equals(InfixExpression.Operator.DIVIDE) ||
          operator.equals(InfixExpression.Operator.REMAINDER) ||
          operator.equals(InfixExpression.Operator.LEFT_SHIFT) ||
          operator.equals(InfixExpression.Operator.RIGHT_SHIFT_SIGNED) ||
          operator.equals(InfixExpression.Operator.RIGHT_SHIFT_UNSIGNED) ||
          operator.equals(InfixExpression.Operator.AND) ||
          operator.equals(InfixExpression.Operator.OR) ||
          operator.equals(InfixExpression.Operator.XOR)) {
          
          type = Type.getCommonType(Type.getType(leftHand), 
                  Type.getType(rightHand));
          Iterator extendedIter = extendedOps.iterator();
          while (type != null && extendedIter.hasNext())
              type = Type.getCommonType(type, 
                      Type.getType((Expression)extendedIter.next()));
          
      } else if (operator.equals(InfixExpression.Operator.LESS) ||
              operator.equals(InfixExpression.Operator.LESS_EQUALS) ||
              operator.equals(InfixExpression.Operator.GREATER) ||
              operator.equals(InfixExpression.Operator.GREATER_EQUALS) ||
              operator.equals(InfixExpression.Operator.CONDITIONAL_AND) ||
              operator.equals(InfixExpression.Operator.CONDITIONAL_OR) ||
              operator.equals(InfixExpression.Operator.EQUALS) ||
              operator.equals(InfixExpression.Operator.NOT_EQUALS))
          type = Type.BOOLEAN;
      else
          throw new UnknownASTException();

      if (type == null)
          throw new UnknownASTException();

      Type.setType(node, type);
  }

  /** Visit an <tt>instanceof</tt> expression and set its type to
   *  be boolean.
   *
   *  @param node The node to be visited.
   */
  public void endVisit(InstanceofExpression node) {
      Type.setType(node, Type.BOOLEAN);
  }

  /** Visit a literal node and set its type to be the same type as the
     *  literal.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(NullLiteral node) {
        Type.setType(node, Type.NULL);
    }

    /** Visit a literal node and set its type to be the same type as the
     *  literal.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(NumberLiteral node) {
        String token = node.getToken();
        if (!token.startsWith("0x") &&
                (token.indexOf('.') != -1 ||
                        token.endsWith("d") ||
                        token.endsWith("f"))) {  // double/float
            if (token.endsWith("f"))
                Type.setType(node, Type.FLOAT);
            else
                Type.setType(node, Type.DOUBLE);
        } else {    // int/long/short
            if (token.endsWith("l"))
                Type.setType(node, Type.LONG);
            else
                Type.setType(node, Type.INT);
        }
    }

    /** End the visit of a method declaration and close the scope
     *  opened by the previous visit function. The type of the method
     *  declaration is set to be the same as the return type.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(MethodDeclaration node) {
        _closeScope();
        Type.propagateType(node, node.getReturnType());
    }

    /** Visit a method invocation node and resolve the invoked method. The
     *  type of the node is set to the return type of the method.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(MethodInvocation node) {
        Expression expression = node.getExpression();
        Class owner = null;
        if (expression != null) {
            Type ownerType = null;
            ownerType = Type.getType(expression);
            try {
                owner = ownerType.toClass(_state.getClassLoader());
            } catch (ClassNotFoundException e) {
                throw new ASTClassNotFoundException(ownerType);
            }
        }

        Type[] types = argumentsToTypes(node.arguments());
        Type returnType = 
            _resolveMethod(owner, node.getName().getIdentifier(), types);
        if (returnType == null)
            throw new ASTResolutionException(
                    owner == null ? _state.getCurrentClass().getName() :
                        owner.getName(), 
                    node.getName().getIdentifier());
        else {
            Type.setType(node, returnType);
            Type.setType(node.getName(), returnType);
        }
    }

    /** End the visit of a package declaration and set the current package
     *  to be the full name of that declared package.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(PackageDeclaration node) {
        _state.getClassLoader().setCurrentPackage(node.getName().toString());
    }

    /** Propagate the type of the expression between the parentheses
     *  to this node.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(ParenthesizedExpression node) {
        Type.propagateType(node, node.getExpression());
    }

    /** Propagate the type of the its sub-expression to this node.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(PrefixExpression node) {
        Type.propagateType(node, node.getOperand());
    }

    /** Propagate the type of the its sub-expression to this node.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(PostfixExpression node) {
        Type.propagateType(node, node.getOperand());
    }

    /** Visit a primitive type node and set its type to be the corresponding
     *  primitive type.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(PrimitiveType node) {
        String typeName = node.getPrimitiveTypeCode().toString();
        Type.setType(node, Type.createType(typeName));
    }

    /** Visit a qualified name, resolve it in the current scope, and set
     *  its type to be the type of object referred to by that name.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(QualifiedName node) {
        Name qualifier = node.getQualifier();
        SimpleName name = node.getName();
        Type owner;

        if (qualifier instanceof SimpleName) {
            owner = _resolveName(((SimpleName)qualifier).getIdentifier(), null);
            Type.setType(qualifier, owner);
        } else
            owner = Type.getType(qualifier);

        Type nodeType;
        String resolveName;
        if (owner == null)
            resolveName = qualifier.toString() + "." + name.getIdentifier();
        else
            resolveName = name.getIdentifier();
        nodeType = _resolveName(resolveName, owner);

        // FIXME: Check for correctness.
        if (nodeType == null &&
                !(node.getParent() instanceof QualifiedName))
            throw new ASTResolutionException(
                    owner == null ? _state.getCurrentClass().getName() :
                        owner.getName(), 
                    resolveName);
        Type.setType(node, nodeType);
        Type.setType(name, nodeType);
    }

    /** Visit a simple name, and resolve it if possible. Some simple names
     *  are not resolved, such as the name of a class to be declared, and the
     *  name of a local variable in its definition.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(SimpleName node) {
        ASTNode parent = node.getParent();
        Type owner = null;

        // Do not type check some simple names.
        if (parent instanceof BodyDeclaration ||
                parent instanceof QualifiedName)
            return;
        else if (parent instanceof VariableDeclaration &&
                ((VariableDeclaration)parent).getName() == node)
            return;
        else if (parent instanceof ClassInstanceCreation &&
                ((ClassInstanceCreation)parent).getExpression() != null &&
                ((ClassInstanceCreation)parent).getName() == node)
            owner = 
                Type.getType(((ClassInstanceCreation)parent).getExpression());
        else if (parent instanceof MethodInvocation &&
                ((MethodInvocation)parent).getName() == node)
            return;
        else if (parent instanceof SuperMethodInvocation &&
                ((SuperMethodInvocation)parent).getName() == node)
            return;
        else if (parent instanceof SuperFieldAccess &&
                ((SuperFieldAccess)parent).getName() == node)
            return;

        String name = node.getIdentifier();
        Type type = _resolveName(name, owner);
        if (type == null) {
            String currentClassName = _state.getCurrentClass().getName();
            throw new ASTResolutionException(currentClassName, name);
        }
        Type.setType(node, type);
    }

    /** Visit a simple type node and set its type to be the same as the
     *  type associated with its name.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(SimpleType node) {
        Type.propagateType(node, node.getName());
    }

    /** Visit a single variable declaration and set its type to be the
     *  declared type. The variable is recorded in the current scope.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(SingleVariableDeclaration node) {
        Type type = Type.getType(node.getType());
        for (int i = 0; i < node.getExtraDimensions(); i++)
            type = type.addOneDimension();
        Type.setType(node, type);
        _state.addVariable(node.getName().getIdentifier(), type);
    }

    /** Visit a literal node and set its type to be the same type as the
     *  literal.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(StringLiteral node) {
        Type.setType(node, Type.createType("java.lang.String"));
    }

    /** Visit a super field access node (<tt>super.FieldName</tt>), and
     *  resolve the field from the superclass of the given class name
     *  (if any, like <tt>ClassName.super.FieldName</tt>) or from the
     *  superclass of the class being inspected.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(SuperFieldAccess node) {
        Name qualifier = node.getQualifier();
        Class owner = null;
        if (qualifier != null) {
            Type ownerType = null;
            ownerType = Type.getType(qualifier);
            try {
                owner = ownerType.toClass(_state.getClassLoader());
            } catch (ClassNotFoundException e) {
                throw new ASTClassNotFoundException(ownerType);
            }
        } else
            owner = _state.getCurrentClass();
        owner = owner.getSuperclass();

        if (owner == null)
            throw new UnknownASTException();

        Type type = 
            _resolveName(node.getName().getIdentifier(), 
                    Type.createType(owner.getName()));
        if (type == null)
            throw new ASTResolutionException(
                    owner == null ? _state.getCurrentClass().getName() :
                        owner.getName(), 
                    node.getName().getIdentifier());
        else
            Type.setType(node, type);
    }

    /** Visit a super method invocation node (<tt>super.method(...)</tt>), 
     *  resolve the method from the superclass of the given class name
     *  (if any, like <tt>ClassName.super.FieldName</tt>) or from the
     *  superclass of the class being inspected. The type of the node is
     *  set to be the same as the return type of the method.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(SuperMethodInvocation node) {
        Name qualifier = node.getQualifier();
        Class owner = null;
        if (qualifier != null) {
            Type ownerType = null;
            ownerType = Type.getType(qualifier);
            try {
                owner = ownerType.toClass(_state.getClassLoader());
            } catch (ClassNotFoundException e) {
                throw new ASTClassNotFoundException(ownerType);
            }
        } else
            owner = _state.getCurrentClass();
        owner = owner.getSuperclass();

        if (owner == null)
            throw new UnknownASTException();

        Type[] types = argumentsToTypes(node.arguments());
        Type returnType = 
            _resolveMethod(owner, node.getName().getIdentifier(), types);
        if (returnType == null)
            throw new ASTResolutionException(
                    owner == null ?
                            _state.getCurrentClass().getName() :
                            owner.getName(),  
                    node.getName().getIdentifier());
        else {
            Type.setType(node, returnType);
            Type.setType(node.getName(), returnType);
        }
    }

    /** Visit a <tt>this</tt> expression, and set its type to be
     *  the class preceding it (if any) or the class currently being
     *  inspected.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(ThisExpression node) {
        Name qualifier = node.getQualifier();
        if (qualifier != null)
            Type.propagateType(node, qualifier);
        else
            Type.setType(node, 
                    Type.createType(_state.getCurrentClass().getName()));
    }

    /** End the visit of a type declaration and close its scope. The
     *  current class is set back to the last visited class.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(TypeDeclaration node) {
        if (_handlers.hasClassHandler()) {
            List handlerList = _handlers.getClassHandlers();
            Iterator handlersIter = handlerList.iterator();
            while (handlersIter.hasNext()) {
                ClassHandler handler = (ClassHandler)handlersIter.next();
                handler.handle(node, _state);
            }
        }
        _state.unsetClassScope();
        _closeScope();
        _state.leaveClass();
    }

    /** Visit a literal node and set its type to be the same type as the
     *  literal.
     *  <p>
     *  A type literal is of the form "<tt>CLASSNAME.class</tt>", so its
     *  type is always {@link Class}.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(TypeLiteral node) {
        Type.setType(node, Type.createType("java.lang.Class"));
    }

    /** Visit a variable declaration expression and set its type to be
     *  the declared type.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(VariableDeclarationExpression node) {
        Type.propagateType(node, node.getType());
    }

    /** Visit a variable declaration fragment and set its type to be the
     *  declared type of the node's parent (a variable declaration or field
     *  declaration). The variable is recorded in the current scope.
     *
     *  @param node The node to be visited.
     */
    public void endVisit(VariableDeclarationFragment node) {
        Type type = null;
        ASTNode parent = node.getParent();
        if (parent instanceof VariableDeclarationStatement)
            type = 
                Type.getType(((VariableDeclarationStatement)parent).getType());
        else if (parent instanceof FieldDeclaration)
            type = Type.getType(((FieldDeclaration)parent).getType());
        else if (parent instanceof VariableDeclarationExpression)
            type = 
                Type.getType(((VariableDeclarationExpression)parent).getType());
        else
            throw new UnknownASTException();

        for (int i = 0; i < node.getExtraDimensions(); i++)
            type = type.addOneDimension();
        Type.setType(node, type);
        Type.setType(node.getName(), type);
        _state.addVariable(node.getName().getIdentifier(), type);
    }

    /** Get the list of handlers to be called back when traversing the AST.
     * 
     *  @return The list of handlers.
     */
    public HandlerList getHandlers() {
        return _handlers;
    }

    /** Take a list of Java files as input and type-check all of them.
     *  The result of the type-checking is written to the standard
     *  output.
     *
     *  @param args Command-line arguments, which is a list of Java files.
     *  @exception Exception If any error occurs.
     */
    public static void main(String[] args) throws Exception {
        if (args.length == 0)
            System.err.println("USAGE:" +
                    " java ptolemy.backtrack.ast.TypeAnalyzer" +
                    " [.java files...]");
        else {
            String[] paths = PathFinder.getPtClassPaths();
            Writer writer = new OutputStreamWriter(System.out);
            for (int i = 0; i < args.length; i++) {
                String fileName = args[i];
                CompilationUnit root = ASTBuilder.parse(fileName);

                TypeAnalyzer analyzer = new TypeAnalyzer(paths);
                root.accept(analyzer);

                ASTDump dump = new ASTDump(writer);
                root.accept(dump);
            }
            writer.close();
        }
    }

    /** Visit an anonymous class declaration and set the current class to
     *  be the {@link Class} object loaded with the same internal name. A
     *  scope is opened for field declarations in it.
     *
     *  @param node The node to be visited.
     *  @return The return value of the overriden function.
     */
    public boolean visit(AnonymousClassDeclaration node) {
        Class currentClass = _state.getCurrentClass();
        StringBuffer currentName = new StringBuffer(currentClass.getName());
        int dollarPos = currentName.indexOf("$");
        if (dollarPos >= 0)
            currentName.setLength(dollarPos);
        currentName.append('$');
        currentName.append(++_anonymousCount);
        try {
            currentClass = 
                _state.getClassLoader().searchForClass(currentName.toString());
            _state.enterClass(currentClass);
        } catch (ClassNotFoundException e) {
            throw new ASTClassNotFoundException(currentName.toString());
        }

        // A class declaration starts a new scope.
        _openScope();
        _state.setClassScope();
        _recordFields();

        // Sort body declarations.
        _sortBodyDeclarations(node);

        return super.visit(node);
    }

    /** Visit a block and open a scope for variable declarations in it.
     *
     *  @param node The node to be visited.
     *  @return The return value of the overriden function.
     */
    public boolean visit(Block node) {
        _openScope();
        return super.visit(node);
    }

    /** Visit an enhanced for statement and open a scope for variable
     *  declarations in it.
     *
     *  @param node The node to be visited.
     *  @return The return value of the overriden function.
     */
    public boolean visit(EnhancedForStatement node) {
        _openScope();
        return super.visit(node);
    }

    /** Visit a for statement and open a scope for variable declarations
     *  in it.
     *
     *  @param node The node to be visited.
     *  @return The return value of the overriden function.
     */
    public boolean visit(ForStatement node) {
        _openScope();
        return super.visit(node);
    }

    /** Override the behavior of visiting an importation declaration.
     *  Its children (simple names and qualified names) are not visited.
     *
     *  @param node The node to be visited.
     *  @return Always <tt>false</tt>.
     */
    public boolean visit(ImportDeclaration node) {
        // Do not visit children.
        return false;
    }

    /** Visit a method declaration and open a scope for variable
     *  declarations in it.
     *
     *  @param node The node to be visited.
     *  @return The return value of the overriden function.
     */
    public boolean visit(MethodDeclaration node) {
        _openScope();
        return super.visit(node);
    }

    /** Override the behavior of visiting a package declaration. Its
     *  children (simple names and qualified names) are not visited.
     *
     *  @param node The node to be visited.
     *  @return Always <tt>false</tt>.
     */
    public boolean visit(PackageDeclaration node) {
        // Do not visit children.
        return false;
    }

    /** Visit an type declaration and set the current class to be the
     *  {@link Class} object loaded with the same (internal) name. A
     *  scope is opened for field declarations in it.
     *
     *  @param node The node to be visited.
     *  @return The return value of the overriden function.
     */
    public boolean visit(TypeDeclaration node) {
        // Enter the class.
        String typeName = node.getName().getIdentifier();
        Class currentClass = _state.getCurrentClass();
        try {
            if (currentClass != null) {   // A inner class is found.
                typeName = currentClass.getName() + "$" + typeName;
                currentClass = _state.getClassLoader().searchForClass(typeName);
            } else
                currentClass = _state.getClassLoader().searchForClass(typeName);
            _state.enterClass(currentClass);
        } catch (ClassNotFoundException e) {
            throw new ASTClassNotFoundException(typeName);
        }

        // A class declaration starts a new scope.
        _openScope();
        _state.setClassScope();
        _recordFields();

        // Sort body declarations.
        _sortBodyDeclarations(node);

        // Tell calling function not to visit the children again.
        return super.visit(node);
    }

    ///////////////////////////////////////////////////////////////////
    ////                     protected methods                     ////

    /** Get the type of a field in a class by its name. If not found
     *  in the class definition, this function also searches the
     *  superclasses of that class, as well as the interfaces that
     *  the class and its superclasses implement.
     *
     *  @param c The class from which the field name is resolved.
     *  @param name The name of the field.
     *  @return The type of the field if found; otherwise, <tt>null</tt>.
     *  @see #_getMethodType(Class, String, Type[])
     */
    protected Type _getFieldType(Class c, String name) {
        // Try to resolve special field "length" of arrays.
        if (c.isArray() && name.equals("length"))
            return Type.INT;

        // Find the field with reflection.
        Field field;
        List workList = new LinkedList();
        Set handledSet = new HashSet();
        workList.add(c);

        while (!workList.isEmpty()) {
            Class topClass = (Class)workList.remove(0);

            try {
                field = topClass.getDeclaredField(name);
                return Type.createType(field.getType().getName());
            } catch (NoSuchFieldException e1) {
            }

            handledSet.add(topClass);
            Class superClass = topClass.getSuperclass();
            if (superClass == null &&
                    !topClass.getName().equals("java.lang.Object"))
                superClass = Object.class;
            if (superClass != null)
                workList.add(superClass);
            Class[] interfaces = topClass.getInterfaces();
            for (int i = 0; i < interfaces.length; i++)
                if (!handledSet.contains(interfaces[i]))
                    workList.add(interfaces[i]);
        }
        return null;
    }

    /** Get the type of a method in a class by its name and types of
     *  actural arguments. If not found in the class definition, this
     *  function also searches the superclasses of that class, as well
     *  as the interfaces that the class and its superclasses implement.
     *  <p>
     *  This function always tries to find the best match if multiple
     *  methods with the same name and the same number of arguments are
     *  defined in the class and interface hierarchy. This is
     *  accomplished by computing the compatibility rating between each
     *  pair of formal argument and actural argument, and sum those
     *  numbers together.
     *
     *  @param c The class from which the method is resolved.
     *  @param name The name of the field.
     *  @param args The types of actural arguments for a call.
     *  @return The return type of the method if found; otherwise, 
     *   <tt>null</tt>.
     *  @see #_getFieldType(Class, String)
     *  @see Type#compatibility(Type, ClassLoader)
     */
    protected Type _getMethodType(Class c, String name, Type[] args) {
        Method[] methods = null;
        int best_compatibility = -1;
        Method best_method = null;
        List workList = new LinkedList();
        Set handledSet = new HashSet();
        workList.add(c);

        while (!workList.isEmpty()) {
            Class topClass = (Class)workList.remove(0);
            methods = topClass.getDeclaredMethods();

            for (int i = 0; i < methods.length; i++) {
                Method method = methods[i];

                // FIXME: Ignore volatile methods.
                if (Modifier.isVolatile(method.getModifiers()))
                    continue;

                if (method.getName().equals(name)) {
                    Class[] formalParams = method.getParameterTypes();
                    if (formalParams.length == args.length) {
                        int compatibility = 0;
                        for (int j = 0; j < formalParams.length; j++)
                            try {
                                Type formalType = 
                                    Type.createType(formalParams[j].getName());
                                int comp = 
                                    args[j].compatibility(formalType, 
                                            _state.getClassLoader());
                                if (comp == -1) {
                                    compatibility = -1;
                                    break;
                                } else
                                    compatibility += comp;
                            } catch (ClassNotFoundException e) {
                                // Not exact.
                                throw new ASTClassNotFoundException(args[j]);
                            }
                        if (compatibility == -1)
                            continue;
                        else if (best_compatibility == -1 ||
                                best_compatibility > compatibility) {
                            best_compatibility = compatibility;
                            best_method = method;
                            if (best_compatibility == 0)    // The best found.
                                break;
                        }
                    }
                }
            }

            if (best_compatibility == 0)    // The best found.
                break;

            handledSet.add(topClass);
            Class superClass = topClass.getSuperclass();
            if (superClass == null &&
                    !topClass.getName().equals("java.lang.Object"))
                superClass = Object.class;
            if (superClass != null && !handledSet.contains(superClass))
                workList.add(superClass);
            Class[] interfaces = topClass.getInterfaces();
            for (int i = 0; i < interfaces.length; i++)
                if (!handledSet.contains(interfaces[i]))
                    workList.add(interfaces[i]);
        }

        if (best_compatibility != -1)
            return Type.createType(best_method.getReturnType().getName());
        else
            return null;
    }

    /** Sort the body declarations of an abstract type declaration. The
     *  resulting order conforms to the Java compiler.
     *  <p>
     *  The Java compiler takes a depth-first search to generate code for
     *  classes and members of classes. When inspecting a class, it first
     *  visits all the fields (and their children), then next visits all
     *  the nested classes defined in it (and their children), and finally
     *  visits all the methods (and their children).
     *  <p>
     *  Using a different order to traverse the Eclipse AST does not change
     *  the program semantics, but names of anonymous classes would be
     *  different because different numbers are assigned to them. This
     *  function sorts the declarations in a class in the same order as
     *  the Java compiler uses.
     *
     *  @param node The abstract type declaration whose members are to be
     *   sorted.
     */
    protected static void _sortBodyDeclarations(
            AbstractTypeDeclaration node) {
        _sortBodyDeclarations(node.bodyDeclarations());
    }

    /** Sort the body declarations of an anonymous class declaration. The
     *  resulting order conforms to the Java compiler.
     *  <p>
     *  The Java compiler takes a depth-first search to generate code for
     *  classes and members of classes. When inspecting a class, it first
     *  visits all the fields (and their children), then next visits all
     *  the nested classes defined in it (and their children), and finally
     *  visits all the methods (and their children).
     *  <p>
     *  Using a different order to traverse the Eclipse AST does not change
     *  the program semantics, but names of anonymous classes would be
     *  different because different numbers are assigned to them. This
     *  function sorts the declarations in a class in the same order as
     *  the Java compiler uses.
     *
     *  @param node The anonymous class declaration whose members are to be
     *   sorted.
     */
    protected static void _sortBodyDeclarations(
            AnonymousClassDeclaration node) {
        _sortBodyDeclarations(node.bodyDeclarations());
    }

    ///////////////////////////////////////////////////////////////////
    ////                      private methods                      ////

    /** Convert a list of arguments into an array of types of those arguments.
     *  Each argument in the list is an {@link ASTNode} with type associated
     *  to it.
     *
     *  @param arguments The argument list.
     *  @return The array of types of the arguments.
     */
    private Type[] argumentsToTypes(List arguments) {
        Type[] types = new Type[arguments.size()];
        Iterator argIter = arguments.iterator();
        for (int i = 0; argIter.hasNext(); i++)
            types[i] = Type.getType((ASTNode)argIter.next());
        return types;
    }

    /** Lookup a class with a partially given name as may
     *  appear in Java source code. The name may be relative
     *  to the current class and its enclosing classes. It
     *  may also be a full name.
     *
     *  @param partialSimpleName The partially given class
     *   name.
     *  @return The class; <tt>null</tt> is returned if the
     *   class cannot be found.
     */
    private Class _lookupClass(String partialSimpleName) {
        int dotPos = partialSimpleName.indexOf('.');
        String simpleName;
        if (dotPos == -1)
            simpleName = partialSimpleName;
        else
            simpleName = partialSimpleName.substring(0, dotPos);
        Class result = null;

        Stack previousClasses = _state.getPreviousClasses();
        int previousNumber = previousClasses.size();
        for (int i = previousNumber; i >= 0; i--) {
            Class workingClass = 
                i == previousNumber ?
                        _state.getCurrentClass() :
                        (Class)previousClasses.get(i);
            if (workingClass != null) {
                if (_getSimpleClassName(workingClass).equals(simpleName)) {
                    result = workingClass;
                    break;
                }
                Class[] declaredClasses = workingClass.getDeclaredClasses();
                for (int j = 0; j < declaredClasses.length; j++)
                    if (_getSimpleClassName(declaredClasses[j]).
                            equals(simpleName)) {
                        result = declaredClasses[j];
                        break;
                    }
                if (result != null)
                    break;
            }
        }

        // Look for imported classes.
        if (result == null && _importedClasses.containsKey(simpleName))
            result = (Class)_importedClasses.get(simpleName);

        // A result is found for simpleName.
        if (result != null && dotPos >= 0)
            try {
                result = 
                    _state.getClassLoader().loadClass(result.getName() +
                            partialSimpleName.substring(dotPos));
            } catch (ClassNotFoundException e) {
                result = null;
            }

        // Fall back to simple class loader.
        if (result == null)
            try {
                result = 
                    _state.getClassLoader().searchForClass(partialSimpleName);
            } catch (ClassNotFoundException e) {
            }

        return result;
    }

    /** Get the simple class name of a class (not including any
     *  "." or "$"). The same function is provided in {@link
     *  Class} class in Java 1.5.
     *
     *  @param c The class object.
     *  @return The simple name of the class object.
     */
    private String _getSimpleClassName(Class c) {
        String name = c.getName();
        int lastSeparator1 = name.lastIndexOf('.');
        int lastSeparator2 = name.lastIndexOf('$');
        int lastSeparator = 
            lastSeparator1 >= lastSeparator2 ? lastSeparator1 : lastSeparator2;
        return name.substring(lastSeparator + 1);
    }

    /** Import a class with its full name, using "." instead
     *  of "$" to separate names of nested classes when they
     *  are refered to. The imported class is added to a
     *  {@link Hashtable} to be looked up in name resolving.
     *
     *  @param classFullName The full name of the class to be
     *   imported.
     */
    private void _importClass(String classFullName) {
        int lastDotPos = classFullName.lastIndexOf('.');
        String simpleName = classFullName.substring(lastDotPos + 1);
        try {
            _importedClasses.put(simpleName, 
                    _state.getClassLoader().loadClass(classFullName));
        } catch (ClassNotFoundException e) {
            throw new ASTClassNotFoundException(classFullName);
        }
    }

    /** Open a new scope.
     */
    private void _openScope() {
        _state.getVariableStack().push(new Hashtable());
    }

    /** Close the last opened scope. All the variables defined in that scope
     *  are forgotten.
     */
    private void _closeScope() {
        _state.getVariableStack().pop();
    }

    /** Record all the fields of the currently inspecting class
     *  in the variable table on the top of the variable stack.
     */
    private void _recordFields() {
        Class c = _state.getCurrentClass();
        Hashtable table = (Hashtable)_state.getVariableStack().peek();
        while (c != null) {
            Field[] fields = c.getDeclaredFields();
            for (int i = 0; i < fields.length; i++) {
                Field field = fields[i];

                // FIXME: Ignore volatile fields.
                if (Modifier.isVolatile(field.getModifiers()))
                    continue;

                String fieldName = field.getName();
                if (!table.containsKey(fieldName)) {
                    Class fieldType = field.getType();
                    table.put(fieldName, Type.createType(fieldType.getName()));
                }
            }

            Class[] interfaces = c.getInterfaces();
            for (int i = 0; i < interfaces.length; i++) {
                fields = interfaces[i].getDeclaredFields();
                for (int j = 0; j < fields.length; j++) {
                    String fieldName = fields[j].getName();
                    if (!table.containsKey(fieldName)) {
                        Class fieldType = fields[j].getType();
                        table.put(fieldName, 
                                Type.createType(fieldType.getName()));
                    }
                }
            }

            Class superclass = c.getSuperclass();
            if (superclass == null && !c.getName().equals("java.lang.Object"))
                superclass = Object.class;
            c = superclass;
        }
    }

    /** Resolve a simple name within the scope of the given type. The name can
     *  be a variable name, a field name, or a class relative to that type. If
     *
     *  @param name The simple name to be resolved.
     *  @param lastType The type from which the name is resolved. It is used as
     *   the scope for the name. If it is null, the name is resolved in the
     *   current scope.
     */
    private Type _resolveName(String name, Type lastType) {
        // Not in a class yet.
        if (_state.getCurrentClass() == null)
            return null;

        if (lastType == null) {
            Type variableType = _state.getVariable(name);
            if (variableType != null)
                return variableType;

            Class c = _lookupClass(name);
            if (c != null)
                return Type.createType(c.getName());
        }

        Type type;
        if (lastType == null)
            type = _resolveNameFromClass(_state.getCurrentClass(), name);
        else
            try {
                type = 
                    _resolveNameFromClass(lastType.
                            toClass(_state.getClassLoader()), name);
            } catch (ClassNotFoundException e) {
                throw new ASTClassNotFoundException(lastType);
            }


        if (type == null && lastType == null) {
            Stack previousClasses = _state.getPreviousClasses();
            int previousNumber = previousClasses.size() - 1;
            while (type == null && previousNumber >= 0) {
                Class previousClass = 
                    (Class)previousClasses.get(previousNumber--);
                if (previousClass != null)
                    type = _resolveNameFromClass(previousClass, name);
            }
        }
        return type;
    }

    /** Resolve a method in the given class with an array of arguments.
     *
     *  @param owner The class where the method belongs to. If it is null, 
     *   the current class is assumed, and all the enclosing classes are
     *   searched, if necessary.
     *  @param methodName The name of the method.
     *  @param arguments The array of arguments.
     *  @return The return type of the method, or <tt>null</tt> if the
     *   method cannot be found.
     *  @see #_getMethodType(Class, String, Type[])
     */
    private Type _resolveMethod(Class owner, String methodName, 
            Type[] arguments) {
        Set handledSet = new HashSet();
        Stack previousClasses = _state.getPreviousClasses();
        int previousNum = previousClasses.size();
        Class oldOwner = owner;
        if (owner == null)
            owner = _state.getCurrentClass();

        do {
            Type type = _getMethodType(owner, methodName, arguments);
            if (type != null)
                return type;
            handledSet.add(owner);
            owner = null;
            if (oldOwner == null)
                while (owner == null && previousNum > 0) {
                    owner = (Class)previousClasses.get(--previousNum);
                    if (handledSet.contains(owner))
                        owner = null;
                }
        } while (owner != null);
        return null;
    }

    /** Resolve a name from a class. The name can be a field name, or the
     *  name of a class nested in the given class.
     *
     *  @param owner The class to be searched.
     *  @param name The name to search for.
     *  @return The type of the field or class if found, or <tt>null</tt>
     *   if not found.
     */
    private Type _resolveNameFromClass(Class owner, String name) {
        // Try to get the field.
        Type type = _getFieldType(owner, name);
        if (type != null)
            return type;

        // Try class name resolution.
        try {
            Class c = 
                _state.getClassLoader().searchForClass(new StringBuffer(name), 
                        owner);
            return Type.createType(c.getName());
        } catch (ClassNotFoundException e) {
            return null;
        }
    }

    /** Sort a list or body declarations according to the Java compiler
     *  convention.
     *
     *  @param bodyDeclarations The list of body declarations.
     *  @see #_sortBodyDeclarations(AbstractTypeDeclaration)
     *  @see #_sortBodyDeclarations(AnonymousClassDeclaration)
     */
    private static void _sortBodyDeclarations(List bodyDeclarations) {
        Object[] bodyArray = bodyDeclarations.toArray();
        Arrays.sort(bodyArray, new Comparator() {
            public int compare(Object o1, Object o2) {
                if (o1.getClass().isInstance(o2))
                    return 0;

                Class[] classes = new Class[] {
                        FieldDeclaration.class, 
                        TypeDeclaration.class, 
                        MethodDeclaration.class
                };
                for (int i = 0; i < classes.length; i++)
                    if (classes[i].isInstance(o1))
                        for (int j = i + 1; j < classes.length; j++)
                            if (classes[j].isInstance(o2))
                                return -1;
                return 1;
            }
        });
        bodyDeclarations.clear();
        bodyDeclarations.addAll(Arrays.asList(bodyArray));
    }

    /** Table of all the explicitly imported classes (not including
     *  package importations). Keys are class names; values are {@link
     *  Class} objects.
     */
    private Hashtable _importedClasses = new Hashtable();

    /** The current state of the analyzer.
     */
    private TypeAnalyzerState _state = new TypeAnalyzerState();

    /** The counter for anonymous classes.
     */
    private int _anonymousCount = 0;
    
    /** The list of handlers to be called back when traversing the AST.
     */
    private HandlerList _handlers = new HandlerList();
}
