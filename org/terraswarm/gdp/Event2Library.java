package org.terraswarm.gdp;
import org.ptolemy.fmi.NativeSizeT; //Use NativeSizeT intead of NativeSize
// import com.ochafik.lang.jnaerator.runtime.NativeSizeTByReference; // Commented out by makefile because NativeSizeTByReference is not in jna.
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import org.terraswarm.gdp.evbuffer_ptr.ByValue;
/**
 * JNA Wrapper for library <b>event2</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Event2Library extends Library {
	public static final String JNA_LIBRARY_NAME = "event2";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(Event2Library.JNA_LIBRARY_NAME);
	public static final Event2Library INSTANCE = (Event2Library)Native.loadLibrary(Event2Library.JNA_LIBRARY_NAME, Event2Library.class);
	/**
	 * Used to tell evbuffer_readln what kind of line-ending to look for.<br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:203</i><br>
	 * enum values
	 */
	public static interface evbuffer_eol_style {
		/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:199</i> */
		public static final int EVBUFFER_EOL_ANY = 0;
		/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:200</i> */
		public static final int EVBUFFER_EOL_CRLF = 1;
		/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:201</i> */
		public static final int EVBUFFER_EOL_CRLF_STRICT = 2;
		/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:202</i> */
		public static final int EVBUFFER_EOL_LF = 3;
	};
	/**
	 * Defines how to adjust an evbuffer_ptr by evbuffer_ptr_set()<br>
	 * @see evbuffer_ptr_set()<br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:362</i><br>
	 * enum values
	 */
	public static interface evbuffer_ptr_how {
		/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:360</i> */
		public static final int EVBUFFER_PTR_SET = 0;
		/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:361</i> */
		public static final int EVBUFFER_PTR_ADD = 1;
	};
	/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h</i> */
	public static final int EVBUFFER_CB_ENABLED = (int)1;
	/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h</i> */
	public static final int EVBUFFER_FLAG_DRAINS_TO_FD = (int)1;
	/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:234</i> */
	public interface evbuffer_ref_cleanup_cb extends Callback {
		void apply(Pointer data, NativeSizeT datalen, Pointer extra);
	};
	/** <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:443</i> */
	public interface evbuffer_cb_func extends Callback {
		void apply(Event2Library.evbuffer buffer, evbuffer_cb_info info, Pointer arg);
	};
	/**
	 * Allocate storage for a new evbuffer.<br>
	 * @return a pointer to a newly allocated evbuffer struct, or NULL if an error<br>
	 * occurred<br>
	 * Original signature : <code>evbuffer* evbuffer_new()</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:27</i>
	 */
	Event2Library.evbuffer evbuffer_new();
	/**
	 * Deallocate storage for an evbuffer.<br>
	 * @param buf pointer to the evbuffer to be freed<br>
	 * Original signature : <code>void evbuffer_free(evbuffer*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:33</i>
	 */
	void evbuffer_free(Event2Library.evbuffer buf);
	/**
	 * Enable locking on an evbuffer so that it can safely be used by multiple<br>
	 * threads at the same time.<br>
	 * NOTE: when locking is enabled, the lock will be held when callbacks are<br>
	 * invoked.  This could result in deadlock if you aren't careful.  Plan<br>
	 * accordingly!<br>
	 * @param buf An evbuffer to make lockable.<br>
	 * @param lock A lock object, or NULL if we should allocate our own.<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_enable_locking(evbuffer*, void*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:45</i>
	 */
	int evbuffer_enable_locking(Event2Library.evbuffer buf, Pointer lock);
	/**
	 * Acquire the lock on an evbuffer.  Has no effect if locking was not enabled<br>
	 * with evbuffer_enable_locking.<br>
	 * Original signature : <code>void evbuffer_lock(evbuffer*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:51</i>
	 */
	void evbuffer_lock(Event2Library.evbuffer buf);
	/**
	 * Release the lock on an evbuffer.  Has no effect if locking was not enabled<br>
	 * with evbuffer_enable_locking.<br>
	 * Original signature : <code>void evbuffer_unlock(evbuffer*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:57</i>
	 */
	void evbuffer_unlock(Event2Library.evbuffer buf);
	/**
	 * Change the flags that are set for an evbuffer by adding more.<br>
	 * @param buffer the evbuffer that the callback is watching.<br>
	 * @param cb the callback whose status we want to change.<br>
	 * @param flags One or more EVBUFFER_FLAG_* options<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_set_flags(evbuffer*, uint64_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:66</i>
	 */
	int evbuffer_set_flags(Event2Library.evbuffer buf, long flags);
	/**
	 * Change the flags that are set for an evbuffer by removing some.<br>
	 * @param buffer the evbuffer that the callback is watching.<br>
	 * @param cb the callback whose status we want to change.<br>
	 * @param flags One or more EVBUFFER_FLAG_* options<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_clear_flags(evbuffer*, uint64_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:75</i>
	 */
	int evbuffer_clear_flags(Event2Library.evbuffer buf, long flags);
	/**
	 * Returns the total number of bytes stored in the evbuffer<br>
	 * @param buf pointer to the evbuffer<br>
	 * @return the number of bytes stored in the evbuffer<br>
	 * Original signature : <code>size_t evbuffer_get_length(evbuffer*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:82</i>
	 */
	NativeSizeT evbuffer_get_length(Event2Library.evbuffer buf);
	/**
	 * Returns the number of contiguous available bytes in the first buffer chain.<br>
	 * This is useful when processing data that might be split into multiple<br>
	 * chains, or that might all be in the first chain.  Calls to<br>
	 * evbuffer_pullup() that cause reallocation and copying of data can thus be<br>
	 * avoided.<br>
	 * @param buf pointer to the evbuffer<br>
	 * @return 0 if no data is available, otherwise the number of available bytes<br>
	 * in the first buffer chain.<br>
	 * Original signature : <code>size_t evbuffer_get_contiguous_space(evbuffer*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:94</i>
	 */
	NativeSizeT evbuffer_get_contiguous_space(Event2Library.evbuffer buf);
	/**
	 * Expands the available space in an evbuffer.<br>
	 * Expands the available space in the evbuffer to at least datlen, so that<br>
	 * appending datlen additional bytes will not require any new allocations.<br>
	 * @param buf the evbuffer to be expanded<br>
	 * @param datlen the new minimum length requirement<br>
	 * @return 0 if successful, or -1 if an error occurred<br>
	 * Original signature : <code>int evbuffer_expand(evbuffer*, size_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:104</i>
	 */
	int evbuffer_expand(Event2Library.evbuffer buf, NativeSizeT datlen);
	/**
	 * Reserves space in the last chain or chains of an evbuffer.<br>
	 * Makes space available in the last chain or chains of an evbuffer that can<br>
	 * be arbitrarily written to by a user.  The space does not become<br>
	 * available for reading until it has been committed with<br>
	 * evbuffer_commit_space().<br>
	 * The space is made available as one or more extents, represented by<br>
	 * an initial pointer and a length.  You can force the memory to be<br>
	 * available as only one extent.  Allowing more extents, however, makes the<br>
	 * function more efficient.<br>
	 * Multiple subsequent calls to this function will make the same space<br>
	 * available until evbuffer_commit_space() has been called.<br>
	 * It is an error to do anything that moves around the buffer's internal<br>
	 * memory structures before committing the space.<br>
	 * NOTE: The code currently does not ever use more than two extents.<br>
	 * This may change in future versions.<br>
	 * @param buf the evbuffer in which to reserve space.<br>
	 * @param size how much space to make available, at minimum.  The<br>
	 * total length of the extents may be greater than the requested<br>
	 * length.<br>
	 * @param vec an array of one or more evbuffer_iovec structures to<br>
	 * hold pointers to the reserved extents of memory.<br>
	 * @param n_vec The length of the vec array.  Must be at least 1;<br>
	 * 2 is more efficient.<br>
	 * @return the number of provided extents, or -1 on error.<br>
	 * @see evbuffer_commit_space()<br>
	 * Original signature : <code>int evbuffer_reserve_space(evbuffer*, ssize_t, iovec*, int)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:133</i>
	 */
	int evbuffer_reserve_space(Event2Library.evbuffer buf, NativeLong size, Event2Library.iovec vec, int n_vec);
	/**
	 * Commits previously reserved space.<br>
	 * Commits some of the space previously reserved with<br>
	 * evbuffer_reserve_space().  It then becomes available for reading.<br>
	 * This function may return an error if the pointer in the extents do<br>
	 * not match those returned from evbuffer_reserve_space, or if data<br>
	 * has been added to the buffer since the space was reserved.<br>
	 * If you want to commit less data than you got reserved space for,<br>
	 * modify the iov_len pointer of the appropriate extent to a smaller<br>
	 * value.  Note that you may have received more space than you<br>
	 * requested if it was available!<br>
	 * @param buf the evbuffer in which to reserve space.<br>
	 * @param vec one or two extents returned by evbuffer_reserve_space.<br>
	 * @param n_vecs the number of extents.<br>
	 * @return 0 on success, -1 on error<br>
	 * @see evbuffer_reserve_space()<br>
	 * Original signature : <code>int evbuffer_commit_space(evbuffer*, iovec*, int)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:152</i>
	 */
	int evbuffer_commit_space(Event2Library.evbuffer buf, Event2Library.iovec vec, int n_vecs);
	/**
	 * Append data to the end of an evbuffer.<br>
	 * @param buf the evbuffer to be appended to<br>
	 * @param data pointer to the beginning of the data buffer<br>
	 * @param datlen the number of bytes to be copied from the data buffer<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_add(evbuffer*, const void*, size_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:161</i>
	 */
	int evbuffer_add(Event2Library.evbuffer buf, Pointer data, NativeSizeT datlen);
	/**
	 * Read data from an evbuffer and drain the bytes read.<br>
	 * If more bytes are requested than are available in the evbuffer, we<br>
	 * only extract as many bytes as were available.<br>
	 * @param buf the evbuffer to be read from<br>
	 * @param data the destination buffer to store the result<br>
	 * @param datlen the maximum size of the destination buffer<br>
	 * @return the number of bytes read, or -1 if we can't drain the buffer.<br>
	 * Original signature : <code>int evbuffer_remove(evbuffer*, void*, size_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:172</i>
	 */
	int evbuffer_remove(Event2Library.evbuffer buf, Pointer data, NativeSizeT datlen);
	/**
	 * Read data from an evbuffer, and leave the buffer unchanged.<br>
	 * If more bytes are requested than are available in the evbuffer, we<br>
	 * only extract as many bytes as were available.<br>
	 * @param buf the evbuffer to be read from<br>
	 * @param data_out the destination buffer to store the result<br>
	 * @param datlen the maximum size of the destination buffer<br>
	 * @return the number of bytes read, or -1 if we can't drain the buffer.<br>
	 * Original signature : <code>ssize_t evbuffer_copyout(evbuffer*, void*, size_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:183</i>
	 */
	NativeLong evbuffer_copyout(Event2Library.evbuffer buf, Pointer data_out, NativeSizeT datlen);
	/**
	 * Read data from an evbuffer into another evbuffer, draining<br>
	 * the bytes from the source buffer.  This function avoids copy<br>
	 * operations to the extent possible.<br>
	 * If more bytes are requested than are available in src, the src<br>
	 * buffer is drained completely.<br>
	 * @param src the evbuffer to be read from<br>
	 * @param dst the destination evbuffer to store the result into<br>
	 * @param datlen the maximum numbers of bytes to transfer<br>
	 * @return the number of bytes read<br>
	 * Original signature : <code>int evbuffer_remove_buffer(evbuffer*, evbuffer*, size_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:196</i>
	 */
	int evbuffer_remove_buffer(Event2Library.evbuffer src, Event2Library.evbuffer dst, NativeSizeT datlen);
	/**
	 * Read a single line from an evbuffer.<br>
	 * Reads a line terminated by an EOL as determined by the evbuffer_eol_style<br>
	 * argument.  Returns a newly allocated nul-terminated string; the caller must<br>
	 * free the returned value.  The EOL is not included in the returned string.<br>
	 * @param buffer the evbuffer to read from<br>
	 * @param n_read_out if non-NULL, points to a size_t that is set to the<br>
	 *       number of characters in the returned string.  This is useful for<br>
	 *       strings that can contain NUL characters.<br>
	 * @param eol_style the style of line-ending to use.<br>
	 * @return pointer to a single line, or NULL if an error occurred<br>
	 * Original signature : <code>char* evbuffer_readln(evbuffer*, size_t*, evbuffer_eol_style)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:217</i>
	 */
// 	Pointer evbuffer_readln(Event2Library.evbuffer buffer, NativeSizeTByReference n_read_out, int eol_style); // Commented out by makefile because NativeSizeTByReference is not in jna.
	/**
	 * Move all data from one evbuffer into another evbuffer.<br>
	 * This is a destructive add.  The data from one buffer moves into<br>
	 * the other buffer.  However, no unnecessary memory copies occur.<br>
	 * @param outbuf the output buffer<br>
	 * @param inbuf the input buffer<br>
	 * @return 0 if successful, or -1 if an error occurred<br>
	 * @see evbuffer_remove_buffer()<br>
	 * Original signature : <code>int evbuffer_add_buffer(evbuffer*, evbuffer*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:228</i>
	 */
	int evbuffer_add_buffer(Event2Library.evbuffer outbuf, Event2Library.evbuffer inbuf);
	/**
	 * Reference memory into an evbuffer without copying.<br>
	 * The memory needs to remain valid until all the added data has been<br>
	 * read.  This function keeps just a reference to the memory without<br>
	 * actually incurring the overhead of a copy.<br>
	 * @param outbuf the output buffer<br>
	 * @param data the memory to reference<br>
	 * @param datlen how memory to reference<br>
	 * @param cleanupfn callback to be invoked when the memory is no longer<br>
	 * referenced by this evbuffer.<br>
	 * @param cleanupfn_arg optional argument to the cleanup callback<br>
	 * @return 0 if successful, or -1 if an error occurred<br>
	 * Original signature : <code>int evbuffer_add_reference(evbuffer*, const void*, size_t, evbuffer_ref_cleanup_cb, void*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:249</i>
	 */
	int evbuffer_add_reference(Event2Library.evbuffer outbuf, Pointer data, NativeSizeT datlen, Event2Library.evbuffer_ref_cleanup_cb cleanupfn, Pointer cleanupfn_arg);
	/**
	 * Copy data from a file into the evbuffer for writing to a socket.<br>
	 * This function avoids unnecessary data copies between userland and<br>
	 * kernel.  If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD<br>
	 * flag is set, it uses those functions.  Otherwise, it tries to use<br>
	 * mmap (or CreateFileMapping on Windows).<br>
	 * The function owns the resulting file descriptor and will close it<br>
	 * when finished transferring data.<br>
	 * The results of using evbuffer_remove() or evbuffer_pullup() on<br>
	 * evbuffers whose data was added using this function are undefined.<br>
	 * @param outbuf the output buffer<br>
	 * @param fd the file descriptor<br>
	 * @param offset the offset from which to read data<br>
	 * @param length how much data to read<br>
	 * @return 0 if successful, or -1 if an error occurred<br>
	 * Original signature : <code>int evbuffer_add_file(evbuffer*, int, off_t, off_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:267</i>
	 */
	int evbuffer_add_file(Event2Library.evbuffer outbuf, int fd, long offset, long length);
	/**
	 * Append a formatted string to the end of an evbuffer.<br>
	 * The string is formated as printf.<br>
	 * @param buf the evbuffer that will be appended to<br>
	 * @param fmt a format string<br>
	 * @param ... arguments that will be passed to printf(3)<br>
	 * @return The number of bytes added if successful, or -1 if an error occurred.<br>
	 * @see evutil_printf(), evbuffer_add_vprintf()<br>
	 * Original signature : <code>int evbuffer_add_printf(evbuffer*, const char*, null)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:278</i><br>
	 * @deprecated use the safer methods {@link #evbuffer_add_printf(org.terraswarm.gdp.Event2Library.evbuffer, java.lang.String, java.lang.Object)} and {@link #evbuffer_add_printf(org.terraswarm.gdp.Event2Library.evbuffer, com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	int evbuffer_add_printf(Event2Library.evbuffer buf, Pointer fmt, Object... varArgs1);
	/**
	 * Append a formatted string to the end of an evbuffer.<br>
	 * The string is formated as printf.<br>
	 * @param buf the evbuffer that will be appended to<br>
	 * @param fmt a format string<br>
	 * @param ... arguments that will be passed to printf(3)<br>
	 * @return The number of bytes added if successful, or -1 if an error occurred.<br>
	 * @see evutil_printf(), evbuffer_add_vprintf()<br>
	 * Original signature : <code>int evbuffer_add_printf(evbuffer*, const char*, null)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:278</i>
	 */
	int evbuffer_add_printf(Event2Library.evbuffer buf, String fmt, Object... varArgs1);
	/**
	 * Append a va_list formatted string to the end of an evbuffer.<br>
	 * @param buf the evbuffer that will be appended to<br>
	 * @param fmt a format string<br>
	 * @param ap a varargs va_list argument array that will be passed to vprintf(3)<br>
	 * @return The number of bytes added if successful, or -1 if an error occurred.<br>
	 * Original signature : <code>int evbuffer_add_vprintf(evbuffer*, const char*, va_list)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:287</i><br>
	 * @deprecated use the safer methods {@link #evbuffer_add_vprintf(org.terraswarm.gdp.Event2Library.evbuffer, java.lang.String, java.lang.Object)} and {@link #evbuffer_add_vprintf(org.terraswarm.gdp.Event2Library.evbuffer, com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	int evbuffer_add_vprintf(Event2Library.evbuffer buf, Pointer fmt, Object... ap);
	/**
	 * Append a va_list formatted string to the end of an evbuffer.<br>
	 * @param buf the evbuffer that will be appended to<br>
	 * @param fmt a format string<br>
	 * @param ap a varargs va_list argument array that will be passed to vprintf(3)<br>
	 * @return The number of bytes added if successful, or -1 if an error occurred.<br>
	 * Original signature : <code>int evbuffer_add_vprintf(evbuffer*, const char*, va_list)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:287</i>
	 */
	int evbuffer_add_vprintf(Event2Library.evbuffer buf, String fmt, Object... ap);
	/**
	 * Remove a specified number of bytes data from the beginning of an evbuffer.<br>
	 * @param buf the evbuffer to be drained<br>
	 * @param len the number of bytes to drain from the beginning of the buffer<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_drain(evbuffer*, size_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:295</i>
	 */
	int evbuffer_drain(Event2Library.evbuffer buf, NativeSizeT len);
	/**
	 * Write the contents of an evbuffer to a file descriptor.<br>
	 * The evbuffer will be drained after the bytes have been successfully written.<br>
	 * @param buffer the evbuffer to be written and drained<br>
	 * @param fd the file descriptor to be written to<br>
	 * @return the number of bytes written, or -1 if an error occurred<br>
	 * @see evbuffer_read()<br>
	 * Original signature : <code>int evbuffer_write(evbuffer*, int)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:305</i>
	 */
	int evbuffer_write(Event2Library.evbuffer buffer, int fd);
	/**
	 * Write some of the contents of an evbuffer to a file descriptor.<br>
	 * The evbuffer will be drained after the bytes have been successfully written.<br>
	 * @param buffer the evbuffer to be written and drained<br>
	 * @param fd the file descriptor to be written to<br>
	 * @param howmuch the largest allowable number of bytes to write, or -1<br>
	 * to write as many bytes as we can.<br>
	 * @return the number of bytes written, or -1 if an error occurred<br>
	 * @see evbuffer_read()<br>
	 * Original signature : <code>int evbuffer_write_atmost(evbuffer*, int, ssize_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:317</i>
	 */
	int evbuffer_write_atmost(Event2Library.evbuffer buffer, int fd, NativeLong howmuch);
	/**
	 * Read from a file descriptor and store the result in an evbuffer.<br>
	 * @param buffer the evbuffer to store the result<br>
	 * @param fd the file descriptor to read from<br>
	 * @param howmuch the number of bytes to be read<br>
	 * @return the number of bytes read, or -1 if an error occurred<br>
	 * @see evbuffer_write()<br>
	 * Original signature : <code>int evbuffer_read(evbuffer*, int, int)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:327</i>
	 */
	int evbuffer_read(Event2Library.evbuffer buffer, int fd, int howmuch);
	/**
	 * Search for a string within an evbuffer.<br>
	 * @param buffer the evbuffer to be searched<br>
	 * @param what the string to be searched for<br>
	 * @param len the length of the search string<br>
	 * @param start NULL or a pointer to a valid struct evbuffer_ptr.<br>
	 * @return a struct evbuffer_ptr whose 'pos' field has the offset of the<br>
	 * first occurrence of the string in the buffer after 'start'.  The 'pos'<br>
	 * field of the result is -1 if the string was not found.<br>
	 * Original signature : <code>evbuffer_ptr evbuffer_search(evbuffer*, const char*, size_t, evbuffer_ptr*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:339</i><br>
	 * @deprecated use the safer methods {@link #evbuffer_search(org.terraswarm.gdp.Event2Library.evbuffer, java.lang.String, com.ochafik.lang.jnaerator.runtime.NativeSizeT, org.terraswarm.gdp.evbuffer_ptr)} and {@link #evbuffer_search(org.terraswarm.gdp.Event2Library.evbuffer, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSizeT, org.terraswarm.gdp.evbuffer_ptr)} instead
	 */
	@Deprecated 
	evbuffer_ptr.ByValue evbuffer_search(Event2Library.evbuffer buffer, Pointer what, NativeSizeT len, evbuffer_ptr start);
	/**
	 * Search for a string within an evbuffer.<br>
	 * @param buffer the evbuffer to be searched<br>
	 * @param what the string to be searched for<br>
	 * @param len the length of the search string<br>
	 * @param start NULL or a pointer to a valid struct evbuffer_ptr.<br>
	 * @return a struct evbuffer_ptr whose 'pos' field has the offset of the<br>
	 * first occurrence of the string in the buffer after 'start'.  The 'pos'<br>
	 * field of the result is -1 if the string was not found.<br>
	 * Original signature : <code>evbuffer_ptr evbuffer_search(evbuffer*, const char*, size_t, evbuffer_ptr*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:339</i>
	 */
	evbuffer_ptr.ByValue evbuffer_search(Event2Library.evbuffer buffer, String what, NativeSizeT len, evbuffer_ptr start);
	/**
	 * Search for a string within part of an evbuffer.<br>
	 * @param buffer the evbuffer to be searched<br>
	 * @param what the string to be searched for<br>
	 * @param len the length of the search string<br>
	 * @param start NULL or a pointer to a valid struct evbuffer_ptr that<br>
	 * indicates where we should start searching.<br>
	 * @param end NULL or a pointer to a valid struct evbuffer_ptr that<br>
	 * indicates where we should stop searching.<br>
	 * @return a struct evbuffer_ptr whose 'pos' field has the offset of the<br>
	 * first occurrence of the string in the buffer after 'start'.  The 'pos'<br>
	 * field of the result is -1 if the string was not found.<br>
	 * Original signature : <code>evbuffer_ptr evbuffer_search_range(evbuffer*, const char*, size_t, evbuffer_ptr*, evbuffer_ptr*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:354</i><br>
	 * @deprecated use the safer methods {@link #evbuffer_search_range(org.terraswarm.gdp.Event2Library.evbuffer, java.lang.String, com.ochafik.lang.jnaerator.runtime.NativeSizeT, org.terraswarm.gdp.evbuffer_ptr, org.terraswarm.gdp.evbuffer_ptr)} and {@link #evbuffer_search_range(org.terraswarm.gdp.Event2Library.evbuffer, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSizeT, org.terraswarm.gdp.evbuffer_ptr, org.terraswarm.gdp.evbuffer_ptr)} instead
	 */
	@Deprecated 
	evbuffer_ptr.ByValue evbuffer_search_range(Event2Library.evbuffer buffer, Pointer what, NativeSizeT len, evbuffer_ptr start, evbuffer_ptr end);
	/**
	 * Search for a string within part of an evbuffer.<br>
	 * @param buffer the evbuffer to be searched<br>
	 * @param what the string to be searched for<br>
	 * @param len the length of the search string<br>
	 * @param start NULL or a pointer to a valid struct evbuffer_ptr that<br>
	 * indicates where we should start searching.<br>
	 * @param end NULL or a pointer to a valid struct evbuffer_ptr that<br>
	 * indicates where we should stop searching.<br>
	 * @return a struct evbuffer_ptr whose 'pos' field has the offset of the<br>
	 * first occurrence of the string in the buffer after 'start'.  The 'pos'<br>
	 * field of the result is -1 if the string was not found.<br>
	 * Original signature : <code>evbuffer_ptr evbuffer_search_range(evbuffer*, const char*, size_t, evbuffer_ptr*, evbuffer_ptr*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:354</i>
	 */
	evbuffer_ptr.ByValue evbuffer_search_range(Event2Library.evbuffer buffer, String what, NativeSizeT len, evbuffer_ptr start, evbuffer_ptr end);
	/**
	 * Sets the search pointer in the buffer to position.<br>
	 * If evbuffer_ptr is not initialized.  This function can only be called<br>
	 * with EVBUFFER_PTR_SET.<br>
	 * @param buffer the evbuffer to be search<br>
	 * @param ptr a pointer to a struct evbuffer_ptr<br>
	 * @param position the position at which to start the next search<br>
	 * @param how determines how the pointer should be manipulated.<br>
	 * @returns 0 on success or -1 otherwise<br>
	 * Original signature : <code>int evbuffer_ptr_set(evbuffer*, evbuffer_ptr*, size_t, evbuffer_ptr_how)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:374</i>
	 */
	int evbuffer_ptr_set(Event2Library.evbuffer buffer, evbuffer_ptr ptr, NativeSizeT position, int how);
	/**
	 * Search for an end-of-line string within an evbuffer.<br>
	 * @param buffer the evbuffer to be searched<br>
	 * @param start NULL or a pointer to a valid struct evbuffer_ptr to start<br>
	 * searching at.<br>
	 * @param eol_len_out If non-NULL, the pointed-to value will be set to<br>
	 * the length of the end-of-line string.<br>
	 * @param eol_style The kind of EOL to look for; see evbuffer_readln() for<br>
	 * more information<br>
	 * @return a struct evbuffer_ptr whose 'pos' field has the offset of the<br>
	 * first occurrence EOL in the buffer after 'start'.  The 'pos'<br>
	 * field of the result is -1 if the string was not found.<br>
	 * Original signature : <code>evbuffer_ptr evbuffer_search_eol(evbuffer*, evbuffer_ptr*, size_t*, evbuffer_eol_style)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:389</i>
	 */
// 	evbuffer_ptr.ByValue evbuffer_search_eol(Event2Library.evbuffer buffer, evbuffer_ptr start, NativeSizeTByReference eol_len_out, int eol_style); // Commented out by makefile because NativeSizeTByReference is not in jna.
	/**
	 * Function to peek at data inside an evbuffer without removing it or<br>
	 * copying it out.<br>
	 * Pointers to the data are returned by filling the 'vec_out' array<br>
	 * with pointers to one or more extents of data inside the buffer.<br>
	 * The total data in the extents that you get back may be more than<br>
	 * you requested (if there is more data last extent than you asked<br>
	 * for), or less (if you do not provide enough evbuffer_iovecs, or if<br>
	 * the buffer does not have as much data as you asked to see).<br>
	 * @param buffer the evbuffer to peek into,<br>
	 * @param len the number of bytes to try to peek.  If len is negative, we<br>
	 * will try to fill as much of vec_out as we can.  If len is negative<br>
	 * and vec_out is not provided, we return the number of evbuffer_iovecs<br>
	 * that would be needed to get all the data in the buffer.<br>
	 * @param start_at an evbuffer_ptr indicating the point at which we<br>
	 * should start looking for data.  NULL means, "At the start of the<br>
	 * buffer."<br>
	 * @param vec_out an array of evbuffer_iovec<br>
	 * @param n_vec the length of vec_out.  If 0, we only count how many<br>
	 * extents would be necessary to point to the requested amount of<br>
	 * data.<br>
	 * @return The number of extents needed.  This may be less than n_vec<br>
	 * if we didn't need all the evbuffer_iovecs we were given, or more<br>
	 * than n_vec if we would need more to return all the data that was<br>
	 * requested.<br>
	 * Original signature : <code>int evbuffer_peek(evbuffer*, ssize_t, evbuffer_ptr*, iovec*, int)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:417</i>
	 */
	int evbuffer_peek(Event2Library.evbuffer buffer, NativeLong len, evbuffer_ptr start_at, Event2Library.iovec vec_out, int n_vec);
	/**
	 * Add a new callback to an evbuffer.<br>
	 * Subsequent calls to evbuffer_add_cb() add new callbacks.  To remove this<br>
	 * callback, call evbuffer_remove_cb or evbuffer_remove_cb_entry.<br>
	 * @param buffer the evbuffer to be monitored<br>
	 * @param cb the callback function to invoke when the evbuffer is modified,<br>
	 * or NULL to remove all callbacks.<br>
	 * @param cbarg an argument to be provided to the callback function<br>
	 * @return a handle to the callback on success, or NULL on failure.<br>
	 * Original signature : <code>evbuffer_cb_entry* evbuffer_add_cb(evbuffer*, evbuffer_cb_func, void*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:456</i>
	 */
	Event2Library.evbuffer_cb_entry evbuffer_add_cb(Event2Library.evbuffer buffer, Event2Library.evbuffer_cb_func cb, Pointer cbarg);
	/**
	 * Remove a callback from an evbuffer, given a handle returned from<br>
	 * evbuffer_add_cb.<br>
	 * Calling this function invalidates the handle.<br>
	 * @return 0 if a callback was removed, or -1 if no matching callback was<br>
	 * found.<br>
	 * Original signature : <code>int evbuffer_remove_cb_entry(evbuffer*, evbuffer_cb_entry*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:465</i>
	 */
	int evbuffer_remove_cb_entry(Event2Library.evbuffer buffer, Event2Library.evbuffer_cb_entry ent);
	/**
	 * Remove a callback from an evbuffer, given the function and argument<br>
	 * used to add it.<br>
	 * @return 0 if a callback was removed, or -1 if no matching callback was<br>
	 * found.<br>
	 * Original signature : <code>int evbuffer_remove_cb(evbuffer*, evbuffer_cb_func, void*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:473</i>
	 */
	int evbuffer_remove_cb(Event2Library.evbuffer buffer, Event2Library.evbuffer_cb_func cb, Pointer cbarg);
	/**
	 * Change the flags that are set for a callback on a buffer by adding more.<br>
	 * @param buffer the evbuffer that the callback is watching.<br>
	 * @param cb the callback whose status we want to change.<br>
	 * @param flags EVBUFFER_CB_ENABLED to re-enable the callback.<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_cb_set_flags(evbuffer*, evbuffer_cb_entry*, uint32_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:482</i>
	 */
	int evbuffer_cb_set_flags(Event2Library.evbuffer buffer, Event2Library.evbuffer_cb_entry cb, int flags);
	/**
	 * Change the flags that are set for a callback on a buffer by removing some<br>
	 * @param buffer the evbuffer that the callback is watching.<br>
	 * @param cb the callback whose status we want to change.<br>
	 * @param flags EVBUFFER_CB_ENABLED to disable the callback.<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_cb_clear_flags(evbuffer*, evbuffer_cb_entry*, uint32_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:491</i>
	 */
	int evbuffer_cb_clear_flags(Event2Library.evbuffer buffer, Event2Library.evbuffer_cb_entry cb, int flags);
	/**
	 * Makes the data at the begging of an evbuffer contiguous.<br>
	 * @param buf the evbuffer to make contiguous<br>
	 * @param size the number of bytes to make contiguous, or -1 to make the<br>
	 * entire buffer contiguous.<br>
	 * @return a pointer to the contiguous memory array<br>
	 * Original signature : <code>char* evbuffer_pullup(evbuffer*, ssize_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:500</i>
	 */
	Pointer evbuffer_pullup(Event2Library.evbuffer buf, NativeLong size);
	/**
	 * Prepends data to the beginning of the evbuffer<br>
	 * @param buf the evbuffer to which to prepend data<br>
	 * @param data a pointer to the memory to prepend<br>
	 * @param size the number of bytes to prepend<br>
	 * @return 0 if successful, or -1 otherwise<br>
	 * Original signature : <code>int evbuffer_prepend(evbuffer*, const void*, size_t)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:509</i>
	 */
	int evbuffer_prepend(Event2Library.evbuffer buf, Pointer data, NativeSizeT size);
	/**
	 * Prepends all data from the src evbuffer to the beginning of the dst<br>
	 * evbuffer.<br>
	 * @param dst the evbuffer to which to prepend data<br>
	 * @param src the evbuffer to prepend; it will be emptied as a result<br>
	 * @return 0 if successful, or -1 otherwise<br>
	 * Original signature : <code>int evbuffer_prepend_buffer(evbuffer*, evbuffer*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:518</i>
	 */
	int evbuffer_prepend_buffer(Event2Library.evbuffer dst, Event2Library.evbuffer src);
	/**
	 * Prevent calls that modify an evbuffer from succeeding. A buffer may<br>
	 * frozen at the front, at the back, or at both the front and the back.<br>
	 * If the front of a buffer is frozen, operations that drain data from<br>
	 * the front of the buffer, or that prepend data to the buffer, will<br>
	 * fail until it is unfrozen.   If the back a buffer is frozen, operations<br>
	 * that append data from the buffer will fail until it is unfrozen.<br>
	 * @param buf The buffer to freeze<br>
	 * @param at_front If true, we freeze the front of the buffer.  If false,<br>
	 * we freeze the back.<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_freeze(evbuffer*, int)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:532</i>
	 */
	int evbuffer_freeze(Event2Library.evbuffer buf, int at_front);
	/**
	 * Re-enable calls that modify an evbuffer.<br>
	 * @param buf The buffer to un-freeze<br>
	 * @param at_front If true, we unfreeze the front of the buffer.  If false,<br>
	 * we unfreeze the back.<br>
	 * @return 0 on success, -1 on failure.<br>
	 * Original signature : <code>int evbuffer_unfreeze(evbuffer*, int)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:541</i>
	 */
	int evbuffer_unfreeze(Event2Library.evbuffer buf, int at_front);
	/**
	 * Force all the callbacks on an evbuffer to be run, not immediately after<br>
	 * the evbuffer is altered, but instead from inside the event loop.<br>
	 * This can be used to serialize all the callbacks to a single thread<br>
	 * of execution.<br>
	 * Original signature : <code>int evbuffer_defer_callbacks(evbuffer*, event_base*)</code><br>
	 * <i>native declaration : src/libevent-2.0.21-stable/include/event2/buffer.h:550</i>
	 */
	int evbuffer_defer_callbacks(Event2Library.evbuffer buffer, Event2Library.event_base base);
	public static class event_base extends PointerType {
		public event_base(Pointer address) {
			super(address);
		}
		public event_base() {
			super();
		}
	};
	public static class iovec extends PointerType {
		public iovec(Pointer address) {
			super(address);
		}
		public iovec() {
			super();
		}
	};
	public static class evbuffer extends PointerType {
		public evbuffer(Pointer address) {
			super(address);
		}
		public evbuffer() {
			super();
		}
	};
	public static class evbuffer_cb_entry extends PointerType {
		public evbuffer_cb_entry(Pointer address) {
			super(address);
		}
		public evbuffer_cb_entry() {
			super();
		}
	};
}
