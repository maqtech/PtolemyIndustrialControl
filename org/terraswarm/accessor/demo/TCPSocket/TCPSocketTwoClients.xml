<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="TCPSocketTwoClients" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={4, 22, 1077, 636}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[843, 526]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.1886601041237">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{199.39453125000006, 124.23275482067828}">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="20.0">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-90.0, -65.0}">
        </property>
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="bold" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Demonstrate sending to two distinct clients.&#10;One gets even numbers, the other gets odd numbers.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-25.0, -95.0}">
        </property>
    </property>
    <entity name="ServerConnected" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={920, 25, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{415.0, 125.0}">
        </property>
    </entity>
    <entity name="Client1Received" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={920, 243, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{380.0, 20.0}">
        </property>
    </entity>
    <entity name="TCPSocketClient1" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor sends and/or receives messages from a TCP socket at&#10; *  the specified host and port. Upon initialization, it initiates a connection to the&#10; *  specified server. When the connection is established, a `true` boolean is sent to&#10; *  the `connected` output.&#10; *&#10; *  Whenever an input is received on the `toSend` input,&#10; *  the data on that input is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when the socket opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `received` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  connection.&#10; *&#10; *  If the connection is dropped midway, the client will attempt to reconnect if&#10; *  `reconnectOnClose` is true. This does not apply after the accessor wraps up.&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item provided on `toSend`,&#10; *  of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent.&#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketClient&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *&#10; *  @parameter {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @parameter {int} port The port on the server to connect to. Defaults to 4000.&#10; *&#10; *  @parameter {int} connectTimeout The time to wait (in milliseconds) before declaring&#10; *    a connection attempt to have failed. This defaults to 6000.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then discard any messages&#10; *    passed to SocketClient.send() before the socket is opened. If false,&#10; *    then queue the messages to be sent when the socket opens. This&#10; *    defaults to false.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {int} maxUnsentMessages The maximum number of unsent messages to queue before&#10; *    further calls to send() will fail. A value of 0 means no limit.&#10; *    This defaults to 100.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available (the default).&#10; *    If false, data may be accumulated until a reasonable packet size is formed&#10; *    in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See above.&#10; *  @parameter {int} reconnectAttempts The number of times to try to reconnect.&#10; *    If this is greater than 0, then a failure to attempt will trigger&#10; *    additional attempts. This defaults to 10.&#10; *  @parameter {int} reconnectInterval The time between reconnect attempts, in&#10; *    milliseconds. This defaults to 100.&#10; *  @parameter {boolean} reconnectOnClose If true, then if the connection is closed&#10; *    before this accessor is wrapped up, then attempt to reconnect.&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See above.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {boolean} trustAll Whether to trust servers. This defaults to false.&#10; *    Setting it to true means that if sslTls is set to true, then&#10; *    any certificate provided by the server will be trusted.&#10; *    FIXME: Need to provide a trusted list if this is false.&#10; *&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;/* These are needed by JSLint, see https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSLint */&#10;&quot;use strict&quot;;&#10;/*global addInputHandler, error, get, getParameter, input, onClose, output, parameter, removeInputHandler, send */&#10;&#10;var socket = require('socket');&#10;var client = null;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    input('toSend');&#10;    output('connected', {&#10;        type : 'boolean'&#10;    });&#10;    output('received');&#10;&#10;    // The most used parameters are listed first.&#10;    parameter('host', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    &#10;    // The remaining parameters are in alphabetical order.&#10;    parameter('connectTimeout', {&#10;        value: 6000,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('discardMessagesBeforeOpen', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('idleTimeout', {&#10;        value: 0,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('maxUnsentMessages', {&#10;        value: 100,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;        options : socket.supportedReceiveTypes()&#10;    });&#10;    parameter('reconnectAttempts', {&#10;        type : 'int',&#10;        value : 10&#10;    });&#10;    parameter('reconnectInterval', {&#10;        type : 'int',&#10;        value : 100&#10;    });&#10;    parameter('reconnectOnClose', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;        options : socket.supportedSendTypes()&#10;    });&#10;    parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('trustAll', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;};&#10;&#10;/** Handles input on 'toSend'. */&#10;exports.toSendInputHandler = function () {&#10;    client.send(get('toSend'));&#10;};&#10;&#10;/** Initializes accessor by attaching functions to inputs. */&#10;exports.initialize = function () {&#10;&#10;    client = new socket.SocketClient(getParameter('port'), getParameter('host'),&#10;        {&#10;            'connectTimeout' : getParameter('connectTimeout'),&#10;            'discardMessagesBeforeOpen' : getParameter('discardMessagesBeforeOpen'),&#10;            'idleTimeout' : getParameter('idleTimeout'),&#10;            'keepAlive' : getParameter('keepAlive'),&#10;            'maxUnsentMessages' : getParameter('maxUnsentMessages'),&#10;            'noDelay' : getParameter('noDelay'),&#10;            'rawBytes' : getParameter('rawBytes'),&#10;            'receiveBufferSize' : getParameter('receiveBufferSize'),&#10;            'receiveType' : getParameter('receiveType'),&#10;            'reconnectAttempts' : getParameter('reconnectAttempts'),&#10;            'reconnectInterval' : getParameter('reconnectInterval'),&#10;            'sendBufferSize' : getParameter('sendBufferSize'),&#10;            'sendType' : getParameter('sendType'),&#10;            'sslTls' : getParameter('sslTls'),&#10;            'trustAll' : getParameter('trustAll'),&#10;        }&#10;    );&#10;&#10;    client.on('open', function() {&#10;        console.log('Status: Connection established');&#10;        send('connected', true);&#10;    });&#10;    client.on('data', function(data) {&#10;        send('received', data);&#10;    });&#10;&#10;    // Record the object that calls it (could be a derived accessor).&#10;    var callObj = this;&#10;&#10;    // Bind onClose() to caller's object, so that 'this' is defined&#10;    // in onClose() to be the object on which this initialize() function&#10;    // is called.&#10;    client.on('close', onClose.bind(callObj));&#10;    client.on('error', function (message) {&#10;        error(message);&#10;    });&#10;    addInputHandler('toSend', exports.toSendInputHandler.bind(callObj));&#10;};&#10;&#10;/** Send false to 'connected' output, and if 'reconnectOnClose'&#10; *  parameter evaluates to true and wrapup() has not been called,&#10; *  then invoke initialize().&#10; *  This will be called if either side closes the connection.&#10; *  @param message Possible message about the closure.&#10; */&#10;function onClose(message) {&#10;    console.log('Status: Connection closed: ' + message);&#10;    if (inputHandle) {&#10;        // wrapup() has not been called.&#10;        // Probably the server closed the connection.&#10;        send('connected', false);&#10;&#10;        // Close and unregister everything.&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client = null;&#10;&#10;        // Reconnect if reconnectOnClose is true.&#10;        if (getParameter('reconnectOnClose')) {&#10;            // Use 'this' rather than 'export' so initialize() can be overridden.&#10;            this.initialize();&#10;        }&#10;    }&#10;}&#10;&#10;/** Export the isOpen() function */&#10;exports.isOpen = function () {&#10;    return client.isOpen();&#10;}&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (client) {&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;        client = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/TCPSocketClient.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="host" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{240.0, 10.0}">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="TCPSocketServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor establishes a server that can accept connection requests for&#10; *  a TCP socket and can send and/or receives messages from the client that makes the&#10; *  request.&#10; *&#10; *  When the server is listening and accepting connections, a 'true' is emitted on the&#10; *  `listening` output port.&#10; *&#10; *  When a connection is established, this accessor outputs on the `connection` output&#10; *  an object with the following fields:&#10; *&#10; *  * **id**: A unique ID identifying the connection (a positive integer).&#10; *  * **remoteHost**: The IP address of the remote host for the socket (a string).&#10; *  * **remotePort**: The port of the remote host for the socket (an integer).&#10; *  * **status**: The string 'open'.&#10; *&#10; *  When the connection is closed, the same object as above is produced on the&#10; *  `connection` output, except with status being 'closed'.&#10; *&#10; *  When data is received from the connection, two outputs are produced.&#10; *  The data itself is produced on the `received` output.  The ID of the connection&#10; *  over which the data arrived is produced on the `receivedID` output.&#10; *&#10; *  To send data over a connection, provide the data on the `toSend` input port&#10; *  and the ID of the connection on the `toSendID` input port.  To send to all open&#10; *  connections, provide an ID of 0 (zero).&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item that arrives on&#10; *  `toSend`, of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *  The client might similarly lose messages by the same two mechanisms occurring&#10; *  on the client side. In that case, messages will presumably be displayed on the&#10; *  client side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent. &#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketClient&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @input toSendID The ID of the connection over which to send the data, where 0 means&#10; *    to send to all open connections.&#10; *  @output {int} listening When the server is listening for connections, this port will&#10; *    produce the port number that the server is listening on&#10; *    (this is useful if the port is specified to be 0).&#10; *  @output connection Output an object with the fields specified above when a&#10; *     connection is established.&#10; *  @output received The data received from the web socket server.&#10; *  @output receivedID The ID of the connection over which data produced on the received&#10; *    output was received. This is a positive integer, as indicated in the connection&#10; *    output.&#10; *&#10; *  @parameter {string} clientAuth: One of 'none', 'request', or 'required', meaning&#10; *    whether it requires that a certificate be presented.&#10; *  @parameter {string} hostInterface: The name of the network interface to use for&#10; *    listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10; *    listen on all available interfaces.&#10; *  @parameter {int} idleTimeout: The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} keepAlive: Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {string} keyStorePassword: If sslTls is set to true, then this option&#10; *    needs to specify the password for the key store specified by keyStorePath.&#10; *  @parameter {string} keyStorePath: If sslTls is set to true, then this option&#10; *    needs to specify the fully qualified filename for the file that stores the&#10; *    certificate that this server will use to identify itself. This path can be&#10; *    any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {boolean} noDelay: If true, data as sent as soon as it is available&#10; *    (the default). If false, data may be accumulated until a reasonable packet size is&#10; *    formed in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {int} port: The default port to listen on. This defaults to 4000.&#10; *    a value of 0 means to choose a random ephemeral free port.&#10; *  @parameter {boolean} rawBytes: If true (the default), then transmit only the data bytes provided&#10; *    to send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize: The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType: See below.&#10; *  @parameter {int} sendBufferSize: The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType: See below.&#10; *  @parameter {boolean} sslTls: Whether SSL/TLS is enabled. This defaults to false.&#10; *&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;/* These are needed by JSLint, see https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSLint */&#10;&quot;use strict&quot;;&#10;/*global addInputHandler, error, get, getParameter, input, onClose, output, parameter, removeInputHandler, send */&#10;&#10;var socket = require('socket');&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    input('toSend');&#10;    input('toSendID', {&#10;        type: 'int',&#10;        value: 0&#10;    });&#10;    output('listening', {&#10;        type: 'int'&#10;    });&#10;    output('connection');&#10;    output('received');&#10;    output('receivedID');&#10;&#10;    // The parameters below are listed alphabetically.&#10;    parameter('clientAuth', {&#10;        type : 'string',&#10;        value : 'none'    // Indicates no SSL/TSL will be used.&#10;    });&#10;    parameter('hostInterface', {&#10;        type : 'string',&#10;        value : '0.0.0.0' // Means listen on all available interfaces.&#10;    });&#10;    parameter('idleTimeout', {&#10;        value: 0,         // In seconds. 0 means don't timeout.&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('keyStorePassword', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('keyStorePath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false      // Means to use a messaging protocol.&#10;    });&#10;    parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;        options : socket.supportedReceiveTypes()&#10;    });&#10;    parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;        options : socket.supportedSendTypes()&#10;    });&#10;    parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;};&#10;&#10;var server = null;&#10;var connectionCount = 0;&#10;var sockets = [];&#10;&#10;/** Handles input on 'toSend'. */&#10;exports.toSendInputHandler = function () {&#10;    var dataToSend = get('toSend');&#10;    var idToSendTo = get('toSendID');&#10;    if (idToSendTo === 0) {&#10;        // Broadcast to all sockets.&#10;        for (var i = 0; i &lt; sockets.length; i++) {&#10;            if (sockets[i]) {&#10;                sockets[i].send(dataToSend);&#10;            }&#10;        }&#10;    } else if (sockets[idToSendTo]) {&#10;        sockets[idToSendTo].send(dataToSend);&#10;    } else {&#10;        error('Connection is not open: ' + idToSendTo);&#10;    }&#10;};&#10;&#10;/** Initialize the accessor by starting the server and&#10; *  attaching functions to inputs.&#10; */&#10;exports.initialize = function () {&#10;&#10;    server = new socket.SocketServer(&#10;        {&#10;            'clientAuth' : getParameter('clientAuth'),&#10;            'hostInterface' : getParameter('hostInterface'),&#10;            'idleTimeout' : getParameter('idleTimeout'),&#10;            'keepAlive' : getParameter('keepAlive'),&#10;            'keyStorePassword' : getParameter('keyStorePassword'),&#10;            'keyStorePath' : getParameter('keyStorePath'),&#10;            'noDelay' : getParameter('noDelay'),&#10;            'port' : getParameter('port'),&#10;            'rawBytes' : getParameter('rawBytes'),&#10;            'receiveBufferSize' : getParameter('receiveBufferSize'),&#10;            'receiveType' : getParameter('receiveType'),&#10;            'sendBufferSize' : getParameter('sendBufferSize'),&#10;            'sendType' : getParameter('sendType'),&#10;            'sslTls' : getParameter('sslTls')&#10;        }&#10;    );&#10;&#10;	server.on('error', function(message) {&#10;        error(message);&#10;	});&#10;	&#10;	server.on('listening', function(port) {&#10;        console.log('Server: Listening for socket connection requests.');&#10;		send('listening', port);&#10;	});&#10;	&#10;	server.on('connection', function(serverSocket) {&#10;		connectionCount++;&#10;		var socketID = {&#10;		    'id': connectionCount,&#10;		    'remoteHost': serverSocket.remoteHost(),&#10;		    'remotePort': serverSocket.remotePort(),&#10;		    'status': 'open'&#10;		};&#10;		send('connection', socketID);&#10;		&#10;		sockets[connectionCount] = serverSocket;&#10;&#10;		serverSocket.on('close', function() {&#10;		    serverSocket.removeAllListeners();&#10;		    socketID.status = 'closed';&#10;            send('connection', socketID);&#10;		    // Avoid a memory leak here.&#10;			sockets[connectionCount] = null;&#10;		});&#10;		serverSocket.on('data', function(data) {&#10;			send('received', data);&#10;			send('receivedID', connectionCount);&#10;		});&#10;		serverSocket.on('error', function(message) {&#10;            error(message);&#10;		});&#10;	});&#10;	&#10;    // Record the object that calls it (could be a derived accessor).&#10;    var callObj = this;&#10;    // Bind the input handler to caller's object so that when it is invoked,&#10;    // it is invoked in the context of that object and not this one.&#10;    addInputHandler('toSend', exports.toSendInputHandler.bind(callObj));&#10;};&#10;&#10;/** Close all sockets, unregister event listeners, and close the server.&#10; */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        if (sockets[i]) {&#10;            sockets[i].close();&#10;            sockets[i].removeAllListeners();&#10;        }&#10;    }&#10;&#10;    sockets = [];&#10;&#10;    if (server !== null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/TCPSocketServer.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="clientAuth" class="ptolemy.data.expr.Parameter" value="none">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="keyStorePassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="keyStorePath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{270.0, 135.0}">
        </property>
        <property name="toSendID" class="ptolemy.actor.parameters.PortParameter" value="0">
        </property>
        <port name="toSendID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="receivedID" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Client2Received" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={921, 459, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{75.0, 20.0}">
        </property>
    </entity>
    <entity name="TCPSocketClient2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor sends and/or receives messages from a TCP socket at&#10; *  the specified host and port. Upon initialization, it initiates a connection to the&#10; *  specified server. When the connection is established, a `true` boolean is sent to&#10; *  the `connected` output.&#10; *&#10; *  Whenever an input is received on the `toSend` input,&#10; *  the data on that input is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when the socket opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `received` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  connection.&#10; *&#10; *  If the connection is dropped midway, the client will attempt to reconnect if&#10; *  `reconnectOnClose` is true. This does not apply after the accessor wraps up.&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item provided on `toSend`,&#10; *  of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent.&#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketClient&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *&#10; *  @parameter {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @parameter {int} port The port on the server to connect to. Defaults to 4000.&#10; *&#10; *  @parameter {int} connectTimeout The time to wait (in milliseconds) before declaring&#10; *    a connection attempt to have failed. This defaults to 6000.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then discard any messages&#10; *    passed to SocketClient.send() before the socket is opened. If false,&#10; *    then queue the messages to be sent when the socket opens. This&#10; *    defaults to false.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {int} maxUnsentMessages The maximum number of unsent messages to queue before&#10; *    further calls to send() will fail. A value of 0 means no limit.&#10; *    This defaults to 100.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available (the default).&#10; *    If false, data may be accumulated until a reasonable packet size is formed&#10; *    in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See above.&#10; *  @parameter {int} reconnectAttempts The number of times to try to reconnect.&#10; *    If this is greater than 0, then a failure to attempt will trigger&#10; *    additional attempts. This defaults to 10.&#10; *  @parameter {int} reconnectInterval The time between reconnect attempts, in&#10; *    milliseconds. This defaults to 100.&#10; *  @parameter {boolean} reconnectOnClose If true, then if the connection is closed&#10; *    before this accessor is wrapped up, then attempt to reconnect.&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See above.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {boolean} trustAll Whether to trust servers. This defaults to false.&#10; *    Setting it to true means that if sslTls is set to true, then&#10; *    any certificate provided by the server will be trusted.&#10; *    FIXME: Need to provide a trusted list if this is false.&#10; *&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;/* These are needed by JSLint, see https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSLint */&#10;&quot;use strict&quot;;&#10;/*global addInputHandler, error, get, getParameter, input, onClose, output, parameter, removeInputHandler, send */&#10;&#10;var socket = require('socket');&#10;var client = null;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    input('toSend');&#10;    output('connected', {&#10;        type : 'boolean'&#10;    });&#10;    output('received');&#10;&#10;    // The most used parameters are listed first.&#10;    parameter('host', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    &#10;    // The remaining parameters are in alphabetical order.&#10;    parameter('connectTimeout', {&#10;        value: 6000,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('discardMessagesBeforeOpen', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('idleTimeout', {&#10;        value: 0,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('maxUnsentMessages', {&#10;        value: 100,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;        options : socket.supportedReceiveTypes()&#10;    });&#10;    parameter('reconnectAttempts', {&#10;        type : 'int',&#10;        value : 10&#10;    });&#10;    parameter('reconnectInterval', {&#10;        type : 'int',&#10;        value : 100&#10;    });&#10;    parameter('reconnectOnClose', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;        options : socket.supportedSendTypes()&#10;    });&#10;    parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('trustAll', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;};&#10;&#10;/** Handles input on 'toSend'. */&#10;exports.toSendInputHandler = function () {&#10;    client.send(get('toSend'));&#10;};&#10;&#10;/** Initializes accessor by attaching functions to inputs. */&#10;exports.initialize = function () {&#10;&#10;    client = new socket.SocketClient(getParameter('port'), getParameter('host'),&#10;        {&#10;            'connectTimeout' : getParameter('connectTimeout'),&#10;            'discardMessagesBeforeOpen' : getParameter('discardMessagesBeforeOpen'),&#10;            'idleTimeout' : getParameter('idleTimeout'),&#10;            'keepAlive' : getParameter('keepAlive'),&#10;            'maxUnsentMessages' : getParameter('maxUnsentMessages'),&#10;            'noDelay' : getParameter('noDelay'),&#10;            'rawBytes' : getParameter('rawBytes'),&#10;            'receiveBufferSize' : getParameter('receiveBufferSize'),&#10;            'receiveType' : getParameter('receiveType'),&#10;            'reconnectAttempts' : getParameter('reconnectAttempts'),&#10;            'reconnectInterval' : getParameter('reconnectInterval'),&#10;            'sendBufferSize' : getParameter('sendBufferSize'),&#10;            'sendType' : getParameter('sendType'),&#10;            'sslTls' : getParameter('sslTls'),&#10;            'trustAll' : getParameter('trustAll'),&#10;        }&#10;    );&#10;&#10;    client.on('open', function() {&#10;        console.log('Status: Connection established');&#10;        send('connected', true);&#10;    });&#10;    client.on('data', function(data) {&#10;        send('received', data);&#10;    });&#10;&#10;    // Record the object that calls it (could be a derived accessor).&#10;    var callObj = this;&#10;&#10;    // Bind onClose() to caller's object, so that 'this' is defined&#10;    // in onClose() to be the object on which this initialize() function&#10;    // is called.&#10;    client.on('close', onClose.bind(callObj));&#10;    client.on('error', function (message) {&#10;        error(message);&#10;    });&#10;    addInputHandler('toSend', exports.toSendInputHandler.bind(callObj));&#10;};&#10;&#10;/** Send false to 'connected' output, and if 'reconnectOnClose'&#10; *  parameter evaluates to true and wrapup() has not been called,&#10; *  then invoke initialize().&#10; *  This will be called if either side closes the connection.&#10; *  @param message Possible message about the closure.&#10; */&#10;function onClose(message) {&#10;    console.log('Status: Connection closed: ' + message);&#10;    if (inputHandle) {&#10;        // wrapup() has not been called.&#10;        // Probably the server closed the connection.&#10;        send('connected', false);&#10;&#10;        // Close and unregister everything.&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client = null;&#10;&#10;        // Reconnect if reconnectOnClose is true.&#10;        if (getParameter('reconnectOnClose')) {&#10;            // Use 'this' rather than 'export' so initialize() can be overridden.&#10;            this.initialize();&#10;        }&#10;    }&#10;}&#10;&#10;/** Export the isOpen() function */&#10;exports.isOpen = function () {&#10;    return client.isOpen();&#10;}&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (client) {&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;        client = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/TCPSocketClient.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="host" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-70.0, 10.0}">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.Clock">
        <property name="offsets" class="ptolemy.data.expr.Parameter" value="{1.0, 2.0}">
        </property>
        <property name="values" class="ptolemy.data.expr.Parameter" value="{1, 2}">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-75.0, 135.0}">
        </property>
    </entity>
    <entity name="Ramp" class="ptolemy.actor.lib.Ramp">
        <doc>Create a sequence of tokens with increasing value</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{120.0, 145.0}">
        </property>
    </entity>
    <entity name="ServerErrors" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={920, 25, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[370.0, 215.0]">
        </property>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;Client1Received.input&quot;,x=380.0,y=20.0}, tail={id=&quot;TCPSocketClient1.received&quot;,x=240.0,y=10.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;Client2Received.input&quot;,x=75.0,y=20.0}, tail={id=&quot;TCPSocketClient2.received&quot;,x=-70.0,y=10.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;ServerConnected.input&quot;,x=415.0,y=125.0}, tail={id=&quot;TCPSocketServer.connection&quot;,x=270.0,y=135.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="{35.0, 135.0}">
        </vertex>
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;Ramp.trigger&quot;,x=120.0,y=145.0}, tail={id=&quot;relation4.vertex1&quot;,x=35.0,y=135.0}, points={} },{ head={id=&quot;DiscreteClock.output&quot;,x=-75.0,y=135.0}, tail={id=&quot;relation4.vertex1&quot;,x=35.0,y=135.0}, points={} },{ head={id=&quot;TCPSocketServer.toSendID&quot;,x=270.0,y=135.0}, tail={id=&quot;relation4.vertex1&quot;,x=35.0,y=135.0}, points={180.0,125.0,180.0,100.0,35.0,100.0} } }">
        </property>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.actor.LayoutHint" value="{ { head={id=&quot;TCPSocketServer.toSend&quot;,x=270.0,y=135.0}, tail={id=&quot;Ramp.output&quot;,x=120.0,y=145.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="ServerConnected.input" relation="relation3"/>
    <link port="Client1Received.input" relation="relation"/>
    <link port="TCPSocketClient1.received" relation="relation"/>
    <link port="TCPSocketServer.error" relation="relation6"/>
    <link port="TCPSocketServer.toSendID" relation="relation4"/>
    <link port="TCPSocketServer.toSend" relation="relation2"/>
    <link port="TCPSocketServer.connection" relation="relation3"/>
    <link port="Client2Received.input" relation="relation5"/>
    <link port="TCPSocketClient2.received" relation="relation5"/>
    <link port="DiscreteClock.output" relation="relation4"/>
    <link port="Ramp.output" relation="relation2"/>
    <link port="Ramp.trigger" relation="relation4"/>
    <link port="ServerErrors.input" relation="relation6"/>
</entity>
