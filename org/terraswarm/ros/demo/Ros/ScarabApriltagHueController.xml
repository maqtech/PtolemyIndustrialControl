<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="ScarabApriltTagHueController" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={251, 124, 972, 658}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[758, 569]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.000000000000006">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{148.56219059406004, 81.35017017326734}">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="Infinity">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[145.0, 15.0]">
        </property>
    </property>
    <entity name="RosSubscriber_tf" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor subscribes to a ROS topic.&lt;br&gt;&#10; *  It communicates to ROS through the rosbridge web socket, and extends the &#10; *  WebSocketClient accessor to do so. &#10; *  It has a 'topic' parameter, that must be prefixed with a '/' eg: '/noise'.&lt;br&gt; &#10; *&#10; *  @accessor RosSubscriber&#10; *  @parameter {string} server The IP address or domain name of server.&#10; *  @parameter {number} port The port that the web socket listens to.&#10; *  @parameter {string} topic The ROS topic to subscribe to.&#10; *  @output {boolean} connected The status of the web socket connection.&#10; *  @output {JSON} received The data received from the web socket server.&#10; *  @author Marcus Pan &#10; *  @version $$Id$$ &#10; *&#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs, outputs and parameters from setup() in WebSocketClient.&lt;br&gt;&#10; *  Adds a 'topic' input which is the ROS topic to subscribe to. */&#10;exports.setup = function() {&#10;&#10;   extend('WebSocketClient');&#10;&#10;   parameter('topic', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;   &#10;}&#10;&#10;/** Overrides the toSendInputHandler to throw an error if called. A subscriber should not be publishing inputs. */&#10;exports.toSendInputHandler = function() {&#10;   console.error('This is a subscriber and does not take input to publish.');&#10;}&#10;&#10;/** Inherits initialize from webSocketClient.&lt;br&gt;&#10;    Sends a message to rosbridge to start subscribing to the topic on input 'topic'.*/ &#10;exports.initialize = function() {&#10;  Object.getPrototypeOf(exports).initialize.apply(this);&#10;&#10;  exports.sendToWebSocket({&#10;      &quot;op&quot;: &quot;subscribe&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;  });&#10;}&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/RosSubscriber.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="192.168.131.15">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="1000">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/tf">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-55.0, 275.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="toSend" class="ptolemy.kernel.util.StringAttribute" value="The data to be send to the web socket server, in JSON format.">
            </property>
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Hue2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.  // All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor controls a Philips Hue lightbulb.&#10; *  &lt;p&gt;&#10; *  It sets the parameters of the specified&#10; *  light according to the input values.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Logging on: This script attempts to access the bridge as a user with&#10; *  name given by &lt;i&gt;userName&lt;/i&gt;, which defaults to &quot;ptolemyuser&quot;.&#10; *  If there is no such user on the bridge, the script registers such a user and requests&#10; *  (via an alert dialog) that the&#10; *  link button on the bridge be pushed to authorize registration of this user.&#10; *  The user is given 20s to do this before an exception is thrown&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Verifying the light: The final initialization step is to get a list of accessible lights. &#10; *  If the input light is not accessible, this accessor throws&#10; *  an exception, where the error message provides a list of available lights.&#10; *  &lt;/p&gt;&lt;p&gt;&#10; *  Discovery: Finding the IP address of the Hue Bridge is not necessarily easy.&#10; *  The bridge acquires its address via DHCP, so the address will typically change&#10; *  each time the bridge is rebooted. Moreover, the address will likely not be&#10; *  accessible except on the local network.  The bridge responds to UPnP packets&#10; *  (universal plug-and-play), so it is possible to use software such as&#10; *  &lt;a href=&quot;http://4thline.org/projects/cling/&quot;&gt;Cling&lt;/a&gt; to discover the bridge.&#10; *  Ideally, UPnP discover would be provided via an accessor. In this case, a&#10; *  swarmlet could be created that runs periodically on a local network and publishes&#10; *  the URL of any discovered bridges to a key-value store. Then the KeyValueStore&#10; *  accessor could be used to provide the &lt;i&gt;bridgeIPAdress&lt;/i&gt; input to this accessor.&#10; *  &lt;/p&gt;&#10; *  @accessor Hue&#10; *  @input {string} bridgeIPAddress The bridge IP address (and port, if needed).&#10; *  @parameter {string} userName The user name for logging on to the Hue Bridge. This must be at least 11 characters, or the Hue regards it as invalid.&#10; *  @input {int} lightID The light identifier (an integer beginning with 1).&#10; *  @input {number} brightness The brightness (an integer between 0 and 255).&#10; *  @input {number} hue The hue (an integer between 0 and 62580).&#10; *  @input {number} saturation The saturation (an integer between 0 and 255).&#10; *  @output {boolean} on Whether the light is on (true) or off (false).&#10; *  @input {int} transitionTime The transition time, in multiples of 100ms.&#10; *  @input {int} trigger Triggers a PUT request with all the light settings. Can be any type.&#10; *  @author Edward A. Lee, Marcus Pan &#10; *  @version $$Id$$ &#10; *&#10;*/&#10;&#10;&#10;// State variables.&#10;var timeout = 3000;&#10;var url = &quot;&quot;;&#10;var userName = &quot;&quot;;&#10;var reachableLights = [];&#10;var changedLights = [];&#10;var strReachableLights = &quot;&quot;;&#10;var handleRegisterUser;&#10;var registerInterval = 2000;&#10;var registerTimeout = 20000;&#10;var registerAttempts = 0;&#10;var handlers = [];&#10;var triggerHandle;&#10;&#10;// Uncomment the following to see the URL being used for the bridge.&#10;// alert(&quot;Connecting to: &quot; + bridge);&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function() {&#10;  input('bridgeIPAddress', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;&quot;&#10;  });&#10;  parameter('userName', {&#10;    type: &quot;string&quot;,&#10;    value: &quot;ptolemyuser&quot;&#10;  });&#10;  input('lightID', {&#10;    type: &quot;int&quot;,&#10;    value: 1&#10;  });&#10;  input('brightness', {&#10;    type: &quot;number&quot;,&#10;    value: 255&#10;  });&#10;  input('hue', {&#10;    type: &quot;number&quot;,&#10;    value: 65280&#10;  });&#10;  input('saturation', {&#10;    type: &quot;number&quot;,&#10;    value: 255 &#10;  });&#10;  input('on', {&#10;    type: &quot;boolean&quot;,&#10;    value: false&#10;  });&#10;  input('transitionTime', {&#10;    type: &quot;int&quot;,&#10;    value: 4&#10;  });&#10;  input('trigger', {value: true})&#10;}&#10;/** Initialize connection. &#10; *  Register user if not registered &#10; *  Input handlers are not added here in case we need to wait for user to regiter */&#10;exports.initialize = function() {&#10;   var ipAddress = get('bridgeIPAddress');&#10;   userName = getParameter('userName');&#10;&#10;   if (userName.length &lt; 11) {&#10;      throw &quot;Username too short. Hue only accepts usernames that contain at least 11 characters.&quot;;&#10;   }&#10;&#10;   if (ipAddress == null || ipAddress.trim() == &quot;&quot;) {&#10;      throw &quot;No IP Address is given for the Hue Bridge.&quot;;&#10;   }&#10;&#10;   url = &quot;http://&quot; + ipAddress + &quot;/&quot;;&#10;&#10;   // First make sure the bridge is actually there and responding.&#10;   try {&#10;      httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout);&#10;   } catch ( ex) {&#10;      // FIXME: We should do a UPnP discovery here and find a bridge.&#10;      throw &quot;No Hue bridge responding at &quot; + url + &quot;\n&quot; + ex;&#10;   }&#10;   url = url + &quot;api/&quot;;&#10;&#10;   // Next, make sure that input username is an authorized user. If not, register the user.&#10;   var lights = JSON.parse(httpRequest(url + userName + &quot;/&quot;, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   if (isNonEmptyArray(lights) &amp;&amp; lights[0].error) {&#10;      var description = lights[0].error.description;&#10;&#10;      if (description.match(&quot;unauthorized user&quot;)) {&#10;         // Add this user.&#10;         alert(userName + &quot; is not a registered user.\n&quot; + &#10;            &quot; Push the link button on the Hue bridge to register.&quot;); &#10;         registerUser();&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;      &#10;   } else if (lights.lights) {&#10;      //proceed to next stage of initialization&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Unknown error. Could not authorize user.&quot;;&#10;   }&#10;}&#10;&#10;/** Register a new user. &#10;  * This function repeats at registerInterval until registration is successful, or until registerTimeout. &#10;  * It does so because it needs to wait until the user clicks&#10;  * the button on the Hue bridge. */&#10;function registerUser() {&#10;   var registerData = '{&quot;devicetype&quot;:&quot;' + userName + '&quot;, &quot;username&quot;:&quot;' + userName + '&quot;}';&#10;   var response = JSON.parse(httpRequest(url, &quot;POST&quot;, null, registerData, timeout));&#10;   console.log(response);&#10;   if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;      var description = response[0].error.description;&#10;&#10;      if (description.match(&quot;link button not pressed&quot;)) {&#10;         //repeat registration attempt unless registerTimeout has been reached&#10;         console.log('link button');&#10;         registerAttempts++;&#10;         if ((registerAttempts * registerInterval) &gt; registerTimeout) {&#10;            throw &quot;Failed to create user after &quot; + registerTimeout/1000 + &#10;               &quot;s.&quot;;&#10;         }&#10;         handleRegisterUser = setTimeout(registerUser, registerInterval);&#10;         return;&#10;      }&#10;&#10;      else {&#10;         throw description;&#10;      }&#10;&#10;   } else if (isNonEmptyArray(response) &amp;&amp; response[0].success) {&#10;      //registration is successful - proceed to next stage of initialization&#10;      if (handleRegisterUser != null) {&#10;         clearTimeout(handleRegisterUser);&#10;      }&#10;      getReachableLights();&#10;&#10;   } else {&#10;      throw &quot;Error registering new user&quot;;&#10;   }&#10;}&#10;&#10;/** This function is only called after user has been registered. &#10;  * Get reachable lights. &#10;  * Add input handlers */&#10;function getReachableLights() {&#10;   url = url + userName + &quot;/&quot; + &quot;lights/&quot;;&#10;   var lights = JSON.parse(httpRequest(url, &quot;GET&quot;, null, &quot;&quot;, timeout));&#10;&#10;   try {&#10;      for (var id in lights) {&#10;         if (lights[id].state.reachable) {&#10;            reachableLights.push(id);&#10;           //record string of reachable lights &#10;            if (strReachableLights.length == 0) {&#10;               strReachableLights += id;&#10;            }&#10;            else {&#10;               strReachableLights += &quot;, &quot; + id;&#10;            }&#10;         }&#10;      }&#10;   } catch (e) {&#10;      throw &quot;Failed to access the state of light &quot;&#10;         &quot; at URL &quot; + url + &quot;\n&quot; + e;&#10;   }&#10;   if (strReachableLights.length == 0) {&#10;      strReachableLights = &quot;No lights are reachable&quot;;&#10;   }&#10;   strReachableLights += &quot;.&quot;;&#10;   console.log('reachable lights: ' + strReachableLights);&#10;/*&#10;   handlers.push(addInputHandler('brightness', inputHandler));&#10;   handlers.push(addInputHandler('hue', inputHandler));&#10;   handlers.push(addInputHandler('saturation', inputHandler));&#10;   handlers.push(addInputHandler('on', inputHandler));&#10;   handlers.push(addInputHandler('transitionTime', inputHandler));&#10;   handlers.push(addInputHandler('lightID', inputHandler));&#10;*/&#10;   triggerHandle = addInputHandler('trigger', inputHandler);&#10;}&#10;&#10;/** Get light settings from inputs and PUT */&#10;function inputHandler() {&#10;   //check if light is reachable&#10;   var lightID = get('lightID').toString();&#10;   if (reachableLights.indexOf(lightID) == -1) {&#10;      throw &quot;Light &quot; + lightID + &quot; is not reachable at &quot; + &#10;         url + &quot;.\n Reachable lights are &quot; + strReachableLights;&#10;   }&#10;   //keep track of changed lights to turn off during wrap up&#10;   if (changedLights.indexOf(lightID) == -1) {&#10;      changedLights.push(lightID);&#10;   }&#10;&#10;   //get inputs and send command to light&#10;   var command = {&#10;      on: get('on') == true,&#10;      bri: limit(get('brightness'), 0, 255),&#10;      hue: limit(get('hue'), 0, 65280),&#10;      sat: limit(get('saturation'), 0, 255),&#10;      transitiontime: limit(get('transitionTime'), 0, 65535)&#10;   }&#10;&#10;   var cmd = JSON.stringify(command);&#10;   try {&#10;      var response = httpRequest(url + lightID + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, cmd, timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         throw &quot;Server responds with error: &quot; + response[0].error.description;&#10;      }&#10;   } catch(e) {&#10;      throw &quot;Error accessing network: &quot; + e;&#10;   }&#10;}&#10;&#10;/** Turn off changed lights on wrapup. */&#10;exports.wrapup = function() {&#10;   /*&#10;   for (var i = 0; i &lt; handlers.length; i++) {&#10;      removeInputHandler(handlers[i]);&#10;   }&#10;   */&#10;   if (triggerHandle) {&#10;      removeInputHandler(triggerHandle);&#10;   }&#10;&#10;   var errorLights = [];&#10;   for (var i = 0; i &lt; changedLights.length; i++) {&#10;      var response = httpRequest(url + changedLights[i] + &quot;/state/&quot;, &quot;PUT&quot;, &#10;            null, '{&quot;on&quot;:false}', timeout);&#10;      console.log(response);&#10;      if (isNonEmptyArray(response) &amp;&amp; response[0].error) {&#10;         errorLights.push(lightID); &#10;      }&#10;   }&#10;&#10;   if (errorLights.length != 0) {&#10;      throw &quot;Error turning of lights &quot; + errorLights.toString();&#10;   }&#10;}&#10;&#10;/** utility function to check that an object is a nonempty array */&#10;function isNonEmptyArray(obj) {&#10;   return (obj instanceof Array &amp;&amp; obj.length &gt; 0);&#10;}&#10;&#10;/** Utility function to limit the range of a number&#10; * and to force it to be an integer. If the value argument&#10; * is a string, then it will be converted to a Number. */&#10;function limit(value, low, high) {&#10;   var parsed = parseInt(value);&#10;   if (!parsed) {&#10;      throw &quot;Expected a number between &quot; + low + &quot; and &quot; + high + &quot;, but got &quot; + value;&#10;   }&#10;   if (parsed &lt; low) {&#10;      return low;&#10;   } else if (parsed &gt; high) {&#10;      return high;&#10;   } else {&#10;      return parsed;&#10;   }&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/home/marcuspan/ptII/org/terraswarm/accessor/accessors/web/Hue.js">
        </property>
        <property name="bridgeIPAddress" class="ptolemy.actor.parameters.PortParameter" value="&quot;192.168.131.17&quot;">
        </property>
        <property name="userName" class="ptolemy.data.expr.StringParameter" value="ptolemyuser">
        </property>
        <property name="lightID" class="ptolemy.actor.parameters.PortParameter" value="2">
        </property>
        <property name="brightness" class="ptolemy.actor.parameters.PortParameter" value="255">
        </property>
        <property name="hue" class="ptolemy.actor.parameters.PortParameter" value="41720.0">
        </property>
        <property name="saturation" class="ptolemy.actor.parameters.PortParameter" value="255">
        </property>
        <property name="on" class="ptolemy.actor.parameters.PortParameter" value="false">
        </property>
        <property name="transitionTime" class="ptolemy.actor.parameters.PortParameter" value="4">
        </property>
        <property name="trigger" class="ptolemy.actor.parameters.PortParameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[505.0, 115.0]">
        </property>
        <port name="bridgeIPAddress" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="lightID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="brightness" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="hue" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="saturation" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="on" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="transitionTime" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="trigger" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <entity name="RosSubscriber_tag_detections_mapped" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor subscribes to a ROS topic.&lt;br&gt;&#10; *  It communicates to ROS through the rosbridge web socket, and extends the &#10; *  WebSocketClient accessor to do so. &#10; *  It has a 'topic' parameter, that must be prefixed with a '/' eg: '/noise'.&lt;br&gt; &#10; *&#10; *  @accessor RosSubscriber&#10; *  @parameter {string} server The IP address or domain name of server.&#10; *  @parameter {number} port The port that the web socket listens to.&#10; *  @parameter {string} topic The ROS topic to subscribe to.&#10; *  @output {boolean} connected The status of the web socket connection.&#10; *  @output {JSON} received The data received from the web socket server.&#10; *  @author Marcus Pan &#10; *  @version $$Id$$ &#10; *&#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs, outputs and parameters from setup() in WebSocketClient.&lt;br&gt;&#10; *  Adds a 'topic' input which is the ROS topic to subscribe to. */&#10;exports.setup = function() {&#10;&#10;   extend('WebSocketClient');&#10;&#10;   parameter('topic', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;   &#10;}&#10;&#10;/** Overrides the toSendInputHandler to throw an error if called. A subscriber should not be publishing inputs. */&#10;exports.toSendInputHandler = function() {&#10;   console.error('This is a subscriber and does not take input to publish.');&#10;}&#10;&#10;/** Inherits initialize from webSocketClient.&lt;br&gt;&#10;    Sends a message to rosbridge to start subscribing to the topic on input 'topic'.*/ &#10;exports.initialize = function() {&#10;  Object.getPrototypeOf(exports).initialize.apply(this);&#10;&#10;  exports.sendToWebSocket({&#10;      &quot;op&quot;: &quot;subscribe&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;  });&#10;}&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/RosSubscriber.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="192.168.131.15">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="1000">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/tag_detections_mapped">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-185.0, 200.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="toSend" class="ptolemy.kernel.util.StringAttribute" value="The data to be send to the web socket server, in JSON format.">
            </property>
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosSubscriber_moveResult" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor subscribes to a ROS topic.&lt;br&gt;&#10; *  It communicates to ROS through the rosbridge web socket, and extends the &#10; *  WebSocketClient accessor to do so. &#10; *  It has a 'topic' parameter, that must be prefixed with a '/' eg: '/noise'.&lt;br&gt; &#10; *&#10; *  @accessor RosSubscriber&#10; *  @parameter {string} server The IP address or domain name of server.&#10; *  @parameter {number} port The port that the web socket listens to.&#10; *  @parameter {string} topic The ROS topic to subscribe to.&#10; *  @output {boolean} connected The status of the web socket connection.&#10; *  @output {JSON} received The data received from the web socket server.&#10; *  @author Marcus Pan &#10; *  @version $$Id$$ &#10; *&#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs, outputs and parameters from setup() in WebSocketClient.&lt;br&gt;&#10; *  Adds a 'topic' input which is the ROS topic to subscribe to. */&#10;exports.setup = function() {&#10;&#10;   extend('WebSocketClient');&#10;&#10;   parameter('topic', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;   &#10;}&#10;&#10;/** Overrides the toSendInputHandler to throw an error if called. A subscriber should not be publishing inputs. */&#10;exports.toSendInputHandler = function() {&#10;   console.error('This is a subscriber and does not take input to publish.');&#10;}&#10;&#10;/** Inherits initialize from webSocketClient.&lt;br&gt;&#10;    Sends a message to rosbridge to start subscribing to the topic on input 'topic'.*/ &#10;exports.initialize = function() {&#10;  Object.getPrototypeOf(exports).initialize.apply(this);&#10;&#10;  exports.sendToWebSocket({&#10;      &quot;op&quot;: &quot;subscribe&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;  });&#10;}&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/RosSubscriber.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="192.168.131.15">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="1000">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/move/result">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-85.0, 35.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="toSend" class="ptolemy.kernel.util.StringAttribute" value="The data to be send to the web socket server, in JSON format.">
            </property>
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosSubscriber_pose" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor subscribes to a ROS topic.&lt;br&gt;&#10; *  It communicates to ROS through the rosbridge web socket, and extends the &#10; *  WebSocketClient accessor to do so. &#10; *  It has a 'topic' parameter, that must be prefixed with a '/' eg: '/noise'.&lt;br&gt; &#10; *&#10; *  @accessor RosSubscriber&#10; *  @parameter {string} server The IP address or domain name of server.&#10; *  @parameter {number} port The port that the web socket listens to.&#10; *  @parameter {string} topic The ROS topic to subscribe to.&#10; *  @output {boolean} connected The status of the web socket connection.&#10; *  @output {JSON} received The data received from the web socket server.&#10; *  @author Marcus Pan &#10; *  @version $$Id$$ &#10; *&#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs, outputs and parameters from setup() in WebSocketClient.&lt;br&gt;&#10; *  Adds a 'topic' input which is the ROS topic to subscribe to. */&#10;exports.setup = function() {&#10;&#10;   extend('WebSocketClient');&#10;&#10;   parameter('topic', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;   &#10;}&#10;&#10;/** Overrides the toSendInputHandler to throw an error if called. A subscriber should not be publishing inputs. */&#10;exports.toSendInputHandler = function() {&#10;   console.error('This is a subscriber and does not take input to publish.');&#10;}&#10;&#10;/** Inherits initialize from webSocketClient.&lt;br&gt;&#10;    Sends a message to rosbridge to start subscribing to the topic on input 'topic'.*/ &#10;exports.initialize = function() {&#10;  Object.getPrototypeOf(exports).initialize.apply(this);&#10;&#10;  exports.sendToWebSocket({&#10;      &quot;op&quot;: &quot;subscribe&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;  });&#10;}&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/RosSubscriber.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="192.168.131.15">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="1000">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/pose">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-125.0, 125.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="toSend" class="ptolemy.kernel.util.StringAttribute" value="The data to be send to the web socket server, in JSON format.">
            </property>
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosPublisher_goal" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10; * During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &#10; * &lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists with a different type, no new topic will be established&#10; * &lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; *  On input from 'toSend', this accessor publishes that input to the &#10; *  aforementioned topic. &#10; *  The input from 'toSend' must be in JSON form, and must match the message&#10; *  datatype that the ROS topic is expecting. For example if ROS topic is &#10; *  expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; *  as follows:&#10; *  &lt;pre&gt; { &quot;data&quot;: &quot;hello world&quot; } &lt;/pre&gt;&#10; *  Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; *  &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; *  &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; *  This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&#10; *&#10; *  @accessor RosPublisher&#10; *  @parameter {string} topic The ROS topic to publish to.&#10; *  @parameter {string} ROStype The ROS datatype of the topic.&#10; *  @parameter {boolean} addHeader If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.&#10; *  @parameter {string} frame_id The frame_id of the header (only needed if a header is required).&#10; *  @author Marcus Pan &#10; *  @version $$Id$$ &#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs from setup() in WebSocketClient. Adds additional parameters regarding the ROS topic to publish to. */ &#10;exports.setup = function() {&#10;   extend('WebSocketClient');&#10;   parameter('topic', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('ROStype', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('addHeader', {&#10;      type: &quot;boolean&quot;,&#10;      value: false&#10;   });&#10;   parameter('frame_id', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;}&#10;&#10;/** Override inputHandler on 'toSend' from WebSocketClient */&#10;exports.toSendInputHandler = function() {&#10;   var msg = get('toSend');&#10;//add a header with a blank time and sequence info. This will be added by rosbridge.&#10;   if (getParameter('addHeader')) {&#10;      msg.header = {&#10;         &quot;frame_id&quot;: getParameter('frame_id')&#10;      };&#10;   }&#10;      &#10;   var data = {&#10;      &quot;op&quot;: &quot;publish&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;msg&quot;: msg &#10;   }&#10;&#10;   exports.sendToWebSocket(data);&#10;}&#10;&#10;/**  Inherits initialize from WebSocketClient. &#10; *   Advertise the topic we are publishing to.*/ &#10;exports.initialize = function() {&#10;   this.ssuper.initialize.apply(this);&#10;&#10;   var advertise = {&#10;      &quot;op&quot;: &quot;advertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;type&quot;: getParameter('ROStype')&#10;   };&#10; //  exports.sendToWebSocket(advertise);&#10;   &#10;}&#10;&#10;/** Unadvertise the topic and inherit wrapup from WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unadvertise = {&#10;      &quot;op&quot;: &quot;unadvertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   };&#10;//   exports.sendToWebSocket(unadvertise);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/home/marcuspan/ptII/org/terraswarm/accessor/accessors/web/RosPublisher.js">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="192.168.131.15">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/goal">
        </property>
        <property name="ROStype" class="ptolemy.data.expr.StringParameter" value="geometry_msgs/PoseStamped">
        </property>
        <property name="addHeader" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="frame_id" class="ptolemy.data.expr.StringParameter" value="map">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[355.0, -65.0]">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosPublisher_cancelWaypoint" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10; * During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &#10; * &lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists with a different type, no new topic will be established&#10; * &lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; *  On input from 'toSend', this accessor publishes that input to the &#10; *  aforementioned topic. &#10; *  The input from 'toSend' must be in JSON form, and must match the message&#10; *  datatype that the ROS topic is expecting. For example if ROS topic is &#10; *  expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; *  as follows:&#10; *  &lt;pre&gt; { &quot;data&quot;: &quot;hello world&quot; } &lt;/pre&gt;&#10; *  Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; *  &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; *  &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; *  This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&#10; *&#10; *  @accessor RosPublisher&#10; *  @parameter {string} topic The ROS topic to publish to.&#10; *  @parameter {string} ROStype The ROS datatype of the topic.&#10; *  @parameter {boolean} addHeader If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.&#10; *  @parameter {string} frame_id The frame_id of the header (only needed if a header is required).&#10; *  @author Marcus Pan &#10; *  @version $$Id$$ &#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs from setup() in WebSocketClient. Adds additional parameters regarding the ROS topic to publish to. */ &#10;exports.setup = function() {&#10;   extend('WebSocketClient');&#10;   parameter('topic', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('ROStype', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('addHeader', {&#10;      type: &quot;boolean&quot;,&#10;      value: false&#10;   });&#10;   parameter('frame_id', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;}&#10;&#10;/** Override inputHandler on 'toSend' from WebSocketClient */&#10;exports.toSendInputHandler = function() {&#10;   var msg = get('toSend');&#10;//add a header with a blank time and sequence info. This will be added by rosbridge.&#10;   if (getParameter('addHeader')) {&#10;      msg.header = {&#10;         &quot;frame_id&quot;: getParameter('frame_id')&#10;      };&#10;   }&#10;      &#10;   var data = {&#10;      &quot;op&quot;: &quot;publish&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;msg&quot;: msg &#10;   }&#10;&#10;   exports.sendToWebSocket(data);&#10;}&#10;&#10;/**  Inherits initialize from WebSocketClient. &#10; *   Advertise the topic we are publishing to.*/ &#10;exports.initialize = function() {&#10;   this.ssuper.initialize.apply(this);&#10;&#10;   var advertise = {&#10;      &quot;op&quot;: &quot;advertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;type&quot;: getParameter('ROStype')&#10;   };&#10; //  exports.sendToWebSocket(advertise);&#10;   &#10;}&#10;&#10;/** Unadvertise the topic and inherit wrapup from WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unadvertise = {&#10;      &quot;op&quot;: &quot;unadvertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   };&#10;//   exports.sendToWebSocket(unadvertise);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/home/marcuspan/ptII/org/terraswarm/accessor/accessors/web/RosPublisher.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="192.168.131.15">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="9090">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="/move/cancel">
        </property>
        <property name="ROStype" class="ptolemy.data.expr.StringParameter" value="actionlib_msgs/GoalID">
        </property>
        <property name="addHeader" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="frame_id" class="ptolemy.data.expr.StringParameter" value="map">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[425.0, 20.0]">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="ScarabAprilTagHue2" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="var moveResultHandle, tagDetectionsMappedHandle, tfHandle, sendToTagHandle;&#10;var cameraCoords;&#10;var currentTag = {id: 0};&#10;&#10;//vars to enumerate options for sendToTag function&#10;var current = 0;&#10;var next = 1;&#10;&#10;var unreachableCount = 0;&#10;&#10;exports.setup = function() {&#10;   input('moveResult', {type: 'JSON', value: {}});&#10;   input('pose', {type: 'JSON', value: {}});&#10;   input('tagDetectionsMapped', {type: 'JSON', value: {}});&#10;   input('tf', {type: 'JSON', value: {}});//frame transforms&#10;   output('waypoint', {type: 'JSON'});//pose msg to publish to /goal topic&#10;   output('cancelWaypoint', {type: 'JSON'});//abort msg to publish to /move/cancel topic&#10;   output('lightID', {type: 'int'});&#10;   output('hue', {type: 'int'});//hue of a Hue bulb&#10;   output('on', {type: 'boolean'});&#10;   output('trigger');&#10;   parameter('stopAtTagDuration', {type: 'number', value: 1000}); //time to spend at each tag before moving in ms&#10;   parameter('robotDistanceFromTag', {type: 'number', value: 0.1}); //distance from robot to tag in m &#10;   parameter('goalTolerance', {type: 'number', value: 0.2}); //the tolerance in distance (m) to conclude a robot has reached a tag&#10;   parameter('mapFrame', {type: 'string', value: 'map_hokuyo'});&#10;   parameter('cameraFrame', {type: 'string', value: 'foscam'});&#10;}&#10;&#10;&#10;exports.initialize = function() {&#10;   tfHandle = addInputHandler('tf', tfHandler);&#10;   tagDetectionsMappedHandle = addInputHandler('tagDetectionsMapped', &#10;         tagDetectionsMappedHandler);&#10;   moveResultHandle = addInputHandler('moveResult', moveResultHandler);&#10;}&#10;/** search transfroms for camera coords. Removes input handler after set */&#10;function tfHandler() {&#10;   console.log('looking for camera to  map transform');&#10;   //check transforms for camera pose&#10;   var transforms = get('tf').msg.transforms;&#10;   var map_frame = getParameter('mapFrame');&#10;   var camera_frame = getParameter('cameraFrame');&#10;   for (var i = 0; i &lt; transforms.length; i++) {&#10;      if (transforms[i].header.frame_id == map_frame &amp;&amp; &#10;         transforms[i].child_frame_id == camera_frame) {&#10;         cameraCoords = {&quot;x&quot;: transforms[i].transform.translation.x,&#10;                         &quot;y&quot;: transforms[i].transform.translation.y};&#10;         console.log(&quot;set camera coords&quot;);&#10;         //only need to set this once&#10;         removeInputHandler(tfHandle);&#10;      }&#10;   }&#10;&#10;}&#10;/**&#10; Only need a handle once. sendToTag is called next by the MoveStatusHandler&#10;*/&#10;function tagDetectionsMappedHandler() {&#10;   if (!cameraCoords) {&#10;      console.log('received tag detections but not camera coords yet. Will wait.');&#10;      return;&#10;   }&#10;   sendToTag(next, getParameter('robotDistanceFromTag'));&#10;   removeInputHandler(tagDetectionsMappedHandle);&#10;}&#10;  &#10;/** Checks the move status of the hfn goal/status topic. The status is &#10;  defined by the ROS actionlib and the ROS message at scarab_msgs/action/Move.action&#10;  If hfn goal is reached, check that tag is really within tolerance of the robot. &#10;  If not, resend to robot to current tag.&#10;*/&#10;  &#10;function moveResultHandler() {&#10;   var moveResult = get('moveResult').msg;&#10;   console.log(moveResult);&#10;   var moveStatus = get('moveResult').msg.result.final_status;&#10;   var goalID  = moveResult.goal_id;//id of goal&#10;   var finalStatus = moveResult.result.final_status//integer reporting status&#10;   var robotDistanceFromTag = getParameter('robotDistanceFromTag');&#10;   //moveStatus mapping: 0=FINISHED, 1=TIMEOUT, 2=STUCK, 3=NOTREADY, 4=UNREACHABLE&#10;   if (moveStatus == 0) {&#10;   //success&#10;      flashLight(currentTag.id);&#10;      unreachableCount = 0;&#10;      sendToTag(next);&#10;      sendToTagHandle = setTimeout(sendToTag, getParameter('stopAtTagDuration'), next, robotDistanceFromTag);&#10;      console.log('robot reached waypoint successfully. sending to next tag');&#10;   } else if (finalStatus == 4) {&#10;   //waypoint is unreachable. tag localization may not be accurate, resulting in a tag location deep in occupied space.  &#10;   //abort current waypoint and send new one with increased distance between waypoint and tag&#10;      cancelWaypoint();&#10;      unreachableCount++;&#10;      sendToTag(current, unreachableCount * robotDistanceFromTag);&#10;      console.log('waypoint cannot be reached. sending new one with increased distance betweeen waypoint and tag');&#10;    } else {&#10;     //problem encountered. abort previous goals and  send to current tag again. &#10;      cancelWaypoint();&#10;      sendToTag(current, robotDistanceFromTag);&#10;      console.log('robot is either stuck, not ready or too slow. sending waypoint again');&#10;   }&#10;}&#10;&#10;/** Utility functions to flash lights */&#10;function flashLight(id) {&#10;   send('lightID', id);&#10;   send('hue', 62580 * id/3);&#10;   send('on', true);&#10;   send('trigger', true);&#10;   setTimeout(offLight, 2000, id);&#10;}&#10;&#10;function offLight(id) {&#10;   send('lightID', id);&#10;   send('on', false);&#10;   send('trigger', true);&#10;}&#10;&#10;   &#10;/** Assume currentTag is still in the frame and get nextTag by ascending ID.&#10;    If stayOnCurrentTag is defined and true, nextTag is the current tag.&#10;    If can't get currentTag, set nextTag to the first tag. &#10;    Send to nextTag's position. &#10;    tag0 is on the robot. &#10;*/ &#10;function sendToTag(currentOrNext, distanceFromTag) {&#10;   var input = get('tagDetectionsMapped');  &#10;   console.log(input);&#10;   if (!input.msg) {&#10;      console.log('No detections received yet. Will check again');&#10;      setTimeout('sendToTag', 1000);&#10;      return;&#10;   }&#10;   if (!cameraCoords) {&#10;      console.log('No camera coords yet.  Will check again');&#10;      setTimeout('sendToTag', 1000);&#10;      return;&#10;   }&#10;&#10;   var detections = input.msg.detections;&#10;   detections.sort(function(a, b) {return a.id &gt; b.id});&#10;   console.log('got detections');&#10;&#10;   for (var i = 0; i &lt; detections.length; i++) {&#10;      if (detections[i].id == currentTag.id) {&#10;         if (currentOrNext == current) { &#10;            currentTag = detections[i];&#10;         } else {&#10;            currentTag = detections[(i+1) % detections.length];&#10;         }&#10;         break;&#10;      }&#10;      //current tag no longer exists. set to tag with smallest id.&#10;      //don't send to tag0 (on the robot)&#10;      if (i == detections.length - 1) {&#10;         currentTag = detections[1];&#10;      }&#10;   } &#10;   //tag frame: facing tag, x-&gt;right, y-&gt;up, z-&gt;toward you&#10;   //robot frame: facing robot, x-&gt;toward you, y-&gt;right, z-&gt;up&#10;   //send robot to face tag with separation specified by parameter, in the line from the camera to the tag&#10;   //format data accoding to ROS pose datatype, (cartesian position and quaternion orientation)&#10;   tagX = currentTag.pose.pose.position.x;&#10;   tagY = currentTag.pose.pose.position.y;&#10;   cameraX = cameraCoords.x;&#10;   cameraY = cameraCoords.y;&#10;&#10;   //get unit vector of direction from tag to camera&#10;   deltaX = cameraX - tagX;&#10;   deltaY = cameraY - tagY;&#10;   deltaLength = distance(deltaX, 0, deltaY, 0);&#10;&#10;   theta = Math.atan2(deltaY, deltaX) + Math.PI;&#10;&#10;   goal = {&#10;      pose: {&#10;         position: {&#10;            x: tagX + (distanceFromTag * deltaX / deltaLength), &#10;            y: tagY + (distanceFromTag * deltaY / deltaLength),&#10;            z: 0&#10;         },&#10;         orientation: {&#10;            x: 0,&#10;            y: 0,&#10;            z: Math.sin(0.5*theta),  &#10;            w: Math.cos(0.5*theta)&#10;         }&#10;      }&#10;   }&#10;   console.log('waypoint sent to tag ' + currentTag.id);&#10;   send('waypoint', goal); &#10;&#10;}&#10;&#10;function cancelWaypoint() {&#10;   //blank info aborts all goals for all time. This is fine, since we only send one goal at a time.&#10;   msg = {&#10;      stamp: {&#10;         secs: 0,&#10;         nsecs: 0&#10;      },&#10;      id: ''&#10;   }&#10;   send('cancelWaypoint', msg);&#10;}&#10;&#10;exports.wrapup = function() {&#10;   //abort all goals&#10;   cancelWaypoint();&#10;   //remove input handlers&#10;   if (moveResultHandle) {&#10;     removeInputHandler(moveResultHandle);&#10;   } &#10;   if (tagDetectionsMappedHandle) {&#10;     removeInputHandler(tagDetectionsMappedHandle);&#10;   } &#10;   if (tfHandle) {&#10;     removeInputHandler(tfHandle);&#10;   } &#10;   if (sendToTagHandle) {&#10;     removeInputHandler(sendToTagHandle);&#10;   } &#10;}&#10;&#10;/** utlity function to return distance between two points */&#10;function distance(x1, x2, y1, y2) {&#10;   return Math.sqrt(&#10;      Math.pow(x2 - x1, 2) + Math.pow(y2 -y1, 2)&#10;   );&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/home/marcuspan/ptII/org/terraswarm/accessor/accessors/my/ScarabAprilTagHue.js">
        </property>
        <property name="moveResult" class="ptolemy.actor.parameters.PortParameter" value="{msg = {header = {frame_id = &quot;&quot;, seq = 26, stamp = {nsecs = 893802878, secs = 1438370339}}, result = {final_status = 0}, status = {goal_id = {id = &quot;/goal_to_action-27-1438370328.012&quot;, stamp = {nsecs = 12429952, secs = 1438370328}}, status = 3, text = &quot;&quot;}}, op = &quot;publish&quot;, topic = &quot;/move/result&quot;}">
        </property>
        <property name="pose" class="ptolemy.actor.parameters.PortParameter" value="{}">
        </property>
        <property name="tagDetectionsMapped" class="ptolemy.actor.parameters.PortParameter" value="{msg = {detections = {{id = 1, pose = {header = {frame_id = &quot;map&quot;, seq = 0, stamp = {nsecs = 715417077, secs = 1438370363}}, pose = {orientation = {w = 0.2765996688051, x = 0.2313733691722, y = 0.624744210661, z = 0.6925703274761}, position = {x = -3.2141914374595, y = -1.3793557757392, z = -0.1698626611591}}}, size = 0}, {id = 3, pose = {header = {frame_id = &quot;map&quot;, seq = 0, stamp = {nsecs = 715417077, secs = 1438370363}}, pose = {orientation = {w = 0.4849005409118, x = 0.4461252943465, y = 0.4462642705861, z = 0.6055508962638}, position = {x = -0.2089017145493, y = 1.2914937672448, z = 0.2025723598065}}}, size = 0}, {id = 2, pose = {header = {frame_id = &quot;map&quot;, seq = 0, stamp = {nsecs = 715417077, secs = 1438370363}}, pose = {orientation = {w = 0.0920765962979, x = 0.0631566101766, y = 0.6738102234921, z = 0.7304196914944}, position = {x = -1.2514513944661, y = -1.8272749330105, z = 0.3008872107976}}}, size = 0}}}, op = &quot;publish&quot;, topic = &quot;/tag_detections_mapped&quot;}">
        </property>
        <property name="tf" class="ptolemy.actor.parameters.PortParameter" value="{msg = {transforms = {{child_frame_id = &quot;foscam&quot;, header = {frame_id = &quot;map&quot;, seq = 0, stamp = {nsecs = 715417077, secs = 1438370363}}, transform = {rotation = {w = -0.2633509568385, x = 0.5004068936887, y = 0.595761775246, z = -0.5703570122623}, translation = {x = 3.0282268865411, y = 2.3098901537053, z = 1.1708750729218}}}}}, op = &quot;publish&quot;, topic = &quot;/tf&quot;}">
        </property>
        <property name="stopAtTagDuration" class="ptolemy.data.expr.Parameter" value="1000.0">
        </property>
        <property name="robotDistanceFromTag" class="ptolemy.data.expr.Parameter" value="0.2">
        </property>
        <property name="goalTolerance" class="ptolemy.data.expr.Parameter" value="0.2">
        </property>
        <property name="mapFrame" class="ptolemy.data.expr.StringParameter" value="map">
        </property>
        <property name="cameraFrame" class="ptolemy.data.expr.StringParameter" value="foscam">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[165.0, 115.0]">
        </property>
        <port name="moveResult" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="pose" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="tagDetectionsMapped" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="tf" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="waypoint" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="cancelWaypoint" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="lightID" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="hue" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="on" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[65.0, 65.0]">
        </vertex>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[150.0, 215.0]">
        </vertex>
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="{10.0, 165.0}">
        </vertex>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="RosSubscriber_tf.received" relation="relation"/>
    <link port="Hue2.lightID" relation="relation5"/>
    <link port="Hue2.hue" relation="relation7"/>
    <link port="Hue2.on" relation="relation8"/>
    <link port="Hue2.trigger" relation="relation10"/>
    <link port="RosSubscriber_tag_detections_mapped.received" relation="relation4"/>
    <link port="RosSubscriber_moveResult.received" relation="relation9"/>
    <link port="RosSubscriber_pose.received" relation="relation3"/>
    <link port="RosPublisher_goal.toSend" relation="relation2"/>
    <link port="RosPublisher_cancelWaypoint.toSend" relation="relation6"/>
    <link port="ScarabAprilTagHue2.moveResult" relation="relation9"/>
    <link port="ScarabAprilTagHue2.pose" relation="relation3"/>
    <link port="ScarabAprilTagHue2.tagDetectionsMapped" relation="relation4"/>
    <link port="ScarabAprilTagHue2.tf" relation="relation"/>
    <link port="ScarabAprilTagHue2.waypoint" relation="relation2"/>
    <link port="ScarabAprilTagHue2.cancelWaypoint" relation="relation6"/>
    <link port="ScarabAprilTagHue2.lightID" relation="relation5"/>
    <link port="ScarabAprilTagHue2.hue" relation="relation7"/>
    <link port="ScarabAprilTagHue2.on" relation="relation8"/>
    <link port="ScarabAprilTagHue2.trigger" relation="relation10"/>
</entity>
